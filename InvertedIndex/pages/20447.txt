https://en.wikipedia.org/wiki/X86-64




x86-64 - Wikipedia



































Jump to content







Main menu





Main menu
move to sidebar
hide



		Navigation
	


Main pageContentsCurrent eventsRandom articleAbout WikipediaContact us





		Contribute
	


HelpLearn to editCommunity portalRecent changesUpload fileSpecial pages



















Search











Search






















Appearance
















Donate

Create account

Log in








Personal tools





Donate Create account Log in





		Pages for logged out editors learn more



ContributionsTalk




























Contents
move to sidebar
hide




(Top)





1
AMD64




Toggle AMD64 subsection





1.1
History








1.2
Implementations








1.3
Architectural features








1.4
Virtual address space details






1.4.1
Canonical form addresses








1.4.2
Page table structure








1.4.3
Operating system limits










1.5
Physical address space details








1.6
Operating modes






1.6.1
Long mode








1.6.2
Legacy mode








1.6.3
Protected mode








1.6.4
Real mode












2
Intel 64




Toggle Intel 64 subsection





2.1
History








2.2
Implementations








2.3
X86S








2.4
Advanced Performance Extensions










3
VIA's x86-64 implementation








4
Microarchitecture levels








5
Differences between AMD64 and Intel 64




Toggle Differences between AMD64 and Intel 64 subsection





5.1
Recent implementations








5.2
Older implementations










6
Adoption








7
Operating system compatibility and characteristics




Toggle Operating system compatibility and characteristics subsection





7.1
BSD






7.1.1
DragonFly BSD








7.1.2
FreeBSD








7.1.3
NetBSD








7.1.4
OpenBSD










7.2
DOS








7.3
Linux








7.4
macOS








7.5
Solaris








7.6
Windows










8
Video game consoles








9
Industry naming conventions








10
Licensing








11
See also








12
Notes








13
References








14
External links


















Toggle the table of contents







x86-64



35 languages




العربيةCatalàČeštinaDanskDeutschEestiΕλληνικάEspañolفارسیFrançais한국어हिन्दीItalianoעבריתMagyarമലയാളംBahasa MelayuNederlands日本語Norsk bokmålPolskiRomânăRuna SimiРусскийSimple EnglishSlovenčinaSlovenščinaСрпски / srpskiSvenskaไทยTürkçeУкраїнськаTiếng Việt粵語中文

Edit links











ArticleTalk





English

















ReadEditView history







Tools





Tools
move to sidebar
hide



		Actions
	


ReadEditView history





		General
	


What links hereRelated changesUpload filePermanent linkPage informationCite this pageGet shortened URLDownload QR code





		Print/export
	


Download as PDFPrintable version





		In other projects
	


Wikidata item





















Appearance
move to sidebar
hide










From Wikipedia, the free encyclopedia


64-bit version of x86 architecture
"Intel 64" redirects here. For the Intel 64-bit architecture in Itanium chips, see IA-64.
"x64" redirects here. For the New York City bus route, see X64 (New York City bus).


AMD Opteron, the first CPU to introduce the x86-64 extensions in April 2003
The five-volume set of the x86-64 Architecture Programmer's Manual, as published and distributed by AMD in 2002
x86-64 (also known as x64, x86_64, AMD64, and Intel 64)[note 1] is a 64-bit extension of the x86 instruction set architecture first announced in 1999. It introduces two new operating modes: 64-bit mode and compatibility mode, along with a new four-level paging mechanism.
In 64-bit mode, x86-64 supports significantly larger amounts of virtual memory and physical memory compared to its 32-bit predecessors, allowing programs to utilize more memory for data storage. The architecture expands the number of general-purpose registers from 8 to 16, all fully general-purpose, and extends their width to 64 bits.
Floating-point arithmetic is supported through mandatory SSE2 instructions in 64-bit mode. While the older x87 FPU and MMX registers are still available, they are generally superseded by a set of sixteen 128-bit vector registers (XMM registers). Each of these vector registers can store one or two double-precision floating-point numbers, up to four single-precision floating-point numbers, or various integer formats.
In 64-bit mode, instructions are modified to support 64-bit operands and 64-bit addressing mode.
The x86-64 architecture defines a compatibility mode that allows 16-bit and 32-bit user applications to run unmodified alongside 64-bit applications, provided the 64-bit operating system supports them.[11][note 2] Since the full x86-32 instruction sets remain implemented in hardware without the need for emulation, these older executables can run with little or no performance penalty,[13] while newer or modified applications can take advantage of new features of the processor design to achieve performance improvements. Also, processors supporting x86-64 still power on in real mode to maintain backward compatibility with the original 8086 processor, as has been the case with x86 processors since the introduction of protected mode with the 80286.
The original specification, created by AMD and released in 2000, has been implemented by AMD, Intel, and VIA. The AMD K8 microarchitecture, in the Opteron and Athlon 64 processors, was the first to implement it. This was the first significant addition to the x86 architecture designed by a company other than Intel. Intel was forced to follow suit and introduced a modified NetBurst family which was software-compatible with AMD's specification. VIA Technologies introduced x86-64 in their VIA Isaiah architecture, with the VIA Nano.
The x86-64 architecture was quickly adopted for desktop and laptop personal computers and servers which were commonly configured for 16 GiB (gibibytes) of memory or more. It has effectively replaced the discontinued Intel Itanium architecture (formerly IA-64), which was originally intended to replace the x86 architecture. x86-64 and Itanium are not compatible on the native instruction set level, and operating systems and applications compiled for one architecture cannot be run on the other natively.


AMD64[edit]
AMD64 logo
History[edit]
AMD64 (also variously referred to by AMD in their literature and documentation as “AMD 64-bit Technology” and “AMD x86-64 Architecture”) was created as an alternative to the radically different IA-64 architecture designed by Intel and Hewlett-Packard, which was backward-incompatible with IA-32, the 32-bit version of the x86 architecture. AMD originally announced AMD64 in 1999[14] with a full specification available in August 2000.[15] As AMD was never invited to be a contributing party for the IA-64 architecture and any kind of licensing seemed unlikely, the AMD64 architecture was positioned by AMD from the beginning as an evolutionary way to add 64-bit computing capabilities to the existing x86 architecture while supporting legacy 32-bit x86 code, as opposed to Intel's approach of creating an entirely new, completely x86-incompatible 64-bit architecture with IA-64.
The first AMD64-based processor, the Opteron, was released in April 2003.

Implementations[edit]
AMD's processors implementing the AMD64 architecture include Opteron, Athlon 64, Athlon 64 X2, Athlon 64 FX, Athlon II (followed by "X2", "X3", or "X4" to indicate the number of cores, and XLT models), Turion 64, Turion 64 X2, Sempron ("Palermo" E6 stepping and all "Manila" models), Phenom (followed by "X3" or "X4" to indicate the number of cores), Phenom II (followed by "X2", "X3", "X4" or "X6" to indicate the number of cores), FX, Fusion/APU and Ryzen/Epyc.

Architectural features[edit]
The primary defining characteristic of AMD64 is the availability of 64-bit general-purpose processor registers (for example, rax), 64-bit integer arithmetic and logical operations, and 64-bit virtual addresses.[16] The designers took the opportunity to make other improvements as well.
Notable changes in the 64-bit extensions include:

64-bit integer capability
All general-purpose registers (GPRs) are expanded from 32 bits to 64 bits, and all arithmetic and logical operations, memory-to-register and register-to-memory operations, etc., can operate directly on 64-bit integers. Pushes and pops on the stack default to 8-byte strides, and pointers are 8 bytes wide.
Additional registers
In addition to increasing the size of the general-purpose registers, the number of named general-purpose registers is increased from eight (i.e. eax, ebx, ecx, edx, esi, edi, esp, ebp) in x86 to 16 (i.e. rax, rbx, rcx, rdx, rsi, rdi, rsp, rbp, r8, r9, r10, r11, r12, r13, r14, r15). It is therefore possible to keep more local variables in registers rather than on the stack, and to let registers hold frequently accessed constants; arguments for small and fast subroutines may also be passed in registers to a greater extent.
AMD64 still has fewer registers than many RISC instruction sets (e.g. Power ISA has 32 GPRs; 64-bit ARM, RISC-V I, SPARC, Alpha, MIPS, and PA-RISC have 31) or VLIW-like machines such as the IA-64 (which has 128 registers). However, an AMD64 implementation may have far more internal registers than the number of architectural registers exposed by the instruction set (see register renaming). (For example, AMD Zen cores have 168 64-bit integer and 160 128-bit vector floating-point physical internal registers.)
Additional XMM (SSE) registers
Similarly, the number of 128-bit XMM registers (used for Streaming SIMD instructions) is also increased from 8 to 16.
The traditional x87 FPU register stack is not included in the register file size extension in 64-bit mode, compared with the XMM registers used by SSE2, which did get extended. The x87 register stack is not a simple register file although it does allow direct access to individual registers by low cost exchange operations.
Larger virtual address space
The AMD64 architecture defines a 64-bit virtual address format, of which the low-order 48 bits are used in current implementations.[11]: 120  This allows up to 256 TiB (248 bytes) of virtual address space. The architecture definition allows this limit to be raised in future implementations to the full 64 bits,[11]: 2 : 3 : 13 : 117 : 120  extending the virtual address space to 16 EiB (264 bytes).[17] This is compared to just 4 GiB (232 bytes) for the x86.[18]
This means that very large files can be operated on by mapping the entire file into the process's address space (which is often much faster than working with file read/write calls), rather than having to map regions of the file into and out of the address space.
Larger physical address space
The original implementation of the AMD64 architecture implemented 40-bit physical addresses and so could address up to 1 TiB (240 bytes) of RAM.[11]: 24  Current implementations of the AMD64 architecture (starting from AMD 10h microarchitecture)  extend this to 48-bit physical addresses[19] and therefore can address up to 256 TiB (248 bytes) of RAM. The architecture permits extending this to 52 bits in the future[11]: 24 [20] (limited by the page table entry format);[11]: 131  this would allow addressing of up to 4 PiB of RAM. For comparison, 32-bit x86 processors are limited to 64 GiB of RAM in Physical Address Extension (PAE) mode,[21] or 4 GiB of RAM without PAE mode.[11]: 4 
Larger physical address space in legacy mode
When operating in legacy mode the AMD64 architecture supports Physical Address Extension (PAE) mode, as do most current x86 processors, but AMD64 extends PAE from 36 bits to an architectural limit of 52 bits of physical address. Any implementation, therefore, allows the same physical address limit as under long mode.[11]: 24 
Instruction pointer relative data access
Instructions can now reference data relative to the instruction pointer (RIP register). This makes position-independent code, as is often used in shared libraries and code loaded at run time, more efficient.
SSE instructions
The original AMD64 architecture adopted Intel's SSE and SSE2 as core instructions. These instruction sets provide a vector supplement to the scalar x87 FPU, for the single-precision and double-precision data types. SSE2 also offers integer vector operations, for data types ranging from 8bit to 64bit precision. This makes the vector capabilities of the architecture on par with those of the most advanced x86 processors of its time. These instructions can also be used in 32-bit mode. The proliferation of 64-bit processors has made these vector capabilities ubiquitous in home computers, allowing the improvement of the standards of 32-bit applications. The 32-bit edition of Windows 8, for example, requires the presence of SSE2 instructions.[22] SSE3 instructions and later Streaming SIMD Extensions instruction sets are not standard features of the architecture.
No-Execute bit
The No-Execute bit or NX bit (bit 63 of the page table entry) allows the operating system to specify which pages of virtual address space can contain executable code and which cannot. An attempt to execute code from a page tagged "no execute" will result in a memory access violation, similar to an attempt to write to a read-only page. This should make it more difficult for malicious code to take control of the system via "buffer overrun" or "unchecked buffer" attacks. A similar feature has been available on x86 processors since the 80286 as an attribute of segment descriptors; however, this works only on an entire segment at a time.
Segmented addressing has long been considered an obsolete mode of operation, and all current PC operating systems in effect bypass it, setting all segments to a base address of zero and (in their 32-bit implementation) a size of 4 GiB. AMD was the first x86-family vendor to implement no-execute in linear addressing mode. The feature is also available in legacy mode on AMD64 processors, and recent Intel x86 processors, when PAE is used.
Removal of older features
A few "system programming" features of the x86 architecture were either unused or underused in modern operating systems and are either not available on AMD64 in long (64-bit and compatibility) mode, or exist only in limited form. These include segmented addressing (although the FS and GS segments are retained in vestigial form for use as extra-base pointers to operating system structures),[11]: 70  the task state switch mechanism, and virtual 8086 mode. These features remain fully implemented in "legacy mode", allowing these processors to run 32-bit and 16-bit operating systems without modifications. Some instructions that proved to be rarely useful are not supported in 64-bit mode, including saving/restoring of segment registers on the stack, saving/restoring of all registers (PUSHA/POPA), decimal arithmetic, BOUND and INTO instructions, and "far" jumps and calls with immediate operands.
Virtual address space details[edit]
Canonical form addresses[edit]
Canonical address space implementations (diagrams not to scale)Current 48-bit implementation57-bit implementation64-bit implementation
Although virtual addresses are 64 bits wide in 64-bit mode, current implementations (and all chips that are known to be in the planning stages) do not allow the entire virtual address space of 264 bytes (16 EiB) to be used. This would be approximately four billion times the size of the virtual address space on 32-bit machines. Most operating systems and applications will not need such a large address space for the foreseeable future, so implementing such wide virtual addresses would simply increase the complexity and cost of address translation with no real benefit. AMD, therefore, decided that, in the first implementations of the architecture, only the least significant 48 bits of a virtual address would actually be used in address translation (page table lookup).[11]: 120 
In addition, the AMD specification requires that the most significant 16 bits of any virtual address, bits 48 through 63, must be copies of bit 47 (in a manner akin to sign extension). If this requirement is not met, the processor will raise an exception.[11]: 131  Addresses complying with this rule are referred to as "canonical form."[11]: 130  Canonical form addresses run from 0 through 00007FFF'FFFFFFFF, and from FFFF8000'00000000 through FFFFFFFF'FFFFFFFF, for a total of 256 TiB of usable virtual address space. This is still 65,536 times larger than the virtual 4 GiB address space of 32-bit machines.
This feature eases later scalability to true 64-bit addressing. Many operating systems (including, but not limited to, the Windows NT family) take the higher-addressed half of the address space (named kernel space) for themselves and leave the lower-addressed half (user space) for application code, user mode stacks, heaps, and other data regions.[23] The "canonical address" design ensures that every AMD64 compliant implementation has, in effect, two memory halves: the lower half starts at 00000000'00000000 and "grows upwards" as more virtual address bits become available, while the higher half is "docked" to the top of the address space and grows downwards. Also, enforcing the "canonical form" of addresses by checking the unused address bits prevents their use by the operating system in tagged pointers as flags, privilege markers, etc., as such use could become problematic when the architecture is extended to implement more virtual address bits.
The first versions of Windows for x64 did not even use the full 256 TiB; they were restricted to just 8 TiB of user space and 8 TiB of kernel space.[23] Windows did not support the entire 48-bit address space until Windows 8.1, which was released in October 2013.[23]

Page table structure[edit]

The 64-bit addressing mode ("long mode") is a superset of Physical Address Extensions (PAE); because of this, page sizes may be 4 KiB (212 bytes) or 2 MiB (221 bytes).[11]: 120  Long mode also supports page sizes of 1 GiB (230 bytes).[11]: 120  Rather than the three-level page table system used by systems in PAE mode, systems running in long mode use four levels of page table: PAE's Page-Directory Pointer Table is extended from four entries to 512, and an additional Page-Map Level 4 (PML4) Table is added, containing 512 entries in 48-bit implementations.[11]: 131  A full mapping hierarchy of 4 KiB pages for the whole 48-bit space would take a bit more than 512 GiB of memory (about 0.195% of the 256 TiB virtual space).


64 bit page table entry


Bits:

63

62 ... 52

51 ... 32


Content:

NX

reserved

Bit 51...32 of base address


Bits:

31 ... 12

11 ... 9

8

7

6

5

4

3

2

1

0


Content:

Bit 31...12 of base address

ign.

G

PAT

D

A

PCD

PWT

U/S

R/W

P

Intel has implemented a scheme with a 5-level page table, which allows Intel 64 processors to support 57-bit addresses, and in turn, a 128 PiB virtual address space.[24] Further extensions may allow full 64-bit virtual address space and physical memory with 12-bit page table descriptors and 16- or 21-bit memory offsets for 64 KiB and 2 MiB page allocation sizes; the page table entry would be expanded to 128 bits to support additional hardware flags for page size and virtual address space size.[25]

Operating system limits[edit]
The operating system can also limit the virtual address space. Details, where applicable, are given in the "Operating system compatibility and characteristics" section.

Physical address space details[edit]
Current AMD64 processors support a physical address space of up to 248 bytes of RAM, or 256 TiB.[19] However, as of 2020[update], there were no known x86-64 motherboards that support 256 TiB of RAM.[26][27][28][29][failed verification] The operating system may place additional limits on the amount of RAM that is usable or supported. Details on this point are given in the "Operating system compatibility and characteristics" section of this article.

Operating modes[edit]
The architecture has two primary modes of operation: long mode and legacy mode.



Operating

Operating system required

Type of code being run

Size (in bits)

No. of general-purpose registers


Mode

Sub-mode

Addresses

Operands (default in italics)


Long mode

64-bit mode

64-bit OS, 64-bit UEFI firmware, or the previous two interacting via a 64-bit firmware's UEFI interface

64-bit

64

8, 16, 32, 64

16


Compatibility mode

Bootloader or 64-bit OS

32-bit

32

8, 16, 32

8


16-bit protected mode

16

8, 16, 32

8


Legacy mode

Protected mode

Bootloader, 32-bit OS, 32-bit UEFI firmware, or the latter two interacting via the firmware's UEFI interface

32-bit

32

8, 16, 32

8


16-bit protected mode OS

16-bit protected mode

16

8, 16, 32[m 1]

8


Virtual 8086 mode

16-bit protected mode or 32-bit OS

subset of real mode

16

8, 16, 32[m 1]

8


Unreal mode

Bootloader or real mode OS

real mode

16, 20, 32

8, 16, 32[m 1]

8


Real mode

Bootloader, real mode OS, or any OS interfacing with a firmware's BIOS interface[30]

real mode

16, 20, 21

8, 16, 32[m 1]

8



^ a b c d Note that 16-bit code written for the 80286 and below does not use 32-bit operand instructions. Code written for the 80386 and above can use the operand-size override prefix (0x66). Normally this prefix is used by protected and long mode code for the purpose of using 16-bit operands, as that code would be running in a code segment with a default operand size of 32 bits. In real mode, the default operand size is 16 bits, so the 0x66 prefix is interpreted differently, changing operand size to 32 bits.


State diagram of the x86-64 operating modes
Long mode[edit]
Main article: Long mode
Long mode is the architecture's intended primary mode of operation; it is a combination of the processor's native 64-bit mode and a combined 32-bit and 16-bit compatibility mode. It is used by 64-bit operating systems. Under a 64-bit operating system, 64-bit programs run under 64-bit mode, and 32-bit and 16-bit protected mode applications (that do not need to use either real mode or virtual 8086 mode in order to execute at any time) run under compatibility mode. Real-mode programs and programs that use virtual 8086 mode at any time cannot be run in long mode unless those modes are emulated in software.[11]: 11  However, such programs may be started from an operating system running in long mode on processors supporting VT-x or AMD-V by creating a virtual processor running in the desired mode.
Since the basic instruction set is the same, there is almost no performance penalty for executing protected mode x86 code. This is unlike Intel's IA-64, where differences in the underlying instruction set mean that running 32-bit code must be done either in emulation of x86 (making the process slower) or with a dedicated x86 coprocessor. However, on the x86-64 platform, many x86 applications could benefit from a 64-bit recompile, due to the additional registers in 64-bit code and guaranteed SSE2-based FPU support, which a compiler can use for optimization. However, applications that regularly handle integers wider than 32 bits, such as cryptographic algorithms, will need a rewrite of the code handling the huge integers in order to take advantage of the 64-bit registers.

Legacy mode[edit]
Legacy mode is the mode that the processor is in when it is not in long mode.[11]: 14  In this mode, the processor acts like an older x86 processor, and only 16-bit and 32-bit code can be executed. Legacy mode allows for a maximum of 32 bit virtual addressing which limits the virtual address space to 4 GiB.[11]: 14 : 24 : 118  64-bit programs cannot be run from legacy mode.

Protected mode[edit]
Protected mode is made into a submode of legacy mode.[11]: 14  It is the submode that 32-bit operating systems and 16-bit protected mode operating systems operate in when running on an x86-64 CPU.[11]: 14 

Real mode[edit]
Real mode is the initial mode of operation when the processor is initialized, and is a submode of legacy mode. It is backwards compatible with the original Intel 8086 and Intel 8088 processors. Real mode is primarily used today by operating system bootloaders, which are required by the architecture to configure virtual memory details before transitioning to higher modes. This mode is also used by any operating system that needs to communicate with the system firmware with a traditional BIOS-style interface.[30]

Intel 64[edit]
Intel 64 is Intel's implementation of x86-64, used and implemented in various processors made by Intel.

History[edit]
Historically, AMD has developed and produced processors with instruction sets patterned after Intel's original designs, but with x86-64, roles were reversed: Intel found itself in the position of adopting the ISA that AMD created as an extension to Intel's own x86 processor line.
Intel's project was originally codenamed Yamhill[31] (after the Yamhill River in Oregon's Willamette Valley). After several years of denying its existence, Intel announced at the February 2004 IDF that the project was indeed underway. Intel's chairman at the time, Craig Barrett, admitted that this was one of their worst-kept secrets.[32][33]
Intel's name for this instruction set has changed several times. The name used at the IDF was CT[34] (presumably[original research?] for Clackamas Technology, another codename from an Oregon river); within weeks they began referring to it as IA-32e (for IA-32 extensions) and in March 2004 unveiled the "official" name EM64T (Extended Memory 64 Technology). In late 2006 Intel began instead using the name Intel 64 for its implementation, paralleling AMD's use of the name AMD64.[35]
The first processor to implement Intel 64 was the multi-socket processor Xeon code-named Nocona in June 2004. In contrast, the initial Prescott chips (February 2004) did not enable this feature. Intel subsequently began selling Intel 64-enabled Pentium 4s using the E0 revision of the Prescott core, being sold on the OEM market as the Pentium 4, model F. The E0 revision also adds eXecute Disable (XD) (Intel's name for the NX bit) to Intel 64, and has been included in then current Xeon code-named Irwindale. Intel's official launch of Intel 64 (under the name EM64T at that time) in mainstream desktop processors was the N0 stepping Prescott-2M.
The first Intel mobile processor implementing Intel 64 is the Merom version of the Core 2 processor, which was released on July 27, 2006. None of Intel's earlier notebook CPUs (Core Duo, Pentium M, Celeron M, Mobile Pentium 4) implement Intel 64.

Implementations[edit]
Intel's processors implementing the Intel64 architecture include the Pentium 4 F-series/5x1 series, 506, and 516, Celeron D models 3x1, 3x6, 355, 347, 352, 360, and 365 and all later Celerons, all models of Xeon since "Nocona", all models of Pentium Dual-Core processors since "Merom-2M", the Atom 230, 330, D410, D425, D510, D525, N450, N455, N470, N475, N550, N570, N2600 and N2800, all versions of the Pentium D, Pentium Extreme Edition, Core 2, Core i9, Core i7, Core i5, and Core i3 processors, and the Xeon Phi 7200 series processors.

X86S[edit]
X86S was a simplification of x86-64 first proposed by Intel in May 2023.[36] The new architecture would have removed support for 16-bit and 32-bit operating systems, although 32-bit programs would still run under a 64-bit OS. A compliant CPU would have no longer had legacy mode, and started directly in 64-bit long mode. There would have been a way to switch to 5-level paging without going through the unpaged mode. Specific removed features included:[37]


Segmentation gates
32-bit ring 0
VT-x will no longer emulate this feature
Rings 1 and 2
Ring 3 I/O port (IN/OUT) access; see port-mapped I/O
String port I/O (INS/OUTS)
Real mode (including huge real mode), 16-bit protected mode, VM86
16-bit addressing mode
VT-x will no longer provide unrestricted mode
8259 support; the only APIC supported would be X2APIC
Some unused operating system mode bits
16-bit and 32-bit Startup IPI (SIPI)

The draft specification received multiple updates, reaching version 1.2 by June 2024. It was eventually abandoned as of December 2024, following the formation of the x86 Ecosystem Advisory Group by Intel and AMD.[38]

Advanced Performance Extensions[edit]
Main article: x86 § APX (Advanced Performance Extensions)
Advanced Performance Extensions is a 2023 Intel proposal for new instructions and an additional 16 general-purpose registers.

VIA's x86-64 implementation[edit]
VIA Technologies introduced their first implementation of the x86-64 architecture in 2008 after five years of development by its CPU division, Centaur Technology.[39]
Codenamed "Isaiah", the 64-bit architecture was unveiled on January 24, 2008,[40] and launched on May 29 under the VIA Nano brand name.[41]
The processor supports a number of VIA-specific x86 extensions designed to boost efficiency in low-power appliances.
It is expected that the Isaiah architecture will be twice as fast in integer performance and four times as fast in floating-point performance as the previous-generation VIA Esther at an equivalent clock speed. Power consumption is also expected to be on par with the previous-generation VIA CPUs, with thermal design power ranging from 5 W to 25 W.[42]
Being a completely new design, the Isaiah architecture was built with support for features like the x86-64 instruction set and x86 virtualization which were unavailable on its predecessors, the VIA C7 line, while retaining their encryption extensions.

Microarchitecture levels[edit]
In 2020, through a collaboration between AMD, Intel, Red Hat, and SUSE, three microarchitecture levels (or feature levels) on top of the x86-64 baseline were defined: x86-64-v2, x86-64-v3, and x86-64-v4.[43][44] These levels define specific features that can be targeted by programmers to provide compile-time optimizations. The features exposed by each level are as follows:[45]


CPU microarchitecture levels


Level name

CPU features

Example instruction

Supported processors


(baseline)also as:x86-64-v1

CMOV
cmov

baseline for all x86-64 CPUs
matches the common capabilities between the 2003 AMD AMD64 and the 2004 Intel EM64T initial implementations in the AMD K8 and the Intel Prescott processor families



CX8
cmpxchg8b


FPU
fld


FXSR
fxsave


MMX
emms


OSFXSR
fxsave


SCE
syscall


SSE
cvtss2si


SSE2
cvtpi2pd


x86-64-v2

CMPXCHG16B
cmpxchg16b


Intel Nehalem and newer Intel "big" cores
Intel (Atom) Silvermont and newer Intel "small" cores
AMD Bulldozer and newer AMD "big" cores
AMD Jaguar
VIA Nano and Eden "C"
features match the 2008 Intel Nehalem architecture, excluding Intel-specific instructions



LAHF-SAHF
lahf


POPCNT
popcnt


SSE3
addsubpd


SSE4_1
blendpd


SSE4_2
pcmpestri


SSSE3
pshufb


x86-64-v3

AVX
vzeroall


Intel Haswell and newer Intel "big" cores (AVX2 enabled models only)
Intel (Atom) Gracemont and newer Intel "small" cores
AMD Excavator and newer AMD "big" cores
QEMU emulation (as of version 7.2)[46][47]
features match the 2013 Intel Haswell architecture, excluding Intel-specific instructions



AVX2
vpermd


BMI1
andn


BMI2
bzhi


F16C
vcvtph2ps


FMA
vfmadd132pd


LZCNT
lzcnt


MOVBE
movbe


OSXSAVE
xgetbv


x86-64-v4

AVX512F
kmovw


Intel Skylake and newer Intel "big" cores (AVX512 enabled models only)
AMD Zen 4 and newer AMD cores
features match the 2017 Intel Skylake-X architecture, excluding Intel-specific instructions



AVX512BW
vdbpsadbw


AVX512CD
vplzcntd


AVX512DQ
vpmullq


AVX512VL
—

The x86-64 microarchitecture feature levels can also be found as AMD64-v1, AMD64-v2 .. or AMD64_v1 .. in settings where the "AMD64" nomenclature is used. These are used as synonyms with the x86-64-vX nomenclature and are thus functionally identical. E.g. the Go language documentation or the Fedora linux distribution.
All levels include features found in the previous levels. Instruction set extensions not concerned with general-purpose computation, including AES-NI and RDRAND, are excluded from the level requirements.
On any x86_64 Linux distribution, all x86_64 feature levels supported by a CPU can be verified using command: ld.so --help The result will be visible at the end of command's output:

Subdirectories of glibc-hwcaps directories, in priority order:
x86-64-v4
x86-64-v3 (supported, searched)
x86-64-v2 (supported, searched)

Here x86-64-v4 feature level is not supported by CPU, but x86-64-v3 and x86-64-v2 are, which means this CPU does not support AVX512 required at v4 level.

Differences between AMD64 and Intel 64[edit]
Although nearly identical, there are some differences between the two instruction sets in the semantics of a few seldom used machine instructions (or situations), which are mainly used for system programming.[48] Unless instructed to otherwise via -march settings, compilers generally produce executables (i.e. machine code) that avoid any differences, at least for ordinary application programs. This is therefore of interest mainly to developers of compilers, operating systems and similar, which must deal with individual and special system instructions.

Recent implementations[edit]
Intel 64 allows SYSCALL/SYSRET only in 64-bit mode (not in compatibility mode),[49] and allows SYSENTER/SYSEXIT in both modes.[50] AMD64 lacks SYSENTER/SYSEXIT in both sub-modes of long mode.[11]: 33 
When returning to a non-canonical address using SYSRET, AMD64 processors execute the general protection fault handler in privilege level 3,[51] while on Intel 64 processors it is executed in privilege level 0.[52]
The SYSRET instruction will load a set of fixed values into the hidden part of the SS segment register (base-address, limit, attributes) on Intel 64 but leave the hidden part of SS unchanged on AMD64.[53]
AMD64 requires a different microcode update format and control MSRs (model-specific registers), while Intel 64 implements microcode update unchanged from their 32-bit only processors.
Intel 64 lacks some MSRs that are considered architectural in AMD64. These include SYSCFG, TOP_MEM, and TOP_MEM2.
Intel 64 lacks the ability to save and restore a reduced (and thus faster) version of the floating-point state (involving the FXSAVE and FXRSTOR instructions).[clarification needed]
In 64-bit mode, near branches with the 66H (operand size override) prefix behave differently. Intel 64 ignores this prefix: the instruction has a 32-bit sign extended offset, and instruction pointer is not truncated. AMD64 uses a 16-bit offset field in the instruction, and clears the top 48 bits of instruction pointer.
On Intel 64 but not AMD64, the REX.W prefix can be used with the far-pointer instructions (LFS, LGS, LSS, JMP FAR, CALL FAR) to increase the size of their far pointer argument to 80 bits (64-bit offset + 16-bit segment).
When the MOVSXD instruction is executed with a memory source operand and an operand-size of 16 bits, the memory operand will be accessed with a 16-bit read on Intel 64, but a 32-bit read on AMD64.
The FCOMI/FCOMIP/FUCOMI/FUCOMIP (x87 floating-point compare) instructions will clear the OF, SF and AF bits of EFLAGS on Intel 64, but leave these flag bits unmodified on AMD64.
For the VMASKMOVPS/VMASKMOVPD/VPMASKMOVD/VPMASKMOVQ (AVX/AVX2 masked move to/from memory) instructions, Intel 64 architecturally guarantees that the instructions will not cause memory faults (e.g. page-faults and segmentation-faults) for any zero-masked lanes, while AMD64 does not provide such a guarantee.
If the RDRAND instruction fails to obtain a random number (as indicated by EFLAGS.CF=0), the destination register is architecturally guaranteed to be set to 0 on Intel 64 but not AMD64.
For the VPINSRD and VPEXTRD (AVX vector lane insert/extract) instructions outside 64-bit mode, AMD64 requires the instructions to be encoded with VEX.W=0, while Intel 64 also accepts encodings with VEX.W=1. (In 64-bit mode, both AMD64 and Intel 64 require VEX.W=0.)
The 0F 0D /r opcode with the ModR/M byte's Mod field set to 11b is a Reserved-NOP on Intel 64[54] but will cause #UD (invalid-opcode exception) on AMD64.[55]
The ordering guarantees provided by some memory ordering instructions such as LFENCE and MFENCE differ between Intel 64 and AMD64:
LFENCE is dispatch-serializing (enabling it to be used as a speculation fence) on Intel 64 but is not architecturally guaranteed to be dispatch-serializing on AMD64.[56]
MFENCE is a fully serializing instruction (including instruction fetch serialization) on AMD64 but not Intel 64.
The MOV to CR8 and INVPCID instructions are serializing on AMD64 but not Intel 64.
The LMSW instruction is serializing on Intel 64 but not AMD64.
WRMSR to the x2APIC ICR (Interrupt Command Register; MSR 830h) is commonly used to produce an IPI (Inter-processor interrupt) — on Intel 64[57] but not AMD64[58] CPUs, such an IPI can be reordered before an older memory store.
Older implementations[edit]
This section needs to be updated. The reason given is: future tense relating to processors that have been out for years, dates with day and month but no year. Please help update this article to reflect recent events or newly available information. (January 2023)
The AMD64 processors prior to Revision F[59] (distinguished by the switch from DDR to DDR2 memory and new sockets AM2, F and S1) of 2006 lacked the CMPXCHG16B instruction, which is an extension of the CMPXCHG8B instruction present on most post-80486 processors. Similar to CMPXCHG8B, CMPXCHG16B allows for atomic operations on octa-words (128-bit values). This is useful for parallel algorithms that use compare and swap on data larger than the size of a pointer, common in lock-free and wait-free algorithms. Without CMPXCHG16B one must use workarounds, such as a critical section or alternative lock-free approaches.[60] Its absence also prevents 64-bit Windows prior to Windows 8.1 from having a user-mode address space larger than 8 TiB.[61] The 64-bit version of Windows 8.1 requires the instruction.[62]
Early AMD64 and Intel 64 CPUs lacked LAHF and SAHF instructions in 64-bit mode. AMD introduced these instructions (also in 64-bit mode) with their 90 nm (revision D) processors, starting with Athlon 64 in October 2004.[63][64] Intel introduced the instructions in October 2005 with the 0F47h and later revisions of NetBurst.[70] The 64-bit version of Windows 8.1 requires this feature.[62]
Early Intel CPUs with Intel 64 also lack the NX bit of the AMD64 architecture. It was added in the stepping E0 (0F41h) Pentium 4 in October 2004.[71] This feature is required by all versions of Windows 8.
Early Intel 64 implementations had a 36-bit (64 GiB) physical addressing of memory while original AMD64 implementations had a 40-bit (1 TiB) physical addressing. Intel used the 40-bit physical addressing first on Xeon MP (Potomac), launched on 29 March 2005.[72] The difference is not a difference of the user-visible ISAs. In 2007 AMD 10h-based Opteron was the first to provide a 48-bit (256 TiB) physical address space.[73][74] Intel 64's physical addressing was extended to 44 bits (16 TiB) in Nehalem-EX in 2010[75] and to 46 bits (64 TiB) in Sandy Bridge E in 2011.[76][77] With the Ice Lake 3rd gen Xeon Scalable processors, Intel increased the virtual addressing to 57 bits (128 PiB) and physical to 52 bits (4 PiB) in 2021, necessitating a 5-level paging.[78] The following year AMD64 added the same in 4th generation EPYC (Genoa).[79] Non-server CPUs retain smaller address spaces for longer.
On all AMD64 processors, the BSF and BSR instructions will, when given a source value of 0, leave their destination register unmodified. This is mostly the case on Intel 64 processors as well, except that on some older Intel 64 CPUs, executing these instructions with an operand size of 32 bits will clear the top 32 bits of their destination register even with a source value of 0 (with the low 32 bits kept unchanged.)[80]
AMD64 processors since Opteron Rev. E and Athlon 64 Rev. D reintroduced limited support for segmentation, via the Long Mode Segment Limit Enable (LMSLE) bit, to ease virtualization of 64-bit guests.[81][82] LMLSE support was removed in the Zen 3 processor.[83]
On all Intel 64 processors, CLFLUSH is ordered with respect to SFENCE - this is also the case on newer AMD64 processors (Zen 1 and later). On older AMD64 processors, imposing ordering on the CLFLUSH instruction instead required MFENCE.
Adoption[edit]
An area chart showing the representation of different families of microprocessors in the TOP500 supercomputer ranking list, from 1993 to 2020[84]
In supercomputers tracked by TOP500, the appearance of 64-bit extensions for the x86 architecture enabled 64-bit x86 processors by AMD and Intel to replace most RISC processor architectures previously used in such systems (including PA-RISC, SPARC, Alpha and others), as well as 32-bit x86, even though Intel itself initially tried unsuccessfully to replace x86 with a new incompatible 64-bit architecture in the Itanium processor.
As of 2023[update], a HPE EPYC-based supercomputer called Frontier is number one. The first ARM-based supercomputer appeared on the list in 2018[85] and, in recent years, non-CPU architecture co-processors (GPGPU) have also played a big role in performance. Intel's Xeon Phi "Knights Corner" coprocessors, which implement a subset of x86-64 with some vector extensions,[86] are also used, along with x86-64 processors, in the Tianhe-2 supercomputer.[87]


Operating system compatibility and characteristics[edit]
The following operating systems and releases support the x86-64 architecture in long mode.

BSD[edit]
DragonFly BSD[edit]
Preliminary infrastructure work was started in February 2004 for a x86-64 port.[88] This development later stalled. Development started again during July 2007[89]
and continued during Google Summer of Code 2008 and SoC 2009.[90][91] The first official release to contain x86-64 support was version 2.4.[92]

FreeBSD[edit]
FreeBSD first added x86-64 support under the name "amd64" as an experimental architecture in 5.1-RELEASE in June 2003. It was included as a standard distribution architecture as of 5.2-RELEASE in January 2004. Since then, FreeBSD has designated it as a Tier 1 platform. The 6.0-RELEASE version cleaned up some quirks with running x86 executables under amd64, and most drivers work just as they do on the x86 architecture. Work is currently being done to integrate more fully the x86 application binary interface (ABI), in the same manner as the Linux 32-bit ABI compatibility currently works.

NetBSD[edit]
x86-64 architecture support was first committed to the NetBSD source tree on June 19, 2001. As of NetBSD 2.0, released on December 9, 2004, NetBSD/amd64 is a fully integrated and supported port.
32-bit code is still supported in 64-bit mode, with a netbsd-32 kernel compatibility layer for 32-bit syscalls. The NX bit is used to provide non-executable stack and heap with per-page granularity (segment granularity being used on 32-bit x86).

OpenBSD[edit]
OpenBSD has supported AMD64 since OpenBSD 3.5, released on May 1, 2004. Complete in-tree implementation of AMD64 support was achieved prior to the hardware's initial release because AMD had loaned several machines for the project's hackathon that year. OpenBSD developers have taken to the platform because of its support for the NX bit, which allowed for an easy implementation of the W^X feature.
The code for the AMD64 port of OpenBSD also runs on Intel 64 processors which contains cloned use of the AMD64 extensions, but since Intel left out the page table NX bit in early Intel 64 processors, there is no W^X capability on those Intel CPUs; later Intel 64 processors added the NX bit under the name "XD bit". Symmetric multiprocessing (SMP) works on OpenBSD's AMD64 port, starting with release 3.6 on November 1, 2004.

DOS[edit]
This article needs additional citations for verification. Please help improve this article by adding citations to reliable sources. Unsourced material may be challenged and removed.Find sources: "X86-64" – news · newspapers · books · scholar · JSTOR (December 2022) (Learn how and when to remove this message)
It is possible to enter long mode under DOS without a DOS extender,[93] but the user must return to real mode in order to call BIOS or DOS interrupts.
It may also be possible to enter long mode with a DOS extender similar to DOS/4GW, but more complex since x86-64 lacks virtual 8086 mode. DOS itself is not aware of that, and no benefits should be expected unless running DOS in an emulation with an adequate virtualization driver backend, for example: the mass storage interface.

Linux[edit]
See also: Comparison of Linux distributions § Instruction set architecture support
Linux was the first operating system kernel to run the x86-64 architecture in long mode, starting with the 2.4 version in 2001 (preceding the hardware's availability).[94][95] Linux also provides backward compatibility for running 32-bit executables. This permits programs to be recompiled into long mode while retaining the use of 32-bit programs. Current Linux distributions ship with x86-64-native kernels and userlands. Some, such as Arch Linux,[96] SUSE, Mandriva, and Debian, allow users to install a set of 32-bit components and libraries when installing off a 64-bit distribution medium, thus allowing most existing 32-bit applications to run alongside the 64-bit OS.
x32 ABI (Application Binary Interface), introduced in Linux 3.4, allows programs compiled for the x32 ABI to run in the 64-bit mode of x86-64 while only using 32-bit pointers and data fields.[97][98][99]
Though this limits the program to a virtual address space of 4 GiB, it also decreases the memory footprint of the program and in some cases can allow it to run faster.[97][98][99]
64-bit Linux allows up to 128 TiB of virtual address space for individual processes, and can address approximately 64 TiB of physical memory, subject to processor and system limitations,[100] or up to 128 PiB (virtual) and 4 PiB (physical) with 5-level paging enabled.[101]

macOS[edit]
Mac OS X 10.4.7 and higher versions of Mac OS X 10.4 run 64-bit command-line tools using the POSIX and math libraries on 64-bit Intel-based machines, just as all versions of Mac OS X 10.4 and 10.5 run them on 64-bit PowerPC machines. No other libraries or frameworks work with 64-bit applications in Mac OS X 10.4.[102]
The kernel, and all kernel extensions, are 32-bit only.
Mac OS X 10.5 supports 64-bit GUI applications using Cocoa, Quartz, OpenGL, and X11 on 64-bit Intel-based machines, as well as on 64-bit PowerPC machines.[103]
All non-GUI libraries and frameworks also support 64-bit applications on those platforms. The kernel, and all kernel extensions, are 32-bit only.
Mac OS X 10.6 is the first version of macOS that supports a 64-bit kernel. However, not all 64-bit computers can run the 64-bit kernel, and not all 64-bit computers that can run the 64-bit kernel will do so by default.[104]
The 64-bit kernel, like the 32-bit kernel, supports 32-bit applications; both kernels also support 64-bit applications. 32-bit applications have a virtual address space limit of 4 GiB under either kernel.[105][106]  The 64-bit kernel does not support 32-bit kernel extensions, and the 32-bit kernel does not support 64-bit kernel extensions.
OS X 10.8 includes only the 64-bit kernel, but continues to support 32-bit applications; it does not support 32-bit kernel extensions, however.
macOS 10.15 includes only the 64-bit kernel and no longer supports 32-bit applications. This removal of support has presented a problem for Wine (and the commercial version CrossOver), as it needs to still be able to run 32-bit Windows applications. The solution, termed wine32on64, was to add thunks that bring the CPU in and out of 32-bit compatibility mode in the nominally 64-bit application.[107][108]
macOS uses the universal binary format to package 32- and 64-bit versions of application and library code into a single file; the most appropriate version is automatically selected at load time. In Mac OS X 10.6, the universal binary format is also used for the kernel and for those kernel extensions that support both 32-bit and 64-bit kernels.

Solaris[edit]
See also: illumos
Solaris 10 and later releases support the x86-64 architecture.
For Solaris 10, just as with the SPARC architecture, there is only one operating system image, which contains a 32-bit kernel and a 64-bit kernel; this is labeled as the "x64/x86" DVD-ROM image. The default behavior is to boot a 64-bit kernel, allowing both 64-bit and existing or new 32-bit executables to be run. A 32-bit kernel can also be manually selected, in which case only 32-bit executables will run. The isainfo command can be used to determine if a system is running a 64-bit kernel.
For Solaris 11, only the 64-bit kernel is provided. However, the 64-bit kernel supports both 32- and 64-bit executables, libraries, and system calls.

Windows[edit]
x64 editions of Microsoft Windows client and server—Windows XP Professional x64 Edition and Windows Server 2003 x64 Edition—were released in March 2005.[109] Internally they are actually the same build (5.2.3790.1830 SP1),[110][111] as they share the same source base and operating system binaries, so even system updates are released in unified packages, much in the manner as Windows 2000 Professional and Server editions for x86. Windows Vista, which also has many different editions, was released in January 2007. Windows 7 was released in July 2009. Windows Server 2008 R2 was sold in only x64 and Itanium editions; later versions of Windows Server only offer an x64 edition.
Versions of Windows for x64 prior to Windows 8.1 and Windows Server 2012 R2 offer the following:

8 TiB of virtual address space per process, accessible from both user mode and kernel mode, referred to as the user mode address space. An x64 program can use all of this, subject to backing store limits on the system, and provided it is linked with the "large address aware" option, which is present by default.[112] This is a 4096-fold increase over the default 2 GiB user-mode virtual address space offered by 32-bit Windows.[113][114]
8 TiB of kernel mode virtual address space for the operating system.[113] As with the user mode address space, this is a 4096-fold increase over 32-bit Windows versions. The increased space primarily benefits the file system cache and kernel mode "heaps" (non-paged pool and paged pool). Windows only uses a total of 16 TiB out of the 256 TiB implemented by the processors because early AMD64 processors lacked a CMPXCHG16B instruction.[115]
Under Windows 8.1 and Windows Server 2012 R2, both user mode and kernel mode virtual address spaces have been extended to 128 TiB.[23] These versions of Windows will not install on processors that lack the CMPXCHG16B instruction.
The following additional characteristics apply to all x64 versions of Windows:

Ability to run existing 32-bit applications (.exe programs) and dynamic link libraries (.dlls) using WoW64 if WoW64 is supported on that version. Furthermore, a 32-bit program, if it was linked with the "large address aware" option,[112] can use up to 4 GiB of virtual address space in 64-bit Windows, instead of the default 2 GiB (optional 3 GiB with /3GB boot option and "large address aware" link option) offered by 32-bit Windows.[116] Unlike the use of the /3GB boot option on x86, this does not reduce the kernel mode virtual address space available to the operating system. 32-bit applications can, therefore, benefit from running on x64 Windows even if they are not recompiled for x86-64.
Both 32- and 64-bit applications, if not linked with "large address aware", are limited to 2 GiB of virtual address space.
Ability to use up to 128 GiB (Windows XP/Vista), 192 GiB (Windows 7), 512 GiB (Windows 8), 1 TiB (Windows Server 2003), 2 TiB (Windows Server 2008/Windows 10), 4 TiB (Windows Server 2012), or 24 TiB (Windows Server 2016/2019) of physical random access memory (RAM).[117]
LLP64 data model: in C/C++, "int" and "long" types are 32 bits wide, "long long" is 64 bits, while pointers and types derived from pointers are 64 bits wide.
Kernel mode device drivers must be 64-bit versions; there is no way to run 32-bit kernel mode executables within the 64-bit operating system. User mode device drivers can be either 32-bit or 64-bit.
16-bit Windows (Win16) and DOS applications will not run on x86-64 versions of Windows due to the removal of the virtual DOS machine subsystem (NTVDM) which relied upon the ability to use virtual 8086 mode. Virtual 8086 mode cannot be entered while running in long mode.
Full implementation of the NX (No Execute) page protection feature. This is also implemented on recent 32-bit versions of Windows when they are started in PAE mode.
Instead of FS segment descriptor on x86 versions of the Windows NT family, GS segment descriptor is used to point to two operating system defined structures: Thread Information Block (NT_TIB) in user mode and Processor Control Region (KPCR) in kernel mode. Thus, for example, in user mode GS:0 is the address of the first member of the Thread Information Block. Maintaining this convention made the x86-64 port easier, but required AMD to retain the function of the FS and GS segments in long mode – even though segmented addressing per se is not really used by any modern operating system.[113]
Early reports claimed that the operating system scheduler would not save and restore the x87 FPU machine state across thread context switches. Observed behavior shows that this is not the case: the x87 state is saved and restored, except for kernel mode-only threads (a limitation that exists in the 32-bit version as well). The most recent documentation available from Microsoft states that the x87/MMX/3DNow! instructions may be used in long mode, but that they are deprecated and may cause compatibility problems in the future.[116] (3DNow! is no longer available on AMD processors, with the exception of the PREFETCH and PREFETCHW instructions,[118] which are also supported on Intel processors as of Broadwell.)
Some components like Jet Database Engine and Data Access Objects will not be ported to 64-bit architectures such as x86-64 and IA-64.[119][120][121]
Microsoft Visual Studio can compile native applications to target either the x86-64 architecture, which can run only on 64-bit Microsoft Windows, or the IA-32 architecture, which can run as a 32-bit application on 32-bit Microsoft Windows or 64-bit Microsoft Windows in WoW64 emulation mode. Managed applications can be compiled either in IA-32, x86-64 or AnyCPU modes. Software created in the first two modes behave like their IA-32 or x86-64 native code counterparts respectively; When using the AnyCPU mode, however, applications in 32-bit versions of Microsoft Windows run as 32-bit applications, while they run as a 64-bit application in 64-bit editions of Microsoft Windows.
Video game consoles[edit]
The PlayStation 4 and Xbox One use AMD x86-64 processors based on the Jaguar microarchitecture.[122][123] Firmware and games are written in x86-64 code; no legacy x86 code is involved. The PlayStation 5 and Xbox Series X/S use AMD x86-64 processors based on the Zen 2 microarchitecture.[124][125] The Steam Deck uses a custom AMD x86-64 accelerated processing unit (APU) based on the Zen 2 microarchitecture.[126]

Industry naming conventions[edit]
Since AMD64 and Intel 64 are substantially similar, many software and hardware products use one vendor-neutral term to indicate their compatibility with both implementations. AMD's original designation for this processor architecture, "x86-64", is still used for this purpose,[2] as is the variant "x86_64".[3][4] Other companies, such as Microsoft[6] and Sun Microsystems/Oracle Corporation,[5] use the contraction "x64" in marketing material.
The term IA-64 refers to the Itanium processor, and should not be confused with x86-64, as it is a completely different instruction set.
Many operating systems and products, especially those that introduced x86-64 support prior to Intel's entry into the market, use the term "AMD64" or "amd64" to refer to both AMD64 and Intel 64.

amd64
Most BSD systems such as FreeBSD, MidnightBSD, NetBSD and OpenBSD refer to both AMD64 and Intel 64 under the architecture name "amd64".
Some Linux distributions such as Debian, Ubuntu, Gentoo Linux refer to both AMD64 and Intel 64 under the architecture name "amd64".
Microsoft Windows's x64 versions use the AMD64 moniker internally to designate various components which use or are compatible with this architecture. For example, the environment variable PROCESSOR_ARCHITECTURE is assigned the value "AMD64" as opposed to "x86" in 32-bit versions, and the system directory on a Windows x64 Edition installation CD-ROM is named "AMD64", in contrast to "i386" in 32-bit versions.[127]
Sun's Solaris's isalist command identifies both AMD64- and Intel 64-based systems as "amd64".
Java Development Kit (JDK): the name "amd64" is used in directory names containing x86-64 files.
x86_64
The Linux kernel[128] and the GNU Compiler Collection refers to 64-bit architecture as "x86_64".
Some Linux distributions, such as Fedora, openSUSE, Arch Linux, Gentoo Linux refer to this 64-bit architecture as "x86_64".
Apple macOS refers to 64-bit architecture as "x86-64" or "x86_64", as seen in the Terminal command arch[3] and in their developer documentation.[2][4]
Breaking with most other BSD systems, DragonFly BSD refers to 64-bit architecture as "x86_64".
Haiku refers to 64-bit architecture as "x86_64".
Licensing[edit]
x86-64/AMD64 was solely developed by AMD. Until April 2021 when the relevant patents expired, AMD held patents on techniques used in AMD64;[129][130][131] those patents had to be licensed from AMD in order to implement AMD64. Intel entered into a cross-licensing agreement with AMD, licensing to AMD their patents on existing x86 techniques, and licensing from AMD their patents on techniques used in x86-64.[132] In 2009, AMD and Intel settled several lawsuits and cross-licensing disagreements, extending their cross-licensing agreements.[133][134][135]

See also[edit]
AMD Generic Encapsulated Software Architecture (AGESA)
Speculative execution CPU vulnerabilities
Notes[edit]


^ Various names are used for the instruction set. Prior to the launch, x86-64 and x86_64 were used, while upon the release AMD named it AMD64.[1] Intel initially used the names IA-32e and EM64T before finally settling on "Intel 64" for its implementation. Some in the industry, including Apple,[2][3][4] use x86-64 and x86_64, while others, notably Sun Microsystems[5] (now Oracle Corporation) and Microsoft,[6] use x64. The BSD family of OSs and several Linux distributions[7][8] use AMD64, as does Microsoft Windows internally.[9][10]

^ In practice, 64-bit operating systems generally do not support 16-bit applications, although modern versions of Microsoft Windows contain a limited workaround that effectively supports 16-bit InstallShield and Microsoft ACME installers by silently substituting them with 32-bit code.[12]




^ The Register reported that the stepping G1 (0F49h) of Pentium 4 will sample on October 17 and ship in volume on November 14.[68] However, Intel's document says that samples are available on September 9, whereas October 17 is the "date of first availability of post-conversion material", which Intel defines as "the projected date that a customer may expect to receive the post-conversion materials. ... customers should be prepared to receive the post-converted materials on this date".[69]


References[edit]


^ "Debian AMD64 FAQ". Debian Wiki. Archived from the original on September 26, 2019. Retrieved May 3, 2012.

^ a b c "x86-64 Code Model". Apple. Archived from the original on June 2, 2012. Retrieved November 23, 2012.

^ a b c arch(1) – Darwin and macOS General Commands Manual

^ a b c Kevin Van Vechten (August 9, 2006). "re: Intel XNU bug report". Darwin-dev mailing list. Apple Computer. Archived from the original on February 1, 2020. Retrieved October 5, 2006. The kernel and developer tools have standardized on "x86_64" for the name of the Mach-O architecture

^ a b "Solaris 10 on AMD Opteron". Oracle. Archived from the original on July 25, 2017. Retrieved December 9, 2010.

^ a b "Microsoft 64-Bit Computing". Microsoft. Archived from the original on December 12, 2010. Retrieved December 9, 2010.

^ "AMD64 Port". Debian. Archived from the original on September 26, 2019. Retrieved November 23, 2012.

^ "Gentoo/AMD64 Project". Gentoo Project. Archived from the original on June 3, 2013. Retrieved May 27, 2013.

^ "WOW64 Implementation Details". Archived from the original on April 13, 2018. Retrieved January 24, 2016.

^ "ProcessorArchitecture Class". Archived from the original on June 3, 2017. Retrieved January 24, 2016.

^ a b c d e f g h i j k l m n o p q r s t u AMD Corporation (December 2016). "Volume 2: System Programming" (PDF). AMD64 Architecture Programmer's Manual. AMD Corporation. Archived (PDF) from the original on July 13, 2018. Retrieved March 25, 2017.

^ Raymond Chen (October 31, 2013). "If there is no 16-bit emulation layer in 64-bit Windows, how come certain 16-bit installers are allowed to run?". Archived from the original on July 14, 2021. Retrieved July 14, 2021.

^ "IBM WebSphere Application Server 64-bit Performance Demystified" (PDF). IBM Corporation. September 6, 2007. p. 14. Archived (PDF) from the original on January 25, 2022. Retrieved April 9, 2010. Figures 5, 6 and 7 also show the 32-bit version of WAS runs applications at full native hardware performance on the POWER and x86-64 platforms. Unlike some 64-bit processor architectures, the POWER and x86-64 hardware does not emulate 32-bit mode. Therefore applications that do not benefit from 64-bit features can run with full performance on the 32-bit version of WebSphere running on the above mentioned 64-bit platforms.

^ "AMD Discloses New Technologies At Microporcessor Forum" (Press release). AMD. October 5, 1999. Archived from the original on March 8, 2012. Retrieved November 9, 2010.

^ "AMD Releases x86-64 Architectural Specification; Enables Market Driven Migration to 64-Bit Computing" (Press release). AMD. August 10, 2000. Archived from the original on March 8, 2012. Retrieved November 9, 2010.

^ AMD64 Architecture Programmer's Manual (PDF). p. 1.

^ Mauerer, W. (2010). Professional Linux kernel architecture. John Wiley & Sons.

^ "Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3A: System Programming Guide, Part 1" (PDF). pp. 4–7. Archived (PDF) from the original on May 16, 2011. Retrieved July 10, 2019.

^ a b "BIOS and Kernel Developer's Guide (BKDG) For AMD Family 10h Processors" (PDF). p. 24. Archived (PDF) from the original on April 18, 2016. Retrieved February 27, 2016. Physical address space increased to 48 bits.

^ 
"Myth and facts about 64-bit Linux" (PDF). March 2, 2008. p. 7. Archived from the original (PDF) on October 10, 2010. Retrieved May 30, 2010. Physical address space increased to 48 bits

^ Shanley, Tom (1998). Pentium Pro and Pentium II System Architecture. PC System Architecture Series (Second ed.). Addison-Wesley. p. 445. ISBN 0-201-30973-4.

^ Microsoft Corporation. "What is PAE, NX, and SSE2 and why does my PC need to support them to run Windows 8 ?". Archived from the original on April 11, 2013. Retrieved March 19, 2013.

^ a b c d "Memory Limits for Windows Releases". MSDN. Microsoft. November 16, 2013. Archived from the original on January 6, 2014. Retrieved January 20, 2014.

^ "5-Level Paging and 5-Level EPT" (PDF). Intel. May 2017. Archived (PDF) from the original on December 5, 2018. Retrieved June 17, 2017.

^ US patent 9858198, Larry Seiler, "64KB page system that supports 4KB page operation", published December 29, 2016, issued January 2, 2018,  assigned to Intel Corp. 

^ "Opteron 6100 Series Motherboards". Supermicro Corporation. Archived from the original on June 3, 2010. Retrieved June 22, 2010.

^ "Supermicro XeonSolutions". Supermicro Corporation. Archived from the original on May 27, 2010. Retrieved June 20, 2010.

^ "Opteron 8000 Series Motherboards". Supermicro Corporation. Archived from the original on May 27, 2010. Retrieved June 20, 2010.

^ "Tyan Product Matrix". MiTEC International Corporation. Archived from the original on June 6, 2010. Retrieved June 21, 2010.

^ a b "From the AMI Archives: AMIBIOS 8 and the Transition to EFI". American Megatrends. September 8, 2017. Archived from the original on October 25, 2021. Retrieved October 25, 2021.

^ "Intel is Continuing the Yamhill Project?". Neowin. Archived from the original on June 5, 2022. Retrieved June 5, 2022.

^ "Craig Barrett confirms 64 bit address extensions for Xeon. And Prescott". The Inquirer. February 17, 2004. Archived from the original on January 12, 2013. Retrieved August 20, 2017.

^ ""A Roundup of 64-Bit Computing", from internetnews.com". Archived from the original on September 25, 2012. Retrieved September 18, 2006.

^ Lapedus, Mark (February 6, 2004). "Intel to demo 'CT' 64-bit processor line at IDF". EDN. AspenCore Media. Archived from the original on May 25, 2021. Retrieved May 25, 2021.

^ "Intel 64 Architecture". Intel. Archived from the original on June 29, 2011. Retrieved June 29, 2007.

^ "Intel Publishes "X86-S" Specification For 64-bit Only Architecture". www.phoronix.com.

^ "Envisioning a Simplified Intel Architecture for the Future". Intel.

^ Paul Alcorn (December 19, 2024). "Intel terminates x86S initiative — unilateral quest to de-bloat x86 instruction set comes to an end". Tom's Hardware. Retrieved December 20, 2024.

^ "VIA to launch new processor architecture in 1Q08" (subscription required). DigiTimes. July 25, 2007. Archived from the original on December 3, 2008. Retrieved July 25, 2007.

^ Stokes, Jon (January 23, 2008). "Isaiah revealed: VIA's new low-power architecture". Ars Technica. Archived from the original on January 27, 2008. Retrieved January 24, 2008.

^ "VIA Launches VIA Nano Processor Family" (Press release). VIA. May 29, 2008. Archived from the original on February 3, 2019. Retrieved May 25, 2017.

^ "VIA Isaiah Architecture Introduction" (PDF). VIA. January 23, 2008. Archived from the original (PDF) on September 7, 2008. Retrieved July 31, 2013.

^ Weimer, Florian (July 10, 2020). "New x86-64 micro-architecture levels". llvm-dev (Mailing list). Archived from the original on April 14, 2021. Retrieved March 11, 2021.

^ Weimer, Florian (January 5, 2021). "Building Red Hat Enterprise Linux 9 for the x86-64-v2 microarchitecture level". Red Hat developer blog. Archived from the original on February 20, 2022. Retrieved March 22, 2022.

^ "System V Application Binary Interface Low Level System Information". x86-64 psABI repo. January 29, 2021. Archived from the original on February 2, 2021. Retrieved March 11, 2021 – via GitLab.

^ "QEMU version 7.2.0 released - QEMU". www.qemu.org. Archived from the original on December 21, 2022. Retrieved January 9, 2023.

^ "ChangeLog/7.2 - QEMU". wiki.qemu.org. Archived from the original on January 9, 2023. Retrieved January 9, 2023.

^ Wasson, Scott (March 23, 2005). "64-bit computing in theory and practice". The Tech Report. Archived from the original on March 12, 2011. Retrieved March 22, 2011.

^ "Intel 64 and IA-32 Architectures Software Developer's Manual Volume 2 (2A, 2B & 2C): Instruction Set Reference, A–Z" (PDF). Intel. September 2013. pp. 4–397. Archived (PDF) from the original on October 20, 2013. Retrieved January 21, 2014.

^ "Intel 64 and IA-32 Architectures Software Developer's Manual Volume 2 (2A, 2B & 2C): Instruction Set Reference, A-Z" (PDF). Intel. September 2013. pp. 4–400. Archived (PDF) from the original on October 20, 2013. Retrieved January 21, 2014.

^ "AMD64 Architecture Programmer's Manual Volume 3: General-Purpose and System Instructions" (PDF). AMD. May 2018. p. 419. Archived (PDF) from the original on August 20, 2018. Retrieved August 2, 2018.

^ "Intel 64 and IA-32 Architectures Software Developer's Manual Volume 2 (2A, 2B & 2C): Instruction Set Reference, A-Z" (PDF). Intel. September 2014. pp. 4–412. Archived (PDF) from the original on January 13, 2015. Retrieved December 28, 2014.

^ LKML, (PATCH) x86_64, asm: Work around AMD SYSRET SS descriptor attribute issue, 23 Apr 2015.

^ Intel, Intel 64 and IA-32 Architectures Software Developer’s Manual, volume 3B, order no. 253669-086US, December 2024, chapter 24.15, page 426. Archived on 11 Jan 2025.

^ AMD, AMD64 Architecture Programmer’s Manual Volume 3: General-Purpose and System Instructions, order no. 24594, rev 3.36, March 2024, see description of PREFETCHW instruction on page 283. Archived on 29 Dec 2024.

^ Hadi Brais, The Significance of the x86 LFENCE Instruction, 14 May 2018. Archived on 10 Jun 2023.

^ LKML, (PATCH 5.4 55/65) x86/apic: Add extra serialization for non-serializing MSRs, 8 Feb 2021

^ Linux kernel, git commit: x86/barrier: Do not serialize MSR accesses on AMD, 13 Nov 2023

^ "Live Migration with AMD-V™ Extended Migration Technology" (PDF). developer.amd.com. Archived (PDF) from the original on December 6, 2022. Retrieved June 30, 2022.

^ Maged M. Michael. "Practical Lock-Free and Wait-Free LL/SC/VL Implementations Using 64-Bit CAS" (PDF). IBM. Archived (PDF) from the original on May 2, 2013. Retrieved January 21, 2014.

^ darwou (August 20, 2004). "Why is the virtual address space 4GB anyway?". The Old New Thing. Microsoft. Archived from the original on March 26, 2017. Retrieved March 25, 2017.

^ a b "System Requirements—Windows 8.1". Archived from the original on April 28, 2014. Retrieved April 27, 2014. To install a 64-bit OS on a 64-bit PC, your processor needs to support CMPXCHG16b, PrefetchW, and LAHF/SAHF.

^ Petkov, Borislav (August 10, 2009). "Re: [PATCH v2] x86: clear incorrectly forced X86_FEATURE_LAHF_LM flag". Linux kernel mailing list. Archived from the original on January 11, 2023. Retrieved June 30, 2022.

^ "Revision Guide for AMD Athlon 64 and AMD Opteron Processors" (PDF). AMD. Archived (PDF) from the original on August 24, 2009. Retrieved July 18, 2009.

^ "Product Change Notification 105224 - 01" (PDF). Intel. Archived from the original (PDF) on November 17, 2005.

^ "Intel® Pentium® D Processor 800 Sequence and Intel® Pentium® Processor Extreme Edition 840 Specification Update" (PDF). Archived (PDF) from the original on May 18, 2021. Retrieved June 30, 2022.

^ "Intel Xeon 2.8 GHz - NE80551KG0724MM / BX80551KG2800HA". CPU-World. Archived from the original on June 28, 2020. Retrieved June 30, 2022.

^ Smith, Tony (August 23, 2005). "Intel tweaks EM64T for full AMD64 compatibility". The Register. Archived from the original on June 30, 2022. Retrieved June 30, 2022.

^ "Product Change Notification 105271 – 00" (PDF). Intel. Archived from the original (PDF) on November 17, 2005.

^ 0F47h debuted in the B0 stepping of Pentium D on October 21,[65][66] but 0F48h which also supports LAHF/SAHF launched on October 10 in the dual-core Xeon.[67][a]

^ "Product Change Notification 104101 – 00" (PDF). Intel. Archived from the original (PDF) on July 16, 2004.

^ "64-bit Intel® Xeon™ Processor MP with up to 8MB L3 Cache Datasheet" (PDF). Archived (PDF) from the original on November 17, 2022. Retrieved November 17, 2022.

^ "Justin Boggs's at Microsoft PDC 2008". p. 5. Archived from the original on November 17, 2022. Retrieved November 17, 2022.

^ Waldecker, Brian. "AMD Opteron Multicore Processors" (PDF). p. 13. Archived (PDF) from the original on December 13, 2022. Retrieved November 17, 2022.

^ "Intel® Xeon® Processor 7500 Series Datasheet, Volume 2" (PDF). Archived (PDF) from the original on November 17, 2022. Retrieved November 17, 2022.

^ "Intel 64 and IA-32 Architectures Software Developer's Manual". September 2014. p. 2-21. Archived from the original on May 14, 2019. Intel 64 architecture increases the linear address space for software to 64 bits and supports physical address space up to 46 bits.

^ Logan, Tom (November 14, 2011). "Intel Core i7-3960X Review". Archived from the original on March 28, 2016. Retrieved July 1, 2022.

^ Ye, Huaisheng. "Introduction to 5-Level Paging in 3rd Gen Intel Xeon Scalable Processors with Linux" (PDF). Lenovo. Archived (PDF) from the original on May 26, 2022. Retrieved July 1, 2022.

^ Kennedy, Patrick (November 10, 2022). "AMD EPYC Genoa Gaps Intel Xeon in Stunning Fashion". ServeTheHome. p. 2. Archived from the original on November 17, 2022. Retrieved November 17, 2022.

^ Intel, Intel 64 and IA-32 Architectures Software Developer’s Manual, Volume 2, order no. 325383-086US, December 2024, see entries on BSF and BSR instructions on pages 227 and 229 (footnote 1). Archived on 1 Jan 2025.

^ "How retiring segmentation in AMD64 long mode broke VMware". Pagetable.com. November 9, 2006. Archived from the original on July 18, 2011. Retrieved May 2, 2010.

^ "VMware and CPU Virtualization Technology" (PDF). VMware. Archived (PDF) from the original on July 17, 2011. Retrieved September 8, 2010.

^ "Linux-Kernel Archive: [PATCH 2/5] KVM: svm: Disallow EFER.LMSLE on hardware that doesn't support it". lkml.indiana.edu. Retrieved November 3, 2023.

^ "Statistics | TOP500 Supercomputer Sites". Top500.org. Archived from the original on March 19, 2014. Retrieved March 22, 2014.

^ "Sublist Generator | TOP500 Supercomputer Sites". www.top500.org. Archived from the original on December 7, 2018. Retrieved December 6, 2018.

^ "Intel® Xeon PhiTM Coprocessor Instruction Set Architecture Reference Manual" (PDF). Intel. September 7, 2012. section B.2 Intel Xeon Phi coprocessor 64 bit Mode Limitations. Archived (PDF) from the original on May 21, 2014. Retrieved May 21, 2014.

^ "Intel Powers the World's Fastest Supercomputer, Reveals New and Future High Performance Computing Technologies". Archived from the original on June 22, 2013. Retrieved June 21, 2013.

^ "cvs commit: src/sys/amd64/amd64 genassym.c src/sys/amd64/include asm.h atomic.h bootinfo.h coredump.h cpufunc.h elf.h endian.h exec.h float.h fpu.h frame.h globaldata.h ieeefp.h limits.h lock.h md_var.h param.h pcb.h pcb_ext.h pmap.h proc.h profile.h psl.h ..." Archived from the original on December 4, 2008. Retrieved May 3, 2009.

^ "AMD64 port". Archived from the original on May 18, 2010. Retrieved May 3, 2009.

^ "DragonFlyBSD: GoogleSoC2008". Archived from the original on April 27, 2009. Retrieved May 3, 2009.

^ "Summer of Code accepted students". Archived from the original on September 4, 2010. Retrieved May 3, 2009.

^ "DragonFlyBSD: release24". Archived from the original on September 23, 2009. Retrieved May 3, 2009.

^ "Tutorial for entering protected and long mode from DOS". Archived from the original on February 22, 2017. Retrieved July 6, 2008.

^ Andi Kleen (June 26, 2001). "Porting Linux to x86-64". Archived from the original on September 10, 2010. Status: The kernel, compiler, tool chain work. The kernel boots and work on simulator and is used for porting of userland and running programs

^ Andi Kleen. "Andi Kleen's Page". Archived from the original on December 7, 2009. Retrieved August 21, 2009. This was the original paper describing the Linux x86-64 kernel port back when x86-64 was only available on simulators.

^ "Arch64 FAQ". April 23, 2012. Archived from the original on May 14, 2012. Retrieved May 11, 2012. You can either use the multilib packages or a i686 chroot.

^ a b Thorsten Leemhuis (September 13, 2011). "Kernel Log: x32 ABI gets around 64-bit drawbacks". www.h-online.com. Archived from the original on October 28, 2011. Retrieved November 1, 2011.

^ a b "x32 - a native 32-bit ABI for x86-64". linuxplumbersconf.org. Archived from the original on May 5, 2012. Retrieved November 1, 2011.

^ a b "x32-abi". Google Sites. Archived from the original on October 30, 2011. Retrieved November 1, 2011.

^ "AMD64 Port". debian.org. Archived from the original on September 26, 2019. Retrieved October 29, 2011.

^ 
"5-level paging". kernel.org. Retrieved February 7, 2024.

^ "Apple – Mac OS X Xcode 2.4 Release Notes: Compiler Tools". Apple Inc. April 11, 2007. Archived from the original on April 22, 2009. Retrieved November 19, 2012.

^ "Apple – Mac OS X Leopard – Technology - 64-bit". Apple Inc. Archived from the original on January 12, 2009. Retrieved November 19, 2012.

^ "Mac OS X v10.6: Macs that use the 64-bit kernel". Apple Inc. Archived from the original on August 31, 2009. Retrieved November 29, 2012.

^ John Siracusa. "Mac OS X 10.6 Snow Leopard: the Ars Technica review". Ars Technica LLC. Archived from the original on October 9, 2009. Retrieved June 20, 2010.

^ "Mac OS X Technology". Apple Inc. Archived from the original on March 28, 2011. Retrieved November 19, 2012.

^ Schmid, J; Thomases, K; Ramey, J; Czekalla, U; Mathieu, B; Abhiram, R (September 10, 2019). "So We Don't Have a Solution for Catalina...Yet". CodeWeavers Blog. Archived from the original on September 29, 2021. Retrieved September 29, 2021.

^ Thomases, Ken (December 11, 2019). "win32 on macOS". WineHQ. Archived from the original on November 11, 2020. Retrieved September 29, 2021.

^ "Microsoft Raises the Speed Limit with the Availability of 64-Bit Editions of Windows Server 2003 and Windows XP Professional". Microsoft News Center (Press release). April 25, 2005. Retrieved January 29, 2024.

^ "A description of the x64-based versions of Windows Server 2003 and of Windows XP Professional x64 Edition". Microsoft Support. Archived from the original on April 20, 2016. Retrieved August 14, 2016.

^ "Windows Server 2003 SP1 Administration Tools Pack". Microsoft Download Center. Archived from the original on August 27, 2016. Retrieved August 14, 2016.

^ a b "/LARGEADDRESSAWARE (Handle Large Addresses)". Visual Studio 2022 Documentation – MSVC Linker Reference – MSVC Linker Options. Microsoft. Archived from the original on December 21, 2022. Retrieved December 21, 2022. The /LARGEADDRESSAWARE option tells the linker that the application can handle addresses larger than 2 gigabytes.

^ a b c Matt Pietrek (May 2006). "Everything You Need To Know To Start Programming 64-Bit Windows Systems". Microsoft. Retrieved April 18, 2023.

^ Chris St. Amand (January 2006). "Making the Move to x64". Microsoft. Retrieved April 18, 2023.

^ "Behind Windows x86-64's 44-bit Virtual Memory Addressing Limit". Archived from the original on December 23, 2008. Retrieved July 2, 2009.

^ a b "64-bit programming for Game Developers". Retrieved April 18, 2023.

^ "Memory Limits for Windows and Windows Server Releases". Microsoft. Retrieved April 18, 2023.

^ Kingsley-Hughes, Adrian (August 23, 2010). "AMD says goodbye to 3DNow! instruction set". ZDNet. Archived from the original on January 8, 2023. Retrieved January 8, 2023.

^ "General Porting Guidelines". Programming Guide for 64-bit Windows. Microsoft Docs. Retrieved April 18, 2023.

^ "Driver history for Microsoft SQL Server". Microsoft Docs. Retrieved April 18, 2023.

^ "Microsoft OLE DB Provider for Jet and Jet ODBC driver are available in 32-bit versions only". Office Access. Microsoft Docs. KB957570. Retrieved April 18, 2023.

^ Anand Lal Shimpi (May 21, 2013). "The Xbox One: Hardware Analysis & Comparison to PlayStation 4". Anandtech. Archived from the original on June 7, 2013. Retrieved May 22, 2013.

^ "The Tech Spec Test: Xbox One Vs. PlayStation 4". Game Informer. May 21, 2013. Archived from the original on June 7, 2013. Retrieved May 22, 2013.

^ "What to expect from Sony 'PlayStation 5' launch in November". The Indian Express. August 31, 2020. Archived from the original on September 19, 2020. Retrieved September 14, 2020.

^ Cutress, Dr Ian. "Hot Chips 2020 Live Blog: Microsoft Xbox Series X System Architecture (6:00pm PT)". www.anandtech.com. Archived from the original on September 17, 2020. Retrieved September 14, 2020.

^ Hollister, Sean (November 12, 2021). "Steam Deck: Five big things we learned from Valve's developer summit". The Verge. Archived from the original on February 7, 2022. Retrieved November 12, 2021.

^ "ProcessorArchitecture Fields". Archived from the original on April 28, 2015. Retrieved September 4, 2013.

^ "An example file from Linux 3.7.8 kernel source tree displaying the usage of the term x86_64". Archived from the original on September 23, 2005. Retrieved February 17, 2013.

^ US 6877084 

^ US 6889312 

^ US 6732258 

^ "Patent Cross License Agreement Between AMD and Intel". January 1, 2001. Archived from the original on June 21, 2007. Retrieved August 23, 2009.

^ "AMD Intel Settlement Agreement". Archived from the original on July 7, 2017. Retrieved September 18, 2017.

^ Stephen Shankland and Jonathan E. Skillings (November 12, 2009). "Intel to pay AMD $1.25 billion in antitrust settlement". CNET. Archived from the original on November 8, 2012. Retrieved April 24, 2012.

^ Smith, Ryan (November 12, 2009). "AMD and Intel Settle Their Differences: AMD Gets To Go Fabless". AnandTech. Archived from the original on May 13, 2010.


External links[edit]
AMD Developer Guides, Manuals & ISA Documents
x86-64: Extending the x86 architecture to 64-bits – technical talk by the architect of AMD64 (video archive), and second talk by the same speaker (video archive)
AMD's "Enhanced Virus Protection"
Intel tweaks EM64T for full AMD64 compatibility
Analyst: Intel Reverse-Engineered AMD64
Early report of differences between Intel IA32e and AMD64
Porting to 64-bit GNU/Linux Systems, by Andreas Jaeger from GCC Summit 2003. An excellent paper explaining almost all practical aspects for a transition from 32-bit to 64-bit.
Intel 64 Architecture
Intel Software Network: "64 bits"
TurboIRC.COM tutorials, including examples of how to of enter protected and long mode the raw way from DOS
Seven Steps of Migrating a Program to a 64-bit System
Memory Limits for Windows Releases
vteAMD technologySoftware
AGESA
AMDgpu
AMD Software
Vivado
Xilinx ISE
PlatformsCurrent
ROCm
GPUOpen
Obsolete
Spider
Dragon
Horus
Technology
Cool'n'Quiet
High Bandwidth Memory
PowerNow!
PowerPlay
PowerTune
Turbo Core
ASTC
AMD Wraith
Virtex
XDNA
Ryzen AI
Instructions
X86-64
3DNow!
AVX
XOP
CVT16/F16C
FMA
FMA4
FMA3
BMI
ABM
BMI1
TBM
SSE5
ASF
AES





Retrieved from "https://en.wikipedia.org/w/index.php?title=X86-64&oldid=1287340407"
Categories: Computer-related introductions in 2003X86 architecture64-bit computersAMD technologiesHidden categories: Articles with short descriptionShort description is different from WikidataUse mdy dates from October 2018Articles containing potentially dated statements from 2020All articles containing potentially dated statementsAll articles with failed verificationArticles with failed verification from May 2016All articles that may contain original researchArticles that may contain original research from August 2017Wikipedia articles needing clarification from July 2021Wikipedia articles in need of updating from January 2023All Wikipedia articles in need of updatingArticles containing potentially dated statements from 2023Articles needing additional references from December 2022All articles needing additional references






 This page was last edited on 25 April 2025, at 15:59 (UTC).
Text is available under the Creative Commons Attribution-ShareAlike 4.0 License;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.


Privacy policy
About Wikipedia
Disclaimers
Contact Wikipedia
Code of Conduct
Developers
Statistics
Cookie statement
Mobile view














Search













Search









Toggle the table of contents







x86-64




























35 languages


Add topic
















