https://en.wikipedia.org/wiki/Zilog_Z80




Zilog Z80 - Wikipedia



































Jump to content







Main menu





Main menu
move to sidebar
hide



		Navigation
	


Main pageContentsCurrent eventsRandom articleAbout WikipediaContact us





		Contribute
	


HelpLearn to editCommunity portalRecent changesUpload fileSpecial pages



















Search











Search






















Appearance
















Donate

Create account

Log in








Personal tools





Donate Create account Log in





		Pages for logged out editors learn more



ContributionsTalk




























Contents
move to sidebar
hide




(Top)





1
History




Toggle History subsection





1.1
Early history








1.2
Exxon investment, detailed development begins








1.3
Into production








1.4
Comparison with the 8080








1.5
Success in the market










2
Design




Toggle Design subsection





2.1
Programming model and register set






2.1.1
Registers








2.1.2
Microarchitecture










2.2
Z80 assembly language






2.2.1
Datapoint 2200 and Intel 8008








2.2.2
New syntax










2.3
Instruction set and encoding






2.3.1
Undocumented instructions








2.3.2
Bugs










2.4
Example code








2.5
Instruction execution








2.6
Compatible peripherals










3
Second sources and derivatives




Toggle Second sources and derivatives subsection





3.1
Second sources








3.2
Derivatives










4
Notable uses




Toggle Notable uses subsection





4.1
Desktop computers








4.2
Portable and handheld computers








4.3
Embedded systems and consumer electronics










5
Discontinuation








6
See also








7
Footnotes








8
References








9
Further reading








10
External links


















Toggle the table of contents







Zilog Z80



38 languages




العربيةAragonésAzərbaycancaБеларускаяCatalàČeštinaDanskDeutschEestiΕλληνικάEspañolفارسیFrançaisGalego한국어HrvatskiBahasa IndonesiaÍslenskaItalianoქართულიLatinaMagyarNederlands日本語Norsk bokmålNorsk nynorskPolskiPortuguêsRomânăРусскийSimple EnglishSlovenčinaSuomiSvenskaTürkçeУкраїнськаVèneto中文

Edit links











ArticleTalk





English

















ReadEditView history







Tools





Tools
move to sidebar
hide



		Actions
	


ReadEditView history





		General
	


What links hereRelated changesUpload filePermanent linkPage informationCite this pageGet shortened URLDownload QR code





		Print/export
	


Download as PDFPrintable version





		In other projects
	


Wikimedia CommonsWikidata item





















Appearance
move to sidebar
hide










From Wikipedia, the free encyclopedia


8-bit microprocessor


Zilog Z80A Z80 manufactured in June 1976General informationLaunchedJuly 1976DiscontinuedJune 2024Marketed byZilogDesigned byFederico Faggin, Masatoshi ShimaCommon manufacturerZilog, Mostek, Synertek, SGS, NEC, Sharp, Toshiba, Rohm, GoldStar, Hitachi, National Semiconductor,[a] and othersPerformanceMax. CPU clock rate2.5 MHz to 8 MHz[b]Data width8 bits[1]Address width16 bits[1]Architecture and classificationApplicationEmbedded, desktop, handheldTechnology node4 μm processInstruction setZ80[c]Physical specificationsTransistors8,500Packages40-pin DIP44-pin PLCC44-pin QFPHistoryPredecessorIntel 8080SuccessorsZ180Z280eZ80
The Zilog Z80 is an 8-bit microprocessor designed by Zilog that played an important role in the evolution of early personal computing. Launched in 1976, it was designed to be software-compatible with the Intel 8080, offering a compelling alternative due to its better integration and increased performance. Along with the 8080's seven registers and flags register, the Z80 introduced an alternate register set, two 16-bit index registers, and additional instructions, including bit manipulation and block copy/search.
Originally intended for use in embedded systems like the 8080, the Z80's combination of compatibility, affordability, and superior performance led to widespread adoption in video game systems and home computers throughout the late 1970s and early 1980s, helping to fuel the personal computing revolution. The Z80 was used in iconic products such as the Osborne 1, Radio Shack TRS-80, ColecoVision, ZX Spectrum, Sega's Master System and the Pac-Man arcade cabinet. In the early 1990s, it was used in portable devices, including the Game Gear and the TI-83 series of graphing calculators.[2][3]
The Z80 was the brainchild of Federico Faggin, a key figure behind the creation of the Intel 8080. After leaving Intel in 1974, he co-founded Zilog with Ralph Ungermann. The Z80 debuted in July 1976, and its success allowed Zilog to establish its own chip factories.[4] For initial production, Zilog licensed the Z80 to U.S.-based Synertek and Mostek, along with European second-source manufacturer, SGS. The design was also copied by various Japanese, Eastern European, and Soviet manufacturers gaining global market acceptance as major companies like NEC, Toshiba, Sharp, and Hitachi produced their own versions or compatible clones.
Long after more advanced processors were introduced, the Z80 continued to be used in embedded systems, remaining in production until June 2024, nearly five decades after it began. Zilog also continued to enhance the basic design of the Z80 with several successors, including the Z180, Z280, and Z380, with the latest iteration, the eZ80, introduced in 2001 and available for purchase as of 2025[update].[5]


History[edit]
A May 1976 advertisement for the Z80 outlines its major advantages over the 8080.
Photo of the original Zilog Z80 microprocessor design in depletion-load nMOS. Total die size is 3545×3350 μm. The blue squares around the outside are the pads that connect to the external pins. This chip was manufactured in 1990.
A CMOS Z80 in a 44-pin quad flat package.
Early history[edit]
At Fairchild Semiconductor, and later at Intel, physicist and engineer Federico Faggin had been working on fundamental transistor and semiconductor manufacturing technology. He also developed the basic design methodology used for memories and microprocessors at Intel and led the work on the Intel 4004, the Intel 8080 and several other ICs. Masatoshi Shima was the principal logic and transistor-level designer of the 4004 and the 8080 under Faggin's supervision, while Ralph Ungermann was in charge of custom integrated circuit design.[6]
In early 1974, Intel viewed microprocessors not so much as products to be sold on their own but as a way to sell more of its main products, static RAM and ROM. A reorganization placed many of the formerly independent sections under the direction of Les Vadasz, further diluting the microprocessor's place in the company. That year, the 1973–1975 recession reached a peak, and Intel laid off several employees.[6] All of this led to Faggin becoming restless, and he invited Ungermann out for drinks and asked if he would be interested in starting their own company. Ungermann immediately agreed, and as he had less to do at Intel, he left in August or September, followed by Faggin, whose last day at Intel was Halloween 1974.[7] When Shima heard, he asked to come to the new company as well, but having no actual product design or money, they told him to wait.[8]
The newly formed and unnamed company initially began designing a single-chip microcontroller called the 2001. They met with Synertek to discuss fabrication on their lines, and when Faggin began to understand the costs involved, it became clear that a low-cost product like this would not be able to compete with a design from a company with its own production lines, like Intel. They then began considering a more complex microprocessor instead, initially known as the Super 80, with the main feature being its use of a +5 V bus[8] instead of the more common −5, +5 and 12 V used by designs like the 8080. The new design was intended to be compatible with the 8080, but add many of the nice features of the Motorola 6800, including index registers and improved interrupts.[9]

Exxon investment, detailed development begins[edit]
While still being set up, the industry newsletter Electronic News heard of them and published a story on the newly formed company. This attracted the attention of Exxon Enterprises, Exxon's high-tech investment arm. At the time, in the midst of the recession, there was very little venture capital available, with a total of $10 million for the entire industry being spent in all of 1975 (equivalent to $58 million in 2024). Someone from Exxon contacted the still-unnamed company,[8] and arranged a meeting that eventually led to them providing an initial $500,000 funding in June 1975 (equivalent to $2.9 million in 2024).[10]
With funding being discussed and a design to be built, Shima joined in February 1975.[9] Shima immediately set about producing a high-level design, adding several concepts of his own. In particular, he used his experience on NEC minicomputers to add the concept of two sets of processor registers so they could quickly respond to interrupts.[7][d] Ungerman began the development of a series of related controllers and peripheral chips that would complement the design.[11]
Through this period, Shima developed a legendary reputation for being able to convert logic concepts into physical design in realtime; while discussing a proposed feature, he would often interrupt and state how much room that would take on the chip and veto its addition if it was too large.[12] The first pass at the design was complete by April 1975. Shima had completed a logic layout by the beginning of May. A second version of the logic design was issued on August 7 and the bus details by September 16. Tape-out was completed in November and converting the tape into a production mask required two more months.[13]
Faggin had already started looking for a production partner. By this time, Synertek and Mostek had both set up the depletion-mode production lines that could be used to produce the design. Having talked to Synertek previously, Faggin approached them first. However, the president of Synertek demanded that the company be given a second source license, allowing them to sell the design directly. Faggin thought this would mean they could never compete even if they set up their own lines, and the agreement fell through. He then turned to Mostek, who agreed to a term of exclusivity while Zilog got their lines set up, and was eventually given the second source agreement.[14]
After considering many names for the new company, and finding them so unmemorable they could not recall them even a day later, Faggin and Ungermann were kicking around ideas based on "integrated logic" when Ungermann said, "How about Zilog?" Faggin immediately agreed, stating they could say it was the "last word in integrated logic". When they met the next day and both immediately recalled it, the company had its name.[15]

Into production[edit]
The first samples were returned from Mostek on March 9, 1976.[11] By the end of the month, they had also completed an assembler-based development system. Some of the Z80 support and peripheral ICs were under development at this point, and many of them were launched during the following year. Among them were the Z80 CTC (counter/timer), Z80 DMA[16] (direct memory access), Z80 DART (dual asynchronous receiver–transmitter), Z80 SIO (synchronous communication controller), and Z80 PIO (parallel input/output).
The Z80 was officially launched in July 1976.[17] One of the first customers was a buyer who, unknown to Zilog, worked for NEC. At the time, the Japanese electronics companies were well known for taking US chip designs and producing them without a license. The Zilog team had worried about this, and Faggin had come up with the idea of adding transistors that would be subtly modified to operate differently than a visual inspection would suggest. Shima added six of these "traps" around the design. Sometime later, Shima was told by an engineer within NEC that the traps had delayed their copying efforts by six months.[18]
The successful launch allowed Faggin and Ungermann to approach Exxon looking for funding to build their own fab. The company agreed, and Zilog built a production line very rapidly. This allowed them to capture about 60 to 70% of the total market for Z80 sales.[19] With their own line running, Mostek was given the go-ahead to start sales of their version, the MK3880, which provided a second source for customers that Intel lacked. At the time, a second source was considered extremely important as a start-up like Zilog might go out of business and leave potential customers stranded.[9][e]

Comparison with the 8080[edit]
Faggin designed the instruction set to be binary compatible with the 8080[20][21] so that most 8080 code, notably the CP/M operating system and Intel's PL/M compiler for 8080 (as well as its generated code), would run unmodified on the new Z80 CPU. Masatoshi Shima designed most of the microarchitecture as well as the gate and transistor levels of the Z80 CPU, assisted by a small number of engineers and layout people.[22][23] CEO Federico Faggin was actually heavily involved in the chip layout work, together with two dedicated layout people. According to Faggin, he worked 80 hours a week in order to meet the tight schedule given by the financial investors.[4]
The Z80 offered many improvements over the 8080:[21]

An enhanced instruction set including:
a more logical, comprehensible and readable system of assembler instruction mnemonics
more flexible 16-bit data movement (load, or LD) instructions, crucially including the stack pointer SP
more flexible addressing modes for input/output to external peripheral ports
single-bit addressing of all registers and memory, including bit testing
shifts/rotates on memory and registers other than the accumulator
improved and more accurate (than the previous 8080) BCD arithmetic
rotate instructions for BCD number strings in memory
16-bit subtraction and 8-bit negation
program looping
program counter (PC) relative jumps
block copy, block input/output (I/O), and byte search instructions.[24]
An overflow flag with better support for signed 8- and 16-bit arithmetics.[f]
New IX and IY index registers with instructions for direct base+offset addressing
A better interrupt system:
A more automatic and general vectorized interrupt system, mode 2, primarily intended for Zilog's line of counter/timers, DMA and communications controllers, as well as a fixed vector interrupt system, mode 1, for simple systems with minimal hardware (with mode 0 being the 8080-compatible mode).[25]
A non-maskable interrupt (NMI), which can be used to respond to power-down situations or other high-priority events (and allowing a minimalistic Z80 system to easily implement a two-level interrupt scheme in mode 1).
A complete duplicate register file,[26] which could be quickly switched, to speed up response to interrupts such as fast asynchronous event handlers or a multitasking dispatcher. Although they were not intended as extra registers for general code, they were nevertheless used that way in some applications.[g]
Less hardware required for power supply, clock generation and interface to memory and I/O
Single 5-volt power supply (the 8080 needed −5 V, +5 V, and +12 V).
Single-phase 5-volt clock (the 8080 needed a high-amplitude (9 to 12 volts) non-overlapping two-phase clock).
Built-in DRAM refresh, which would otherwise require external circuitry, unless SRAM, more expensive and less dense (but faster), was used.[h]
Non-multiplexed buses (the 8080 had state signals multiplexed onto the data bus).
A special reset that zeroes only the program counter, so that a single Z80 CPU could be used in a development system such as an in-circuit emulator.[27]
Success in the market[edit]
The Z80 took over from the 8080 and its offspring, the 8085, in the processor market[28] and became one of the most popular and widely used 8-bit CPUs.[29][30] Some organizations such as British Telecom remained loyal to the 8085 for embedded applications, owing to their familiarity with it and to its on-chip serial interface and interrupt architecture. Likewise, Zenith Data Systems paired the 8085 with the 16-bit Intel 8088 in its first MS-DOS computer, the Zenith Z-100, despite having previous experience with its pioneering Z80-based Heathkit H89 and Zenith Z-89 products. However, other computers were made integrating the Z80 with other CPUs: the Radio Shack TRS-80 Model 16 with a Motorola 68000, the DEC Rainbow with an 8088, and the Commodore 128 with a MOS Technology 8502.
Zilog was later producing a low-power Z80 suitable for the growing laptop computer market of the early 1980s. Intel produced a CMOS 8085 (80C85) used in battery-powered portable computers, such as the Kyocera-designed laptop from April 1983, also sold by Tandy (as TRS-80 Model 100), Olivetti, and NEC. In following years, however, CMOS versions of the Z80 (from both Zilog and Japanese manufacturers) would dominate this market as well, in products such as the Amstrad NC100, Cambridge Z88 and Tandy's own WP-2.
Perhaps a key to the initial success of the Z80 was the built-in DRAM refresh, at least in markets such as CP/M and other office and home computers. (Most Z80 embedded systems use static RAM that do not need refresh.) It may also have been its minimalistic two-level interrupt system, or conversely, its general multi-level daisy-chain interrupt system useful in servicing multiple Z80 IO chips. These features allowed systems to be built with less support hardware and simpler circuit board layouts.
However, others claim that its popularity was due to the duplicated registers that allowed fast context switches or more efficient processing of things like floating-point math compared to 8-bit CPUs with fewer registers. (The Z80 can keep several such numbers internally, using HL'HL, DE'DE and BC'BC as 32-bits registers, avoiding having to access them from slower RAM during computation.)[31]
For the original NMOS design, the specified upper clock-frequency limit increased successively from the introductory 2.5 MHz, via the well known 4 MHz (Z80A), up to 6 MHz (Z80B) and 8 MHz (Z80H).[32][33] An NMOS version was produced as a 10 MHz part beginning in the late 1980s. CMOS versions were developed with specified upper frequency limits ranging from 4 MHz up to 20 MHz for the version sold today. The CMOS versions allowed low-power standby with internal state retained, having no lower frequency limit.[i] The fully compatible derivatives HD64180/Z180[34][35] and eZ80 are currently specified for up to 33 MHz and 50 MHz, respectively.

Design[edit]
This section needs additional citations for verification. Please help improve this article by adding citations to reliable sources in this section. Unsourced material may be challenged and removed. (February 2025) (Learn how and when to remove this message)
Programming model and register set[edit]
An approximate block diagram of the Z80: There is no dedicated adder for offsets or separate incrementer for R, and no need for more than a single 16-bit temporary register WZ (although the incrementer latches are also used as a 16-bit temporary register, in other contexts). It is the PC and IR registers that are placed in a separate group, with a detachable bus segment, to allow updates of these registers in parallel with the main register bank.[36]
The programming model and register set of the Z80 are fairly conventional, ultimately based on the register structure of the Datapoint 2200. The Z80 was designed as an extension of the Intel 8080, created by the same engineers, which in turn was an extension of the 8008. The 8008 was basically a PMOS implementation of the TTL-based CPU of the Datapoint 2200.[j]
The 2200 design allowed 8-bit registers H and L (High and Low) to be paired into a 16-bit address register HL.[k] In the 8080, this pairing was added to the BC and DE pairs as well, while HL was generalized to allow use as a 16-bit accumulator, not just an address register. The 8080 also introduced immediate 16-bit data for BC, DE, HL, and SP loads. Furthermore, direct 16-bit copying between HL and memory was now possible, using a direct address.

The Z80 orthogonalized this further by making all 16-bit register pairs, including IX and IY, more general purpose, as well as allowing 16-bit copying directly to and from memory for all of these pairs. The 16-bit IX and IY registers in the Z80 are primarily intended as base address-registers, where a particular instruction supplies a constant offset that is added to the previous values, but they are also usable as 16-bit accumulators, among other things. A limitation is that all operand references involving IX or IY require an extra instruction prefix byte, adding at least four clock cycles over the timing of an instruction using HL instead; this sometimes makes using IX or IY less efficient than a method using only the 8080-model registers. The Z80 also introduced a new signed overflow flag and complemented the fairly simple 16-bit arithmetics of the 8080 with dedicated instructions for signed 16-bit arithmetics.The Z80's original DIP40 chip package pinoutThe 8080-compatible registers AF, BC, DE, HL are duplicated as a separate register file in the Z80,[37] where the processor can quickly (in four t-states, the least possible execution time for any Z80 instruction) switch from one bank to the other;[38] a feature useful for speeding up responses to single-level, high-priority interrupts. The dual register-set is very useful in the embedded role, as it improves interrupt handling performance, but found widespread use in the personal computer role as an additional set of general registers for complex code like floating-point arithmetic or home computer games.
The duplicate register file is often referred to as the "alternate register set" (by some, the "primed" register file since the apostrophe character is used to denote them in assembler source code and the Zilog documentation). This emphasizes that only one set is addressable at any time. However, the 8-bit accumulator A with its flag register F is bifurcated from the "general purpose" register pairs HL, DE and BC. This is accomplished with two separate instructions used to swap their accessibilities: EX AF,AF' exchanges only register pair AF with AF', while the EXX instruction exchanges the three general purpose register pairs HL, DE and BC with their alternates HL', DE' and BC'. Thus the accumulator A can interact independently with any of the general purpose 8-bit registers in the alternate (or primed) register file, or, if HL' contains a pointer to memory, some byte there (DE' and BC' can also transfer 8-bit data between memory and accumulator A).
This can become confusing for programmers because after executing EX AF,AF' or EXX, the contents of the alternate (primed) registers are now in the main registers, and vice versa. The only way for the programmer to understand and track this swapped condition is to trace through the code flow, noting each occurrence of a register swap instruction. Obviously if jump and call instructions are made within these code segments it can quickly become difficult to tell which register file is in context unless carefully commented. Thus it is advisable that exchange instructions be used directly and in short discrete code segments. The Zilog Z280 instruction set includes JAF and JAR instructions which jump to a destination address if the alternate registers are in context (thus officially recognizing this programming complication).

Registers[edit]

Zilog Z80 registers





15

14

13

12

11

10

09

08

07

06

05

04

03

02

01

00

(bit position)


Main registers


Accumulator (A)

Flags (F)

AF


B

C

BC


D

E

DE


H

L

HL


Alternate (shadow) registers


Accumulator' (A')

Flags' (F')

AF'


B'

C'

BC'


D'

E'

DE'


H'

L'

HL'


Index registers


Index X

IX


Index Y

IY


Stack Pointer

SP


Other registers


 

Interrupt vector

I


 

Refresh counter

R


Program counter


Program Counter

PC


Status register


 

S

Z

-

H

-

P/V

N

C

Flags


As on the 8080, 8-bit registers are typically paired to provide 16-bit versions. The 8080 compatible registers[39] are:

AF: 8-bit accumulator (A) and flag bits (F) carry, zero, minus, parity/overflow, half-carry (used for BCD), and an Add/Subtract flag (usually called N) also for BCD
BC: 16-bit data/address register or two 8-bit registers
DE: 16-bit data/address register or two 8-bit registers
HL: 16-bit accumulator/address register or two 8-bit registers
SP: stack pointer, 16 bits
PC: program counter, 16 bits
The new registers introduced with the Z80 are:

IX: 16-bit index or base register for 8-bit immediate offsets
IY: 16-bit index or base register for 8-bit immediate offsets
I: interrupt vector base register, 8 bits
R: DRAM refresh counter, 8 bits (msb does not count)
AF': alternate (or shadow) accumulator and flags (toggled in and out with EX AF,AF' )
BC', DE' and HL': alternate (or shadow) registers (toggled in and out with EXX)
Four bits of interrupt status and interrupt mode status
The refresh register, R, increments each time the CPU fetches an opcode (or an opcode prefix, which internally executes like a 1-byte instruction) and has no simple relationship with program execution. This has sometimes been used to generate pseudorandom numbers in games, and also in software protection schemes.[citation needed] It has also been employed as a "hardware" counter in some designs; an example of this is the ZX81, which lets it keep track of character positions on the TV screen by triggering an interrupt at wrap around (by connecting INT to A6).
The interrupt vector register, I, is used for the Z80 specific mode 2 interrupts (selected by the IM 2 instruction). It supplies the high byte of the base address for a 128-entry table of service routine addresses which are selected via an index sent to the CPU during an interrupt acknowledge cycle; this index is simply the low byte part of the pointer to the tabulated indirect address pointing to the service routine.[25] The pointer identifies a particular peripheral chip or peripheral function or event, where the chips are normally connected in a so-called daisy chain for priority resolution. Like the refresh register, this register has also sometimes been used creatively; in interrupt modes 0 and 1 (or in a system not using interrupts) it can be used as simply another 8-bit data register.
The instructions LD A,R and LD A,I affect the Z80 flags register, unlike all the other LD (load) instructions. The Sign (bit 7) and Zero (bit 6) flags are set according to the data loaded from the Refresh or Interrupt source registers. For both instructions, the Parity/Overflow flag (bit 2) is set according to the current state of the IFF2 flip-flop.[40]

Microarchitecture[edit]
Although the Z80 is generally considered an eight-bit CPU, it has a four-bit ALU, so calculations are done in two steps.[41]

Z80 assembly language[edit]
Datapoint 2200 and Intel 8008[edit]
The first Intel 8008 assembly language was based on a very simple (but systematic) syntax inherited from the Datapoint 2200 design. This original syntax was later transformed into a new, somewhat more traditional, assembly language form for this same original 8008 chip. At about the same time, the new assembly language was also extended to accommodate the additional addressing modes in the more advanced Intel 8080 chip (the 8008 and 8080 shared a language subset without being binary compatible; however, the 8008 was binary compatible with the Datapoint 2200).
In this process, the mnemonic L, for LOAD, was replaced by various abbreviations of the words LOAD, STORE and MOVE, intermixed with other symbolic letters. The mnemonic letter M, for memory (referenced by HL), was lifted out from within the instruction mnemonic to become a syntactically freestanding operand, while registers and combinations of registers became very inconsistently denoted; either by abbreviated operands (MVI D, LXI H and so on), within the instruction mnemonic itself (LDA, LHLD and so on), or both at the same time (LDAX B, STAX D and so on).



Intel 8008Datapoint 2200

Intel 8080Intel 8085

Zilog Z80

Intel 8086/Intel 8088


before ca. 1973

ca. 1974

1976

1978


LBC

MOV B,C

LD B,C

MOV CH,CL


--

LDAX B

LD A,(BC)

--


LAM

MOV A,M

LD A,(HL)

MOV AL,[BX]


LBM

MOV B,M

LD B,(HL)

MOV CH,[BX]


--

STAX D

LD (DE),A

--


LMA

MOV M,A

LD (HL),A

MOV [BX],AL


LMC

MOV M,C

LD (HL),C

MOV [BX],CL


LDI 56

MVI D,56

LD D,56

MOV DL,56


LMI 56[l]

MVI M,56

LD (HL),56

MOV byte ptr [BX],56


--

LDA 1234

LD A,(1234)

MOV AL,[1234]


--

STA 1234

LD (1234),A

MOV [1234],AL


--

--

LD B,(IX+56)

MOV CH,[SI+56]


--

--

LD (IX+56),C

MOV [SI+56],CL


--

--

LD (IY+56),78

MOV byte ptr [DI+56],78


--

LXI B,1234

LD BC,1234

MOV CX,1234


--

LXI H,1234

LD HL,1234

MOV BX,1234


--

SHLD 1234

LD (1234),HL

MOV [1234],BX


--

LHLD 1234

LD HL,(1234)

MOV BX,[1234]


--

--

LD BC,(1234)

MOV CX,[1234]


--

--

LD IX,(1234)

MOV SI,[1234]
Illustration of four syntaxes, using samples of equivalent, or (for 8086) very similar, load and store instructions.[42] The Z80 syntax uses parentheses around an expression to indicate that the value should be used as a memory address (as mentioned below), while the 8086 syntax uses brackets instead of ordinary parentheses for this purpose. Both Z80 and 8086 use the + sign to indicate that a constant is added to a base register to form an address. Note that the 8086 is not a complete superset of the Z80. BX is the only 8086 register pair that can be used as a pointer.
New syntax[edit]
Because Intel claimed a copyright on their assembly mnemonics,[43] a new assembly syntax had to be developed for the Z80. This time a more systematic approach was used:

All registers and register pairs are explicitly denoted by their full names
Parentheses are consistently used to indicate "memory contents at" (constant address or variable pointer dereferencing) with the exception the jump instructions JP (HL), JP (IX), and JP (IY). These load the new PC address from the respective register directly, without indirecting through memory.[m]
All load and store instructions use the same mnemonic name, LD, for LOAD (a return to the simplistic Datapoint 2200 vocabulary); other common instructions, such as ADD and INC, use the same mnemonic regardless of addressing mode or operand size. This is possible because the operands themselves carry enough information.
These principles made it straightforward to find names and forms for all new Z80 instructions, as well as orthogonalizations of old ones, such as LD BC,1234.
Apart from naming differences, and despite a certain discrepancy in basic register structure, the Z80 and 8086 syntax are virtually isomorphic for a large portion of instructions. Only quite superficial similarities (such as the word MOV, or the letter X, for extended register) exist between the 8080 and 8086 assembly languages, although 8080 programs can be translated to 8086 assembly language by translator programs.[45][46]

Instruction set and encoding[edit]
The Z80 uses 252 out of the available 256 codes as single byte opcodes ("root instruction" most of which are inherited from the 8080); the four remaining codes are used extensively as opcode prefixes:[47] CB and ED enable extra instructions, and DD or FD select IX+d or IY+d respectively (in some cases without displacement d) in place of HL. This scheme gives the Z80 a large number of permutations of instructions and registers; Zilog categorizes these into 158 different "instruction types", 78 of which are the same as those of the Intel 8080[47] (allowing operation of all 8080 programs on a Z80). The Zilog documentation[48] further groups instructions into the following categories (most from the 8080, others entirely new like the block and bit instructions, and others 8080 instructions with more versatile addressing modes, like the 16-bit loads, I/O, rotates/shifts and relative jumps):

Load and exchange
Block transfer and search
Arithmetic and logical
Rotate and shift
Bit manipulation (set, reset, test)
Jump, call and return
Input/output
Basic CPU control
No explicit multiply instructions are available in the original Z80,[49] though registers A and HL can be multiplied by powers of two with ADD A,A and ADD HL,HL instructions (similarly IX and IY also). Shift instructions can also multiply or divide by powers of two.
Different sizes and variants of additions, shifts, and rotates have somewhat differing effects on flags because most of the flag-changing properties of the 8080 were copied. However, the parity flag bit P of the 8080 (bit 2) is called P/V (parity/overflow) in the Z80 as it serves the additional purpose of a twos complement overflow indicator, a feature lacking in the 8080. Arithmetic instructions on the Z80 set it to indicate overflow rather than parity, while bitwise instructions still use it as a parity flag. (This introduces a subtle incompatibility of the Z80 with code written for the 8080, as the Z80 sometimes indicates signed overflow where the 8080 would indicate parity, possibly causing the logic of some practical 8080 software to fail on the Z80.[n]) This new overflow flag is used for all new Z80-specific 16-bit operations (ADC, SBC) as well as for 8-bit arithmetic operations, while the 16-bit operations inherited from the 8080 (ADD, INC, DEC) do not affect it. Also, bit 1 of the flags register (a spare bit on the 8080) is used as a flag N that indicates whether the last arithmetic instruction executed was a subtraction or addition. The Z80 version of the DAA instruction (decimal adjust accumulator for BCD arithmetic) checks the N flag and behaves accordingly, so a (hypothetical) subtraction followed later by DAA will yield a different result on an old 8080 than on the Z80. However, this would likely be erroneous code on the 8080, as DAA was defined for addition only on that processor.
The Z80 has six new LD instructions that can load the DE, BC, and SP register pairs from memory, and load memory from these three register pairs—unlike the 8080.[42] As on the 8080, load instructions do not affect the flags (except for the special-purpose I and R register loads). A result of a regular encoding (common with the 8080) is that each of the 8-bit registers can be loaded from themselves (e.g. LD A,A). This is effectively a NOP.
New block transfer instructions can move up to 64 kilobytes from memory to memory or between memory and I/O peripheral ports. Block instructions LDIR and LDDR (load, increment/decrement, repeat) use HL to point to the source address, DE to the destination address, and BC as a byte counter. Bytes are copied from source to destination, the pointers are incremented or decremented, and the byte counter is decremented until BC reaches zero. Non-repeating versions LDI and LDD move a single byte and bump the pointers and byte counter, which if it becomes zero resets the P/V flag. Corresponding memory-to-I/O instructions INIR, INDR, OTIR, OTDR, INI, IND, OUTI and OUTD operate similarly, except that B, not BC, is used as the byte counter.[50][51] The Z80 can input and output any register to an I/O port using register C to designate the port. (The 8080 only performs I/O through the accumulator A, using a direct port address specified in the instruction; a self-modifying code technique is required to use a variable 8080 port address.)
The last group of block instructions perform a CP compare operation between the byte at (HL) and the accumulator A. Register pair DE is not used. The repeating versions CPIR and CPDR only terminate if BC goes to zero or a match is found. HL is left pointing to the byte after (CPIR) or before (CPDR) the matching byte. If no match is found, the Z flag is reset. There are non-repeating versions CPI and CPD.
Unlike the 8080, the Z80 can jump to a relative address (JR instead of JP) using a shorter instruction with a signed 8-bit displacement. There are unconditional and conditional forms of this instruction. Only the zero and carry conditions can be tested. (All 8080 jumps and calls, conditional or not, are three-byte instructions.) If jump is taken, the two-byte JR instructions are slower than the 8080-style three-byte JP instructions; if not taken, JR instructions are quicker.
A two-byte instruction specialized for program looping is also new to the Z80: DJNZ (decrement jump if non-zero) takes a signed 8-bit displacement as an operand. The B register is decremented, and if the result is nonzero, then program execution jumps relative to PC; the flags remain unaltered. To perform an equivalent loop on an 8080 requires separate DEC and conditional jump (to a two-byte absolute address) instructions (totalling four bytes), and the DEC alters the flag register.
The index register (IX/IY, often abbreviated XY) instructions can be useful for accessing data organised in fixed heterogenous structures (such as records) or at fixed offsets relative a variable base address (as in recursive stack frames) and can also reduce code size by removing the need for multiple short instructions using non-indexed registers. However, although they may save speed in some contexts when compared to long/complex "equivalent" sequences of simpler operations, they incur a lot of additional CPU time (e.g., 19 T-states to access one indexed memory location vs. as little as 11 to access the same memory using HL and INC to point to the next). Thus, for simple or linear accesses of data, use of IX and IY tend to be slower and occupy more memory. Still, they may be useful in cases where the "main" registers are all occupied, by removing the need to save/restore registers. Their officially undocumented 8-bit halves (see below) can be especially useful in this context, for they incur less slowdown than their 16-bit parents. Similarly, instructions for 16-bit additions are not particularly fast (11 clocks) in the original Z80 (being 1 clock slower than in the 8080/8085); nonetheless, they are about twice as fast as performing the same calculations using 8-bit operations, and equally important, they reduce register usage. It was not uncommon for programmers to "poke" different offset displacement bytes (which were typically calculated dynamically) into indexed instructions; this is an example of self-modifying code, which was regular practice on nearly all early 8-bit processors with non-pipelined execution units.
The index registers have a parallel instruction to JP (HL), which is JP (XY). This is often seen in stack-oriented languages like Forth, which at the end of every Forth word (atomic subroutines comprising the language) must jump unconditionally back to their thread interpreter routines. Typically this jump instruction appears many hundreds of times in an application, and using JP (XY) rather than JP THREAD saves a byte and two T-states for each occurrence. This naturally makes the index register unavailable for any other use, or else the need to constantly reload it would negate its efficiency.
The 10-year-newer microcoded Z180 design could initially afford more "chip area", permitting a slightly more efficient implementation (using a wider ALU, among other things); similar things can be said for the Z800, Z280, and Z380. However, it was not until the fully pipelined eZ80 was launched in 2001 that those instructions finally became approximately as cycle-efficient as it is technically possible to make them, i.e. given the Z80 encodings combined with the capability to do an 8-bit read or write every clock cycle.[citation needed]

Undocumented instructions[edit]
The index registers, IX and IY, were intended as flexible 16-bit pointers, enhancing the ability to manipulate memory, stack frames and data structures. Officially, they were treated as 16-bit only. In reality they were implemented as a pair of 8-bit registers,[52] in the same fashion as the HL register, which is accessible either as 16 bits or separately as the High and Low registers. The binary opcodes (machine language) were identical, but preceded by a new opcode prefix.[53] Zilog published the opcodes and related mnemonics for the intended functions, but did not document the fact that every opcode that allowed manipulation of the H and L registers was equally valid for the 8 bit portions of the IX and IY registers. For example, the opcode 26h followed by an immediate byte value (LD H,n) will load that value into the H register. Preceding this two-byte instruction with the IX register's opcode prefix, DD, would instead result in the most significant 8 bits of the IX register being loaded with that same value. A notable exception to this would be instructions similar to LD H,(IX+d) which make use of both the HL and IX or IY registers in the same instruction;[53] in this case the DD prefix is only applied to the (IX+d) portion of the instruction. The halves of the XY registers could also hold operands for 8-bit arithmetic, logical and compare instructions, sparing the regular 8-bit registers for other use. The undocumented ability to increment and decrement the upper half of an index register made it easy to expand the range of the normal indexed instructions, without having to resort to the documented ADD/SBC XY,DE or ADD/SBC XY,BC.
There are several other undocumented instructions as well.[54] Undocumented or illegal opcodes are not detected by the Z80 and have various effects, some of which are useful. However, as they are not part of the formal definition of the instruction set, different implementations of the Z80 are not guaranteed (or especially likely) to work the same way for every undocumented opcode.

Bugs[edit]
The OTDR instruction does not conform to the Z80 documentation. Both the OTDR and OTIR instructions are supposed to leave the carry (C) flag unmodified. The OTIR instruction operates correctly; however, during the execution of the OTDR instruction, the carry flag takes the results of a spurious compare between the accumulator (A) and the last output of the OTDR instruction.[55]

Example code[edit]
The following Z80 assembly source code is for a subroutine named memcpy that copies a block of data bytes of a given size from one location to another. Important: the example code does not handle the case where the destination block overlaps the source; a serious limitation, but one that is irrelevant for some applications—such as, especially, when the source is in ROM and the destination in RAM, so they can never overlap. The data block is copied one byte at a time, and the data movement and looping logic utilizes 16-bit operations. It demonstrates a variety of instructions but in practice it would not be coded this way as the Z80 has a single instruction that will replace this entire subroutine: LDIR. The sample code will move one byte every 46 T-states. Substituting the LDIR instruction will move each byte in only 21 T-states. Note that the assembled code is binary-compatible with the Intel 8080 and 8085 CPUs.



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 1000
 1000
 1000 F5
 1001 7E
 1002 12
 1003 23
 1004 13
 1005 0B
 1006 78
 1007 B1
 1008 C2 01 10
 100B F1
 100C C9
 100D


 ; memcpy --
 ; Copy a block of memory from one location to another.
 ; This routine is the equivalent of LDIR
 ;
 ; Entry registers
 ; HL - Address of source data block
 ; DE - Address of destination data block
 ; BC - Number of bytes to copy
 ;
 ; Return registers
 ; HL - First byte after source data block
 ; DE - First byte after destination data block
 ; BC - Zero
 ; (LDIR does not fully save AF. H, P/V, and N are reset.)

             org     1000h       ; Origin at 1000h
 memcpy      public
             push    af          ; Save AF like LDIR
 loop        ld      a,(hl)      ; Copy 1 source byte
             ld      (de),a      ; to its destination
             inc     hl          ; Bump source pointer
             inc     de          ; Bump dest pointer
             dec     bc          ; Count the copied byte
             ld      a,b         ; Test BC for zero
             or      c           ; If BC != 0,
             jp      nz,loop     ; repeat the loop
             pop     af          ; Restore AF
             ret                 ; Return
             end


Instruction execution[edit]
Each instruction is executed in steps that are usually termed machine cycles (M-cycles), each of which can take between three and six clock periods (T-states).[56] Each M-cycle corresponds roughly to one memory access or internal operation. Many instructions actually end during the M1 of the next instruction which is known as a fetch/execute overlap.


Examples of typical instructions (R=read, W=write)


Total
M-cycles


T-states

instruction

M1

M2

M3

M4

M5

M6


1[57]

4[1]

INC B

opcode









2[58]

7

ADD A,n

opcode

n








3[59]

11

ADD HL,DE

opcode

internal

internal






4[60]

15

SET b,(HL)

prefix

opcode

R(HL), set

W(HL)





5[61]

19

LD (IX+d),n

prefix

opcode

d

n,add

W(IX+d)



6[62]

23

INC (IY+d)

prefix

opcode

d

add

R(IY+d),inc

W(IY+d)

The Z80 machine cycles are sequenced by an internal state machine which builds each M-cycle out of 3, 4, 5 or 6 T-states depending on context. This avoids cumbersome asynchronous logic and makes the control signals behave consistently at a wide range of clock frequencies. It also means that a higher frequency crystal must be used than without this subdivision of machine cycles (approximately 2–3 times higher). It does not imply tighter requirements on memory access times, since a high resolution clock allows more precise control of memory timings and so memory can be active in parallel with the CPU to a greater extent, allowing more efficient use of available memory bandwidth.[citation needed]
One central example of this is that, for opcode fetch, the Z80 combines two full clock cycles into a memory access period (the M1-signal). In the Z80 this signal lasts for a relatively larger part of the typical instruction execution time than in a design such as the 6800, 6502, or similar, where this period would typically last typically 30-40% of a clock cycle.[citation needed] With memory chip affordability (i.e. access times around 450-250 ns in the 1980s[citation needed]) typically determining the fastest possible access time, this meant that such designs were locked to a significantly longer clock cycle (i.e. lower internal clock speed) than the Z80.
Memory was generally slow compared to the state machine sub-cycles (clock cycles) used in contemporary microprocessors. The shortest machine cycle that could safely be used in embedded designs has therefore often been limited by memory access times, not by the maximum CPU frequency (especially so during the home computer era). However, this relation has slowly changed during the last decades, particularly regarding SRAM; cacheless, single-cycle designs such as the eZ80 have therefore become much more meaningful recently.
The content of the refresh register R is sent out on the lower half of the address bus along with a refresh control signal while the CPU is decoding and executing the fetched instruction. During refresh the contents of the Interrupt register I are sent out on the upper half of the address bus.[63]

Compatible peripherals[edit]
Zilog introduced a number of peripheral parts for the Z80, which all support the Z80's interrupt handling system and I/O address space. These include the counter/timer channel (CTC),[64] the SIO (serial input/output), the DMA (direct memory access), the PIO (parallel input/output) and the DART (dual asynchronous receiver–transmitter). As the product line developed, low-power, high-speed and CMOS versions of these chips were introduced.




PIO Z84C2008



CTC Z84C3008



SIO Z84C4008


Like the 8080, 8085 and 8086 processors, but unlike processors such as the Motorola 6800 and MOS Technology 6502, the Z80 and 8080 has a separate control line and address space for I/O instructions. While some Z80-based computers such as the Osborne 1 used "Motorola-style" memory mapped input/output devices, usually the I/O space was used to address one of the many Zilog peripheral chips compatible with the Z80. During the timing for an I/O read or an I/O write operation, a single wait cycle is automatically inserted by the Z80.[65] Zilog I/O chips supported the Z80's new mode 2 interrupts which simplified interrupt handling for large numbers of peripherals.
The Z80 was officially described as supporting 16-bit (64 KB) memory addressing, and 8-bit (256 ports) I/O-addressing. All I/O instructions actually assert the entire 16-bit address bus. OUT (C),reg and IN reg,(C) places the contents of the entire 16-bit BC register on the address bus;[55] OUT (n),A and IN A,(n) places the contents of the A register on b8–b15 of the address bus and n on b0–b7 of the address bus. A designer could choose to decode the entire 16-bit address bus on I/O operations in order to take advantage of this feature, or use the high half of the address bus to select subfeatures of the I/O device. This feature has also been used to minimise decoding hardware requirements, such as in the Amstrad CPC/PCW and ZX81.

Second sources and derivatives[edit]
Second sources[edit]
Mostek, which produced the first Z80 for Zilog, offered it second-source as MK3880. SGS-Thomson (now STMicroelectronics) was a second source, too, with their Z8400. Sharp and NEC developed second sources for the NMOS Z80, the LH0080 and μPD780C, respectively. The LH0080 was used in various home computers and personal computers made by Sharp and other Japanese manufacturers, including Sony MSX computers, and a number of computers in the Sharp MZ series.[66] Sharp developed the LH0080A and LH0080B to operate at frequencies of 4 MHz and 6 MHz, respectively.[67] Sharp also developed LH0083[68] compatible with Z80 DMA.
Toshiba made a CMOS-version, the TMPZ84C00, which is believed[by whom?] (but not verified) to be the same design also used by Zilog for its own CMOS Z84C00. There were also Z8400, Z80-chips made by GoldStar (now LG) and the BU18400 series of Z80-clones (including DMA, PIO, CTC, DART and SIO) in NMOS and CMOS made by ROHM Electronics. The LH5080,[69] LH5081,[70] and LH5082,[71] which are CMOS versions of the Z80, PIO, and CTC respectively, are manufactured by Sharp.
In East Germany, an unlicensed clone of the Z80, known as the U880, was manufactured. It was used extensively in Robotron's and VEB Mikroelektronik Mühlhausen's computer systems (such as the KC85-series) and also in many self-made computer systems. In Romania another unlicensed clone could be found, named MMN80CPU and produced by Microelectronica, used in home computers like TIM-S, HC, COBRA.
Also, several clones of Z80 were created in the Soviet Union, notable ones being the T34BM1, also called КР1858ВМ1 (parallelling the Soviet 8080-clone KR580VM80A). The first marking was used in pre-production series, while the second had to be used for a larger production. Though, due to the collapse of Soviet microelectronics in the late 1980s, there are many more T34BM1s than КР1858ВМ1s.[citation needed]




Mostek Z80: MK3880



NEC μPD780C



Sharp LH0080



Toshiba Z84C00



East Germany RFT U880D



Soviet T34BM1 Z80 clone


Derivatives[edit]
Compatible with the original Z80

Hitachi developed the HD64180, a microcoded and partially dynamic Z80 in CMOS, with on-chip peripherals and a simple MMU, giving a 1 MB address space. It was later second sourced by Zilog, initially as the Z64180, and then in the form of the slightly modified Zilog Z180[72] which has bus protocol and timings better adapted to Z80 peripheral chips. Z180 has been maintained and further developed under Zilog's name, the newest versions being based on the fully static S180/L180 core with very low power draw and EMI (noise).
Toshiba developed the 84-pin Z84013 / Z84C13 and the 100 pin Z84015 / Z84C15 series of "intelligent peripheral controllers", basically ordinary NMOS and CMOS Z80 cores with Z80 peripherals, watchdog timer, power on reset, and wait state generator on the same chip. Manufactured by Sharp as well as Toshiba. These products are today second sourced by Zilog.[73]
The 32-bit Z80 compatible Zilog Z380, introduced 1994, is used in telecom equipment.[74]
Zilog's fully pipelined Z80 compatible eZ80[75] with an 8/16/24-bit word length and a linear 16 MB address space was introduced in 2001. It exists in versions with on-chip SRAM or Flash memory, as well as with integrated peripherals. One variant has an on-chip medium access controller (MAC), and available software include a TCP/IP stack. In contrast with the Z800 and Z280, there are only a few added instructions (primarily load Effective Address (LEA), Push Effective Address (PEA), and variable-address 16/24-bit loads), but instructions are instead executed between 2 and 11 times as clock cycle efficiently as on the original Z80, with a mean value around 3-5 times. It is currently specified for clock frequencies up to 50 MHz.
Kawasaki developed the binary compatible KL5C8400 which is approximately 1.2-1.3 times as clock cycle efficient as the original Z80 and can be clocked at up to 33 MHz. Kawasaki also produces the KL5C80A1x family, which has peripherals as well as a small RAM on chip; it is approximately as clock cycle efficient as the eZ80 and can be clocked at up to 10 MHz (2006).[76]
The NEC μPD9002 was a hybrid CPU compatible with both Z80 and x86 families.
The Chinese Actions Semiconductor's audio processor family of chips (ATJ2085 and others) contains a Z80-compatible MCUs together with a 24-bit dedicated DSP processor.[77] These chips are used in many MP3 and media player products.
The T80 (VHDL) and TV80 (Verilog) synthesizable soft cores are available from OpenCores.org.[78]
The National Semiconductor NSC800 announced in 1980[79] is used in many TeleSecurity Timmann (TST) electronic cipher machines[80] and the Canon X-07. The NSC800 is fully compatible with the Z-80 instruction set.[81] The NSC800 uses a multiplexed bus like the 8085 but has a different pinout than the Z80.[82]
Non-compatible

The Toshiba TLCS 900 series of high volume, mostly one-time programmable microcontrollers are based on the Z80. They share the same basic BC,DE,HL,IX,IY register structure, and largely the same instructions, but are not binary compatible, while the previous TLCS 90 is Z80-compatible.[83]
The NEC 78K series microcontrollers are based on the Z80. They share the same basic BC,DE,HL register structure, and has similar, but differently named instructions; not binary compatible.
Partly compatible

Rabbit Semiconductor's Rabbit 2000/3000/4000 microprocessors/microcontrollers[84] are based on the HD64180/Z180 architecture, although they are not fully binary compatible.[85]
No longer produced

The ASCII Corporation R800 was a fast 16-bit processor used in MSX TurboR computers; it was software-, but not hardware-compatible with the Z80 (signal timing, pinout and function of pins differ from the Z80).
Zilog's NMOS Z800 and CMOS Z280 were 16-bit Z80 implementations (before the HD64180/Z180) with a 16 MB-paged MMU address space; they added many orthogonalizations and addressing modes to the Z80 instruction set. Minicomputer features — such as user and system modes, multiprocessor support, on chip MMU, on chip instruction and data cache, and so on — were seen rather as more complexity than as functionality and support for the (usually electronics-oriented) embedded systems designer; it also made it very hard to predict instruction execution times.[citation needed]
Certain arcade games, such as Pang/Buster Bros., use an encrypted "Kabuki" Z80 CPU manufactured by VLSI Technology, where the decryption keys are stored in its internal battery-backed memory, to avoid piracy and illegal bootleg games.[86]



ASCII R800



Hitachi HD64180



Zilog Z180



Zilog Z280



Toshiba TMPZ84C015


Notable uses[edit]
Desktop computers[edit]
See also: list of home computers
The Z80A was used as the CPU in a number of gaming consoles, such as this ColecoVision.
During the late 1970s and early 1980s, the Z80 was used in a great number of fairly anonymous business-oriented machines with the CP/M operating system, a combination that dominated the market at the time.[87][88] Four well-known examples of Z80 business computers running CP/M are the Heathkit H89, the portable Osborne 1, the Kaypro series, and the Epson QX-10. Less well-known was the expensive high-end Otrona Attache.[89] Some systems used multi-tasking operating system software (like MP/M or Morrow's Micronix) to share the one processor between several concurrent users.

A Sinclair ZX Spectrum which uses a Z80 clocked at 3.5 MHz
Multiple home computers were introduced that used the Z80 as the main processor or as a plug-in option to allow access to software written for the Z80. Notable are the TRS-80 series, including the original model (later retronymed "Model I"), Model II, Model III, and Model 4, which were equipped with a Z80 as their main processor, and some (but not all) other TRS-80 models which used the Z80 as either the main or a secondary processor. Other notable machines were the DEC Rainbow 100, and the Seequa Chameleon, both of which featured both an Intel 8088 and a Z80 CPU, to support either 8-bit CP/M-80 applications running on the Z80, or a custom MS-DOS that was not fully compatible with PC DOS applications running on the 8088.
In 1981, Multitech (later to become Acer) introduced the Microprofessor I, a simple and inexpensive training system for the Z80 microprocessor. Currently, it is still manufactured and sold by Flite Electronics International Limited in Southampton, England.
In 1984 Toshiba introduced the Toshiba MSX HX-10 in Japan and Australia.
In 1985, Sharp introduced the Hotbit and Gradiente introduced the Expert, which became the dominant 8-bit home computers in Brazil until the late 1980s.

Portable and handheld computers[edit]
Use of the Z80 in lighter, battery-operated devices became more widespread with the availability of CMOS versions of the processor. It also inspired the development of other CMOS based processors, such as the LH5801[90] from Sharp. The Sharp PC-1500, a BASIC-programmable pocket computer was released in 1981, followed by the improved Sharp PC-1600 in 1986 and the Sharp PC-E220 in 1991. Later models of the Sharp Wizard series of personal organizers also were Z80 based. Laptops which could run the CP/M operating system just like the desktop machines followed with Epson PX-8 Geneva in 1984, and in 1985 the Epson PX-4 and Bondwell-2. While the laptop market in subsequent years moved to more powerful Intel 8086 processors and the MS-DOS operating system, light-weight Z80-based systems with a longer battery life were still being introduced, such as the Cambridge Z88 in 1988 and the Amstrad NC100 in 1992. The Z80-derived Z8S180 also found its way into an early pen-operated personal digital assistant, the Amstrad PenPad PDA600 in 1993. Hong Kong-based VTech produced a line of small laptop computers called 'Lasers' based on a Z80.[91][92] The last two were the Laser PC5[93] and PC6.[94]
The Cidco MailStation Mivo 100, first released in 1999, was a stand-alone portable email device, with a Z80-based microcontroller.[95] Texas Instruments produced a line of pocket organizers (ending in 2000) using Toshiba processors built around a Z80 core; the first of these was the TI PS-6200[96] and after a lengthy production run of some dozen models culminated in their PocketMate series.[97]

Embedded systems and consumer electronics[edit]
Z80-based PABX. The Z80 is to the right of the chip with the hand-written white label on it.
The Zilog Z80 has long been a popular microprocessor in embedded systems and microcontroller cores,[39] where it remains in widespread use today.[29][98] Applications of the Z80 include uses in consumer electronics, industrial products, and electronic musical instruments. For example, Z80 was used in the groundbreaking music synthesizer Prophet-5,[99] as well as in the first MIDI-equipped synthesizer, the Prophet 600.[100] The Z80 was the basis for all E-mu Systems instruments from 1976 to 1986.[101] Casio used the Z80A in its PV-1000 video game console.
Many early-1980s arcade video games, including the arcade game Pac-Man, contain Z80 CPUs.
The Z80 was used in Sega's Master System and Game Gear consoles. The Sega Genesis contains a Z80, with its own 8 KB of RAM, which runs in parallel with the MC68000 main CPU, has direct access to the system's sound chips and I/O (controller) ports, and has a switched data path to the main memory bus of the 68000 (providing access to the 64 KB main RAM, the software cartridge, and the whole video chip); in addition to providing backward compatibility with Master System games, the Z80 is often used to control and play back audio in Genesis software.[o]
Z80 CPUs were also used in the popular TI-8x series of graphing calculators from Texas Instruments, beginning in 1990 with the TI-81, which features a Z80 clocked at 2 MHz. Most higher-line calculators in the series, starting with the TI-82 and TI-85, clock their Z80 CPUs at 6 MHz or higher. (A few models with TI-8x names use other CPUs, such as the M68000, but the vast majority are Z80-based. On those, it is possible to run assembled or compiled user programs in the form of Z80 machine-language code.) The TI-84 Plus series, introduced in 2004, is still in production as of 2023. The TI-84 Plus CE series, introduced in 2015, uses the Z80-derived Zilog eZ80 processor and is also still in production as of 2024.
In the late 1980s, a series of Soviet landline phones called "AON" featured the Z80; these phones expanded the feature set of the landline with caller ID, different ringtones based on the caller, speed dial and so forth.[102] In the second half of the 1990s however, manufacturers of these phones switched to 8051 compatible MCUs to reduce power consumption, and prevent compact wall power adapters from overheating.

Discontinuation[edit]
On April 15, 2024, Zilog announced the discontinuation of the Z80 processor, with orders being accepted until June 14, 2024. The announcement included 13 variants of the Z80 processor, many of which were DIP40 variants of the chip. Zilog will continue to manufacture the upgraded eZ80 version of the processor.[5]

See also[edit]
S-100 bus
SymbOS
Z88DK
Micro-Professor MPF-I, Z80 training system
Footnotes[edit]


^ Only in CMOS, National made no NMOS version, according to Oral History with Federico Faggin

^ CMOS variants went up to 20 MHz and binary compatible derivatives went up to 50 MHz

^ Backwards compatible with Intel 8080

^ This was a fairly common feature of minicomputer designs of the era, and found its way into a number of early microprocessors.

^ Zilog manufactured the Z80 as well as most of their other products for many years until they sold their manufacturing plants and become the "fabless" company they are today.

^ Although the 8080 had 16-bit addition and 16-bit increment and decrement instructions, it had no explicit 16-bit subtraction, and no overflow flag. The Z80 complemented this with the ADC HL,rr and SBC HL,rr instructions, which sets the new overflow flag accordingly. (The 8080-compatible ADD HL,rr does not.)

^ Notably to simultaneously handle the 32-bit mantissas of two operands in the 40-bit floating-point format used in the ZX81 home computer. They were also used in a similar fashion in some earlier but lesser known Z80-based computers, such as the Swedish ABC 80 and ABC 800.

^ As this refresh does not need to transfer any data, just output sequential row-addresses, it occupies less than 1.5 T-states. The dedicated M1-signal (machine cycle one) in the Z80 can be used to allow memory chips the same amount of access time for instruction fetches as for data access, i.e almost 2 full T-states out of the 4T fetch cycle (as well as out of the 3T data read cycle). The Z80 could use memory with the same range of access times as the 8080 (or the 8086) at the same clock frequency. This long M1-signal (relative to the clock) also meant that the Z80 could employ about 4–5 times the internal frequency of a 6800, 6502 or similar using the same type of memory.

^ Unlike the original nMOS version, which used dynamic latches and could not be stopped for more than a few thousand clock cycles.

^ The related 8086 family also inherited this register design.

^ This variable HL pointer was actually the only way to access memory (for data) in the Datapoint 2200, and hence also in the Intel 8008. No direct addresses could be used to access data.

^ Load memory immediate not available on Datapoint 2200.

^ Jump (JP) instructions, which load the program counter with a new instruction address, do not themselves access memory. Absolute and relative forms of the jump reflect this by omitting the round brackets from their operands. Register based jump instructions such as "JP (HL)" include round brackets in an apparent deviation from this convention.[44]

^ For example, on the 8080, a programmer might test the parity of a byte by ADDing zero to it, by SUBtracting zero from it, or by ORing or XORing it with zero; all of these are single-instruction operations of the same speed and size, on both the 8080 and the Z80. If the programmer happened to choose to test parity by ORing or XORing with zero, then the Z80 will execute the program correctly, but if the programmer chose to test parity by ADDing or SUBtracting zero, then the Z80 will always reset the P/V flag to zero (since adding or subtracting zero never causes an overflow or underflow) instead of assigning P to correctly indicate the parity of the byte (as the 8080—or 8085—would), and the program may fail. Nothing in the Intel programming manuals or other documentation for the 8080 discouraged use of arithmetic instructions, or prescribed using logical instructions, to test parity, so there is no reason that an 8080 programmer exercising recommended good programming practice should be expected to have chosen one of the ways that will work on the Z80 over one of the ways that will not work.

^ This common, but merely optional and not limiting, usage leads to the frequent but incorrect description of the Z80 in the Genesis as a "sound processor".


References[edit]


^ a b c Zilog (2005). Z80 Family CPU User Manual (PDF). Zilog. p. 5. Archived (PDF) from the original on June 19, 2009. Retrieved July 18, 2009.

^ "Chip Hall of Fame: Zilog Z80 Microprocessor - IEEE Spectrum". spectrum.ieee.org. Retrieved November 22, 2024.

^ Edwards, Benj (April 22, 2024). "After 48 years, Zilog is killing the classic standalone Z80 microprocessor chip". Ars Technica. Retrieved November 22, 2024.

^ a b Faggin, Shima & Ungermann 2007.

^ a b Edwards, Benj (April 22, 2024). "After 48 years, Zilog is killing the classic standalone Z80 microprocessor chip". Ars Technica. Archived from the original on May 12, 2024. Retrieved May 23, 2024.

^ a b Faggin, Shima & Ungermann 2007, p. 1.

^ a b Faggin, Shima & Ungermann 2007, p. 2.

^ a b c Faggin, Shima & Ungermann 2007, p. 3.

^ a b c Faggin, Shima & Ungermann 2007, p. 4.

^ Faggin, Shima & Ungermann 2007, p. 8.

^ a b Faggin, Shima & Ungermann 2007, p. 5.

^ Faggin, Shima & Ungermann 2007, p. 19.

^ Faggin, Shima & Ungermann 2007, p. 6.

^ Faggin, Shima & Ungermann 2007, p. 7.

^ Faggin, Shima & Ungermann 2007, p. 17.

^ "Z80® DMA Direct Memory Access Controller" (PDF). Archived (PDF) from the original on February 5, 2024. Retrieved January 8, 2024.

^ Anderson (1994), p. 51.

^ Faggin, Shima & Ungermann 2007, p. 13.

^ Faggin, Shima & Ungermann 2007, p. 9.

^ Anderson (1994), p. 57.

^ a b Brock, Gerald W. (2003). The second information revolution. Harvard University Press. ISBN 978-0-674-01178-6.

^ "History of the 8-bit: travelling far in a short time". InfoWorld. Vol. 4, no. 47. Palo Alto, CA: Popular Computing Inc. November 29, 1982. pp. 58–60. ISSN 0199-6649. Archived from the original on January 5, 2024.

^ Faggin, Federico; Shima, Masatoshi; Ungermann, Ralph (August 19, 1976). "Z-80 chip set heralds third microprocessor generation" (PDF). Electronics. Vol. 49, no. 17. New York: McGraw–Hill. pp. 89–93. Archived (PDF) from the original on January 31, 2023.

^ Ciarcia (1981), pp. 31, 32.

^ a b Chen, Wai-Kai (2002). The circuits and filters handbook. CRC Press. p. 1943. ISBN 978-0-8493-0912-0. interrupt processing commences according to the interrupt method stipulated by the IM i, i = 0, 1, or 2, instruction. If i = 1, for direct method, the PC is loaded with 0038H. If i = 0, for vectored method, the interrupting device has the opportunity to place the op-code for one byte. If i = 2, for indirect vector method, the interrupting device must then place a byte. The Z80 then uses this byte where one of 128 interrupt vectors can be selected by the byte.

^ Mathur (1989). Introduction to Microprocessors. Tata McGraw-Hill Publishing Company. p. 111. ISBN 978-0-07-460222-5. The register architecture of the Z80 is more innovative than that of the 8085

^ Brewer, Tony. "Z80 Special Reset". GitHub. Archived from the original on April 27, 2024. Retrieved April 27, 2024.

^ Adrian, Andre (June 4, 2011). "Z80, the 8-bit Number Cruncher". Archived from the original on November 26, 2023.

^ a b Balch, Mark (June 18, 2003). "Digital Fundamentals". Complete Digital Design: A Comprehensive Guide to Digital Electronics and Computer System Architecture. Professional Engineering. New York, New York: McGraw-Hill Professional. p. 122. ISBN 0-07-140927-0.

^ The Seybold report on professional computing. Seybold Publications. 1983. In the 8-bit world, the two most popular microcomputers are the Z80 and 6502 computer chips.

^ Adrian, Andre (June 4, 2011). "Z80, the 8-bit Number Cruncher: Z80 32-bit (long) add". Archived from the original on November 26, 2023.

^ Popular Computing. McGraw-Hill. 1983. p. 15.

^ Markoff, John (October 18, 1982). "Zilog's speedy Z80 soups up 8-bit to 16-bit performance". InfoWorld. Vol. 4, no. 41. Palo Alto, CA: Popular Computing, Inc. p. 1. ISSN 0199-6649. Archived from the original on January 5, 2024.

^ Electronic design. Hayden. 1988. p. 142. In addition to supporting the entire Z80 instruction set, the Z180

^ Ganssle, Jack G. (1992). "The Z80 Lives!". Archived from the original on December 20, 2023. The designers picked an architecture compatible with the Z80, giving Z80 users a completely software compatible upgrade path. The 64180 processor runs every Z80 instruction exactly as a Z80 does

^ Shiriff, Ken. "Down to the silicon: how the Z80's registers are implemented". Archived from the original on November 5, 2023.

^ Kilobaud. 1001001. 1977. p. 22.

^ Zaks, Rodnay (1982). Programming the Z80 (3rd ed.). SYBEX. p. 62. ISBN 978-0-89588-069-7.

^ a b Heath, Steve (2003). Embedded systems design. Oxford: Newnes. p. 21. ISBN 978-0-7506-5546-0.

^ Rison, Mark. Young, Sean (ed.). "Z80 Flag Affection". z80.info. Thomas Scherrer. Archived from the original on December 23, 2023. Retrieved June 14, 2016.

^ Shirriff, Ken. "The Z-80 has a 4-bit ALU. Here's how it works". Archived from the original on September 9, 2013. Retrieved November 16, 2021.

^ a b Durda IV, Frank (2012). "8080/Z80 Instruction Set". Archived from the original on February 11, 2016. Retrieved July 22, 2009.

^ "8080A/ 8-Bit N-Channel Microprocessor". Intel Component Data Catalog 1978. Santa Clara, CA: Intel Corporation. 1978. pp. 11–17. All mnemonics copyright Intel Corporation 1977

^ "Z80 Relocating Macro Assembler User's Guide" (PDF). p. B–2. Archived from the original (PDF) on July 20, 2011. Retrieved June 4, 2009.

^ Scanlon, Leo J. (1988). 8086/8088/80286 assembly language. Brady Books. p. 12. ISBN 978-0-13-246919-7. [...] The 8086 is software-compatible with the 8080 at the assembly-language level. [...]

^ Nelson, Ross P. (January 1989) [1988]. The 80386 Book: Assembly Language Programmer's Guide for the 80386. Microsoft Programming Series (1 ed.). Microsoft Press. p. 2. ISBN 978-1-55615-138-5. [...] An Intel translator program could convert 8080 assembler programs into 8086 assembler programs [...]

^ a b "Z80 CPU Introduction". Zilog. 1995. Archived from the original on December 20, 2023. It has a language of 252 root instructions and with the reserved 4 bytes as prefixes, accesses an additional 308 instructions.

^ "Z80-CPU Instruction Set" (PDF). Zilog. 1976. p. 19. Archived from the original on November 5, 2023. Retrieved July 20, 2021.

^ Sanchez, Julio; Canton, Maria P. (2008). Software Solutions for Engineers And Scientists. Taylor & Francis. p. 65. ISBN 978-1-4200-4302-0. The 8-bit microprocessors that preceded the 80x86 family (such as the Intel 8080, the Zilog Z80, and the Motorola) did not include multiplication.

^ Ciarcia (1981), p. 86.

^ HAYES, JOHN P. (1978). Computer Architecture and Organization. p. 423. ISBN 0-07-027363-4.

^ Froehlich, Robert A. (1984). The free software catalog and directory. Crown Publishers. p. 133. ISBN 978-0-517-55448-7. Undocumented Z80 codes allow 8 bit operations with IX and IY registers.

^ a b Bot, Jacco J. T. "Z80 Undocumented Instructions". Home of the Z80 CPU. Archived from the original on December 23, 2023. If an opcode works with the registers HL, H or L then if that opcode is preceded by #DD (or #FD) it works on IX, IXH or IXL (or IY, IYH, IYL), with some exceptions. The exceptions are instructions like LD H,IXH and LD L,IYH.

^ Robin Nixon The Amstrad Notepad Advanced User Guide, Robin Nixon, 1993, ISBN 1-85058-515-6, pages 219–223.

^ a b Young, Sean (October 1998). "Z80 Undocumented Features (in software behaviour)". Archived from the original on December 25, 2023. The I/O instructions use the whole of the address bus, not just the lower 8 bits. So in fact, you can have 65536 I/O ports in a Z80 system (the Spectrum uses this). IN r,(C), OUT (C),r and all the I/O block instructions put the whole of BC on the address bus. IN A,(n) and OUT (n),A put A*256+n on the address bus.

^ "Timing". Z80 Family CPU User Manual (PDF). Zilog. 2016. p. 7. UM008011-0816. Archived (PDF) from the original on December 26, 2023. Retrieved January 5, 2024.

^ Ciarcia (1981), p. 65.

^ Zaks, Rodnay (1989). Programming the Z80. Sybex. p. 200. ISBN 978-0-89588-069-7. ADD A, n Add accumulator with immediate data n. MEMORY Timing: 2 M cycles; 7 T states.

^ Ciarcia (1981), p. 63.

^ Ciarcia (1981), p. 77.

^ Ciarcia (1981), p. 36.

^ Ciarcia (1981), p. 58.

^ "Special-Purpose Registers". Z80 Family CPU User Manual (PDF). Zilog. 2016. p. 3. UM008011-0816. Archived (PDF) from the original on December 26, 2023. Retrieved January 5, 2024.

^ "Z80 Family CPU Peripherals User Manual" (PDF). EEWORLD Datasheet. ZiLOG. 2001. Archived from the original (PDF) on May 2, 2014. Retrieved April 30, 2014.

^ "Sharp 1986 Semiconductor Data Book" (PDF). p. 218. Archived (PDF) from the original on January 1, 2024. Retrieved January 1, 2024.

^ "Overview of the SHARP MZ-series". SharpMZ.org. Archived from the original on March 27, 2008. Retrieved July 28, 2011. Most MZ's use the 8bit CPU LH0080 / Z80 [...]

^ "LH0080/LH0080A/LH0080B". 1986 Semiconductor Data Book (PDF). Sharp Corporation. 1986. p. 210. Archived (PDF) from the original on January 1, 2024. Retrieved January 1, 2024.

^ "Sharp 1986 Semiconductor Data Book" (PDF). pp. 255–269. Archived (PDF) from the original on January 20, 2024. Retrieved January 13, 2024.

^ "Sharp 1986 Semiconductor Data Book" (PDF). pp. 296–301. Archived (PDF) from the original on January 20, 2024. Retrieved January 20, 2024.

^ "Sharp 1986 Semiconductor Data Book" (PDF). pp. 302–306. Archived (PDF) from the original on January 28, 2024. Retrieved January 28, 2024.

^ "Sharp 1986 Semiconductor Data Book" (PDF). pp. 307–311. Archived (PDF) from the original on January 28, 2024. Retrieved January 28, 2024.

^ Ganssle, Jack G. (1992). "The Z80 Lives!". Archived from the original on May 1, 2009. Retrieved July 17, 2009. The 64180 is a Hitachi-supplied Z80 core with numerous on-chip "extras". Zilog's version is the Z180, which is essentially the same part.

^ Ganssle, Jack G. (1992). "The Z80 Lives!". Archived from the original on May 1, 2009. Retrieved July 17, 2009. Both Toshiba and Zilog sell the 84013 and 84015, which are Z80 cores with conventional Z80 peripherals integrated on-board.

^ Granville, Fran (August 1, 1996). "EDN Access — 08.01.96 Z80 turns 20". EDN. Archived from the original on August 7, 2023. Retrieved August 7, 2023.

^ "EZ80 ACCLAIM Product Family". Zilog. Archived from the original on December 20, 2008.

^ Electronic Business Asia. Cahners Asia Limited. 1997. p. 5. Kawasaki's KL5C80A12, KL5C80A16 and KL5C8400 are high speed 8-bit MCUs and CPU. Their CPU code, KC80 is compatible with Zilog's Z80 at binary level. KC80 executes instructions about four times faster than Z80 at the same clock rate

^ "Hardware specs". S1mp3.org. October 19, 2005. Archived from the original on December 8, 2005.

^ "Overview :: T80 cpu :: OpenCores". opencores.org. Archived from the original on April 1, 2024. Retrieved July 1, 2024.

^ Rada, Col (March 1981). "NSC800 — a low-power high-performance microprocessor family". Electronics and Power. 27 (3). Institution of Engineering and Technology: 222. doi:10.1049/ep.1981.0107. Archived from the original on October 16, 2021. Retrieved June 1, 2021.

^ "TST-4043: Data encryptor with HF-modem and FEC". Crypto Museum. February 27, 2018. Archived from the original on November 5, 2023.

^ "NSC800 High-Performance Low-Power CMOS Microprocessor" (PDF). National Semiconductor. June 1992. Archived (PDF) from the original on November 19, 2023.

^ "MCS-85, Zilog Z80 and National NSC800 Expansion Boards". CPU Shack. February 15, 2015. Archived from the original on September 30, 2023.

^ "Section 6 MOS MPU, MCU, and Peripherals Market Trends" (PDF). Integrated Circuit Engineering Corporation. p. 16. Archived from the original (PDF) on June 14, 2011.

^ Axelson, Jan (2003). Embedded Ethernet and Internet Complete. Lakeview research. p. 93. ISBN 978-1-931448-00-0. Rabbit Semiconductor's Rabbit 3000 microprocessor, which is a much improved and enhanced derivative of ZiLOG, Inc.'s venerable Z80 microprocessor.

^ Hyder, Kamal; Perrin, Bob (2004). Embedded systems design using the Rabbit 3000 microprocessor. Newnes. p. 32. ISBN 978-0-7506-7872-8. The Rabbit parts are based closely on the Zilog Z180 architecture, although they are not binary compatible with the Zilog parts.

^ Cruz, Eduardo (November 23, 2014). "Capcom Kabuki CPU – Intro". Arcade Hacker. Archived from the original on November 5, 2023.

^ Holtz, Herman (1985). Computer work stations. Chapman and Hall. p. 223. ISBN 978-0-412-00491-9. and CP/M continued to dominate the 8-bit world of microcomputers.

^ Dvorak, John C. (May 10, 1982). "After CP/M, object oriented operating systems may lead the field". InfoWorld. Vol. 4, no. 18. InfoWorld Media Group. p. 20. ISSN 0199-6649. Archived from the original on January 6, 2024. The idea of a generic operating system is still in its infancy. In many ways it begins with CP/M and the mishmash of early 8080 and Z80 computers.

^ Stengel, Steven. "Otrona Attache". Steve's Old Computer Museum. Archived from the original on December 27, 2023. Retrieved March 5, 2019.

^ "Sharp PC-1500 Technical Reference Manual" (PDF). Archived (PDF) from the original on November 5, 2023.

^ "Poor Man's Laptop". Google Books. Popular Mechanics, April 1991, page 120. April 1991. Retrieved April 11, 2018.

^ "Laser PC4". Old Computer Museum. Archived from the original on November 5, 2023. Retrieved April 11, 2018.

^ "Laser PC5 from VTech". larwe.com. Archived from the original on November 5, 2023. Retrieved April 11, 2018.

^ "Laser PC6". Perfect Solutions dot com. Perfect Solutions. Archived from the original on May 21, 2018. Retrieved April 11, 2018.

^ "Mailstation Development". Fybertech.net. Archived from the original on January 6, 2024. Retrieved April 18, 2021.

^ Woerner, Joerg. "Texas Instruments PS-6200". Datamath Calculator Museum. Archived from the original on November 5, 2023. Retrieved June 18, 2019.

^ Woerner, Joerg. "Texas Instruments PocketMate 100". Datamath Calculator Museum. Archived from the original on November 5, 2023. Retrieved June 18, 2019.

^ Ian R. Sinclair (2000). Practical electronics handbook (5 ed.). Oxford, Angleterre: Newnes. p. 204. ISBN 978-0-7506-4585-0. LCCN 00502236. OCLC 42701044.

^ "Gordon Reid's Vintage Synths – the Sequential Circuits Prophet 5 and Prophet 10". gordonreid.co.uk. 1999. Archived from the original on November 5, 2023.

^ Fabio, Adam (March 19, 2014). "Prophet 600: A Classic Synthesizer Gets Processor Upgrade". Archived from the original on November 5, 2023.

^ Keeble, Rob (September 2002). "30 Years of Emu". Sound On Sound. SOS Publications Group. Retrieved January 10, 2025.

^ "Making a demo for an old phone — AONDEMO". habr.com. January 29, 2020. Archived from the original on November 5, 2023.


Sources

Anderson, A. John (1994). Foundations of computer technology (1st ed.). London: Chapman & Hall. ISBN 0-412-59810-8.
Ciarcia, Steve (1981). Build Your Own Z80 Computer – Design Guidelines and Application Notes (1st ed.). Byte Books. ISBN 978-0-07-010962-9.
Faggin, Federico; Peuto, Bernard; Shima, Masatoshi; Ungermann, Ralph (April 27, 2007). "Oral History Panel on the Development and Promotion of the Zilog Z8000 Microprocessor" (PDF) (Interview).
Further reading[edit]
Datasheets and manuals
Z80 Datasheet (NMOS); Zilog; 10 pages; 1978.
Z80 Data Book (NMOS); Zilog; 131 pages; 1978.
Z80 Datasheet (NMOS and CMOS); Zilog; 36 pages; 2002. Errata
Z80 User Manual (NMOS and CMOS); Zilog; 332 pages; 2016.
Z80 Peripheral User Manual (NMOS and CMOS); Zilog; 330 pages; 2001.
Hardware books
Build Your Own Z80 Computer – Design Guidelines and Application Notes; 1st Ed; Steve Ciarcia; Byte Books; 332 pages; 1981; ISBN 978-0070109629. (archive)
Z80 Microprocessor – Architecture, Interfacing, Programming, and Design; 1st Ed; Ramesh Gaonkar; Macmillan; 674 pages; 1988; ISBN 978-0675205405. (archive)
Z80 Users Manual – Pin Definitions, Control Signals, Peripherals, and More; 1st Ed; Joseph Carr; Reston; 338 pages; 1980; ISBN 978-0835995177. (archive)
Microprocessor Interfacing Techniques; 3rd Ed; Rodnay Zaks and Austin Lesea; Sybex; 466 pages; 1979; ISBN 978-0-89588-029-1. (archive)
Software books
Programming the Z80; 3rd Ed; Rodnay Zaks; Sybex; 630 pages; 1980; ISBN 978-0895880949. (archive)
Z80 Assembly Language Programming; 1st Ed; Lance Leventhal; Osborne/McGraw-Hill; 642 pages; 1979; ISBN 978-0931988219. (archive)
8080/Z80 Assembly Language – Techniques for Improved Programming; 1st Ed; Alan Miller; John Wiley & Sons; 332 pages; 1981; ISBN 978-0471081241. (archive)
Z80 and 8080 Assembly Language Programming; 1st Ed; Kathe Spracklen; Hayden; 180 pages; 1979; ISBN 978-0810451674. (archive)
Practical Microcomputer Programming – The Z80 – including Source for Resident Assembler and Debug Monitor; 1st Ed; Walter Weller; Northern Technology; 501 pages; 1978; ISBN 978-0930594053. (archive)
Z80 Assembly Language Subroutines; 1st Ed; Lance Leventhal and Winthrop Saville; Osborne/McGraw-Hill; 512 pages; 1983; ISBN 978-0931988912. (archive)
Undocumented Z80 Documented; Sean Young; v0.91; 52 pages; 2005. (archive)
Reference cards
Reference Card for the Z80 Microprocessor; Shirley & Nanos; Nanos Systems; 16 pages; 1981. (archive)
Z80 Microprocessor Instant Reference Card; James Lewis; Micro Logic; 2 pages; 1981. (archive)
External links[edit]



Wikibooks has a book on the topic of: Z80 Assembly




Wikimedia Commons has media related to Zilog Z80.

Z80 unofficial support page
Z80 technical literature
Z80 test collection
Z80 Cheat Sheet
List of Z80 compatible chips

Shirriff, Ken (September 2013). "Reverse-engineering the Z-80: the silicon for two interesting gates explained". Archived from the original on November 28, 2023. Retrieved November 26, 2023.
— (September 2013). "The Z-80 has a 4-bit ALU. Here's how it works". Archived from the original on September 9, 2013. Retrieved November 16, 2021.
— (October 2014). "Down to the silicon: how the Z80's registers are implemented". Archived from the original on October 6, 2014. Retrieved October 5, 2014.
— (November 2013). "The Z-80's 16-bit increment/decrement circuit reverse engineered". Archived from the original on January 15, 2024. Retrieved November 26, 2023.

Simulators / Emulators:

Z80 software emulators
Yet Another Z80 Emulator
Z80 Bus Emulator for education purpose
Visual Z80 Remix
Z80 emulation library written in ANSI C
Boards
Grant's 7-chip Z80 computer
Grant's 9-chip Z80 computer, supports CP/M 2.2 or BASIC
link3000 6-chip Z80 computer, supports CP/M 2.2
vteZilogProductsZ80 series
Z80
Z180
Z280
Z800
Z380
eZ80
Z8000 series
Z8000
Z80000
Microcontroller
Z8
Z8 Encore!
Z80182
Encore! 32
Operating systems
Z80-RIO
RelatedZ80 compatibles
ASCII R800
Hitachi HD64180, Zilog Z64180
NEC µPD780C
Sharp LH0080
Toshiba TLCS-870
Rabbit 2000
КР1858ВМ1
U880
MMN80CPU
People
Federico Faggin
Ralph Ungermann
Masatoshi Shima

vteMicrocontrollersMain
Single-board microcontroller
Special function register
Architectures
68000
8051
ARC
ARM
AVR
MIPS
MPS430
PIC
RISC-V
x86
Word length4-bit
Am2900
COP400
MARC4
PPS-4
S1C6x
TLCS-47
TMS1000
μCOM-4
8-bit
6800
68HC05
68HC08
68HC11
S08
RS08
6502
65C134
65C265
MELPS 740
78K
8048
8051
XC800
AVR
COP8
H8
PIC10/12/16/17/18
ST6/ST7
STM8
Z8
Z80
eZ80
Rabbit 2000
TLCS-870
16-bit
65C816
68HC12/16
80186
C166
CR16/C
H8S
MSP430
PIC24/dsPIC
R8C
RL78
TLCS-900
Z8000
32-bit
Am29000
ARC
ARM Cortex-M
EFM32
LPC
SAM
STM32
XMC
ARM Cortex-R
AVR32
CRX
FR
FR-V
H8SX
M32R
MN103
68000
ColdFire
PIC32
PowerPC
MPC5xx
Propeller
SuperH
TLCS-900
TriCore
V850
RX
Xtensa
Z80000
64-bit
ARC
ARM Cortex-R
PowerPC64
InterfacesProgramming
In-circuit serial programming (ICSP)
In-system programming (ISP)
Program and Debug Interface (PDI)
High-voltage serial programming (HVSP)
High voltage parallel programming (HVPP)
Bootloader
ROM
aWire
Debugging
Nexus (standard)
Joint Test Action Group (JTAG)
debugWIRE (Atmel)
In-circuit debugging (ICD)
In-circuit emulator (ICE)
In-target probe (ITP)
Lists
List of common microcontrollers
By manufacturer
Intel
NXP/Freescale
Infineon
Renesas Electronics
List of Wi-Fi microcontrollers
See also
Embedded system
Programmable logic controller
List of microprocessors

Authority control databases: National GermanyUnited StatesFranceBnF dataIsrael




Retrieved from "https://en.wikipedia.org/w/index.php?title=Zilog_Z80&oldid=1287122643"
Categories: Computer-related introductions in 1976Zilog microprocessorsZ80Sharp Corporation products8-bit microprocessorsHidden categories: Articles with short descriptionShort description matches WikidataUse mdy dates from May 2024Articles containing potentially dated statements from 2025All articles containing potentially dated statementsArticles needing additional references from February 2025All articles needing additional referencesAll articles with unsourced statementsArticles with unsourced statements from February 2012Articles with unsourced statements from July 2011Articles with unsourced statements from December 2012Articles with unsourced statements from November 2012Articles with specifically marked weasel-worded phrases from December 2010Articles with unsourced statements from May 2013Commons category link is on Wikidata






 This page was last edited on 24 April 2025, at 04:07 (UTC).
Text is available under the Creative Commons Attribution-ShareAlike 4.0 License;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.


Privacy policy
About Wikipedia
Disclaimers
Contact Wikipedia
Code of Conduct
Developers
Statistics
Cookie statement
Mobile view














Search













Search









Toggle the table of contents







Zilog Z80




























38 languages


Add topic
















