https://en.wikipedia.org/wiki/Hardware_description_language




Hardware description language - Wikipedia



























Jump to content







Main menu





Main menu
move to sidebar
hide



		Navigation
	


Main pageContentsCurrent eventsRandom articleAbout WikipediaContact us





		Contribute
	


HelpLearn to editCommunity portalRecent changesUpload fileSpecial pages



















Search











Search






















Appearance
















Donate

Create account

Log in








Personal tools





Donate Create account Log in





		Pages for logged out editors learn more



ContributionsTalk




























Contents
move to sidebar
hide




(Top)





1
Motivation








2
Structure of HDL




Toggle Structure of HDL subsection





2.1
Comparison with control-flow languages










3
History








4
Design using HDL








5
Simulating and debugging HDL code








6
Design verification with HDLs








7
HDL and programming languages








8
High-level synthesis








9
Examples of HDLs




Toggle Examples of HDLs subsection





9.1
HDLs for analog circuit design








9.2
HDLs for digital circuit design








9.3
HDLs for printed circuit board design










10
See also








11
References








12
External links


















Toggle the table of contents







Hardware description language



27 languages




العربيةবাংলাCatalàDeutschEestiΕλληνικάEspañolفارسیFrançais한국어हिन्दीÍslenskaItalianoעבריתBahasa MelayuNederlands日本語PolskiPortuguêsРусскийСрпски / srpskiSuomiSvenskaTürkçeУкраїнськаTiếng Việt中文

Edit links











ArticleTalk





English

















ReadEditView history







Tools





Tools
move to sidebar
hide



		Actions
	


ReadEditView history





		General
	


What links hereRelated changesUpload filePermanent linkPage informationCite this pageGet shortened URLDownload QR code





		Print/export
	


Download as PDFPrintable version





		In other projects
	


Wikimedia CommonsWikidata item





















Appearance
move to sidebar
hide










From Wikipedia, the free encyclopedia


Specialized computer language used to describe electronic circuits
This article has multiple issues. Please help improve it or discuss these issues on the talk page. (Learn how and when to remove these messages)

This article needs additional citations for verification. Please help improve this article by adding citations to reliable sources. Unsourced material may be challenged and removed.Find sources: "Hardware description language" – news · newspapers · books · scholar · JSTOR (January 2013) (Learn how and when to remove this message)
This article may be too technical for most readers to understand. Please help improve it to make it understandable to non-experts, without removing the technical details. (April 2014) (Learn how and when to remove this message)

 (Learn how and when to remove this message)
In computer engineering, a hardware description language (HDL) is a specialized computer language used to describe the structure and behavior of electronic circuits, usually to design application-specific integrated circuits (ASICs) and to program field-programmable gate arrays (FPGAs).
A hardware description language enables a precise, formal description of an electronic circuit that allows for the automated analysis and simulation of the circuit. It also allows for the synthesis of an HDL description into a netlist (a specification of physical electronic components and how they are connected together), which can then be placed and routed to produce the set of masks used to create an integrated circuit.
A hardware description language looks much like a programming language such as C or ALGOL; it is a textual description consisting of expressions, statements and control structures. One important difference between most programming languages and HDLs is that HDLs explicitly include the notion of time.
HDLs form an integral part of electronic design automation (EDA) systems, especially for complex circuits, such as application-specific integrated circuits, microprocessors, and programmable logic devices.


Motivation[edit]
Due to the exploding complexity of digital electronic circuits since the 1970s (see Moore's law), circuit designers needed digital logic descriptions to be performed at a high level without being tied to a specific electronic technology, such as ECL, TTL or CMOS. HDLs were created to implement register-transfer level abstraction, a model of the data flow and timing of a circuit.[1]
There are two major hardware description languages: VHDL and Verilog. There are different types of description in them: "dataflow, behavioral and structural".
Example of dataflow of VHDL:

LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;

ENTITY not1 IS
    PORT(
        a : IN  STD_LOGIC;
        b : OUT STD_LOGIC
    );
END not1;

ARCHITECTURE behavioral OF not1 IS
BEGIN
    b <= NOT a;
END behavioral;

Structure of HDL[edit]
HDLs are standard text-based expressions of the structure of electronic systems and their behaviour over time. Like concurrent programming languages, HDL syntax and semantics include explicit notations for expressing concurrency. However, in contrast to most software programming languages, HDLs also include an explicit notion of time, which is a primary attribute of hardware. Languages whose only characteristic is to express circuit connectivity between a hierarchy of blocks are properly classified as netlist languages used in electric computer-aided design. HDL can be used to express designs in structural, behavioral or register-transfer-level architectures for the same circuit functionality; in the latter two cases the synthesizer decides the architecture and logic gate layout.
HDLs are used to write executable specifications for hardware. A program designed to implement the underlying semantics of the language statements and simulate the progress of time provides the hardware designer with the ability to model a piece of hardware before it is created physically. It is this executability that gives HDLs the illusion of being programming languages, when they are more precisely classified as specification languages or modeling languages. Simulators capable of supporting discrete-event (digital) and continuous-time (analog) modeling exist, and HDLs targeted for each are available.

Comparison with control-flow languages[edit]
It is certainly possible to represent hardware semantics using traditional programming languages such as C++, which operate on control flow semantics as opposed to data flow, although to function as such, programs must be augmented with extensive and unwieldy class libraries. Generally, however, software programming languages do not include any capability for explicitly expressing time, and thus cannot function as hardware description languages. Before the introduction of System Verilog in 2002, C++ integration with a logic simulator was one of the few ways to use object-oriented programming in hardware verification. System Verilog is the first major HDL to offer object orientation and garbage collection.
Using the proper subset of hardware description language, a program called a synthesizer, or logic synthesis tool, can infer hardware logic operations from the language statements and produce an equivalent netlist of generic hardware primitives[jargon] to implement the specified behaviour.[citation needed] Synthesizers generally ignore the expression of any timing constructs in the text. Digital logic synthesizers, for example, generally use clock edges as the way to time the circuit, ignoring any timing constructs. The ability to have a synthesizable subset of the language does not itself make a hardware description language.

History[edit]
The first hardware description languages appeared in the late 1960s, looking like more traditional languages.[2] The first that had a lasting effect was described in 1971 in C. Gordon Bell and Allen Newell's text Computer Structures.[3] This text introduced the concept of register transfer level, first used in the ISP language to describe the behavior of the Digital Equipment Corporation (DEC) PDP-8.[4]
The language became more widespread with the introduction of DEC's PDP-16 RT-Level Modules (RTMs) and a book describing their use.[5]
At least two implementations of the basic ISP language (ISPL and ISPS) followed.[6][7]
ISPS was well suited to describe relations between the inputs and the outputs of the design and was quickly adopted by commercial teams at DEC, and by several research teams in the US and among its allies in the North Atlantic Treaty Organization (NATO).
The RTM products never succeeded commercially and DEC stopped marketing them in the mid-1980s, as new methods grew more popular, more so very-large-scale integration (VLSI).
Separate work done about 1979 at the University of Kaiserslautern produced a language called KARL ("KAiserslautern Register Transfer Language"), which included design calculus language features supporting VLSI chip floorplanning[jargon] and structured hardware design. This work was also the basis of KARL's interactive graphic sister language ABL, whose name was an initialism for "A Block diagram Language".[8] ABL was implemented in the early 1980s by the Centro Studi e Laboratori Telecomunicazioni (CSELT) in Torino, Italy, producing the ABLED graphic VLSI design editor. In the mid-1980s, a VLSI design framework was implemented around KARL and ABL by an international consortium funded by the Commission of the European Union.[9]
By the late 1970s, design using programmable logic devices (PLDs) became popular, although these designs were primarily limited to designing finite-state machines. The work at Data General in 1980 used these same devices to design the Data General Eclipse MV/8000, and commercial need began to grow for a language that could map well to them. By 1983 Data I/O introduced ABEL to fill that need.
In 1985, as design shifted to VLSI, Gateway Design Automation introduced Verilog, and Intermetrics released the first completed version of the VHSIC Hardware Description Language (VHDL). VHDL was developed at the behest of the United States Department of Defense's Very High Speed Integrated Circuit Program (VHSIC), and was based on the Ada programming language, and on the experience gained with the earlier development of ISPS.[10] Initially, Verilog and VHDL were used to document and simulate circuit designs already captured and described in another form (such as schematic files). HDL simulation enabled engineers to work at a higher level of abstraction than simulation at the schematic level, and thus increased design capacity from hundreds of transistors to thousands.[citation needed] In 1986, with the support of the U.S Department of Defense, VHDL was sponsored as an IEEE standard (IEEE Std 1076), and the first IEEE-standardized version of VHDL, IEEE Std 1076-1987, was approved in December 1987. Cadence Design Systems later acquired Gateway Design Automation for the rights to Verilog-XL, the HDL simulator that would become the de facto standard of Verilog simulators for the next decade.
The introduction of logic synthesis for HDLs pushed HDLs from the background into the foreground of digital design. Synthesis tools compiled HDL source files (written in a constrained format called RTL) into a manufacturable netlist description in terms of gates and transistors. Writing synthesizable RTL files required practice and discipline on the part of the designer; compared to a traditional schematic layout, synthesized RTL netlists were almost always larger in area and slower in performance[citation needed]. A circuit design from a skilled engineer, using labor-intensive schematic-capture/hand-layout, would almost always outperform its logically-synthesized equivalent, but the productivity advantage held by synthesis soon displaced digital schematic capture to exactly those areas that were problematic for RTL synthesis: extremely high-speed, low-power, or asynchronous circuitry.
Within a few years, VHDL and Verilog emerged as the dominant HDLs in the electronics industry, while older and less capable HDLs gradually disappeared from use. However, VHDL and Verilog share many of the same limitations, such as being unsuitable for analog or mixed-signal circuit simulation. Specialized HDLs (such as Confluence) were introduced with the explicit goal of fixing specific limitations of Verilog and VHDL, though none were ever intended to replace them.
Over the years, much effort has been invested in improving HDLs. The latest iteration of Verilog, formally known as IEEE 1800-2005 SystemVerilog, introduces many new features (classes, random variables, and properties/assertions) to address the growing need for better test bench randomization, design hierarchy, and reuse. A future revision of VHDL is also in development[when?], and is expected to match SystemVerilog's improvements.

Design using HDL[edit]
As a result of the efficiency gains realized using HDL, a majority of modern digital circuit design revolves around it. Most designs begin as a set of requirements or a high-level architectural diagram. Control and decision structures are often prototyped in flowchart applications, or entered in a editor. The process of writing the HDL description is highly dependent on the nature of the circuit and the designer's preference for coding style. The HDL is merely the 'capture language', often beginning with a high-level algorithmic description such as a C++ mathematical model. Designers often use scripting languages such as Perl to automatically generate repetitive circuit structures in the HDL language. Special text editors offer features for automatic indentation, syntax-dependent coloration, and macro-based expansion of the entity/architecture/signal declaration.
The HDL code then undergoes a code review, or auditing. In preparation for synthesis, the HDL description is subject to an array of automated checkers. The checkers report deviations from standardized code guidelines, identify potential ambiguous code constructs before they can cause misinterpretation, and check for common logical coding errors, such as floating ports or shorted outputs. This process aids in resolving errors before the code is synthesized.
In industry parlance, HDL design generally ends at the synthesis stage. Once the synthesis tool has mapped the HDL description into a gate netlist, the netlist is passed off to the back-end stage. Depending on the physical technology (FPGA, ASIC gate array, ASIC standard cell), HDLs may or may not play a significant role in the back-end flow. In general, as the design flow progresses toward a physically realizable form, the design database becomes progressively more laden with technology-specific information, which cannot be stored in a generic HDL description. Finally, an integrated circuit is manufactured or programmed for use.

Simulating and debugging HDL code[edit]
Main article: Logic simulation
Essential to HDL design is the ability to simulate HDL programs. Simulation allows an HDL description of a design (called a model) to pass design verification, an important milestone that validates the design's intended function (specification) against the code implementation in the HDL description. It also permits architectural exploration. The engineer can experiment with design choices by writing multiple variations of a base design, then comparing their behavior in simulation. Thus, simulation is critical for successful HDL design.
To simulate an HDL model, an engineer writes a top-level simulation environment (called a test bench). At minimum, a testbench contains an instantiation of the model (called the device under test or DUT), pin/signal declarations for the model's I/O, and a clock waveform. The testbench code is event driven: the engineer writes HDL statements to implement the (testbench-generated) reset-signal, to model interface transactions (such as a host–bus read/write), and to monitor the DUT's output. An HDL simulator — the program that executes the testbench — maintains the simulator clock, which is the master reference for all events in the testbench simulation. Events occur only at the instants dictated by the testbench HDL (such as a reset-toggle coded into the testbench), or in reaction (by the model) to stimulus and triggering events. Modern HDL simulators have full-featured graphical user interfaces, complete with a suite of debug tools. These allow the user to stop and restart the simulation at any time, insert simulator breakpoints (independent of the HDL code), and monitor or modify any element in the HDL model hierarchy. Modern simulators can also link the HDL environment to user-compiled libraries, through a defined PLI/VHPI interface. Linking is system-dependent (x86, SPARC etc. running Windows/Linux/Solaris), as the HDL simulator and user libraries are compiled and linked outside the HDL environment.
Design verification is often the most time-consuming portion of the design process, due to the disconnect between a device's functional specification, the designer's interpretation of the specification, and the imprecision[citation needed] of the HDL language. The majority of the initial test/debug cycle is conducted in the HDL simulator environment, as the early stage of the design is subject to frequent and major circuit changes. An HDL description can also be prototyped and tested in hardware — programmable logic devices are often used for this purpose. Hardware prototyping is comparatively more expensive than HDL simulation, but offers a real-world view of the design. Prototyping is the best way to check interfacing against other hardware devices and hardware prototypes. Even those running on slow FPGAs offer much shorter simulation times than pure HDL simulation.

Design verification with HDLs[edit]
Main article: Functional verification
Historically, design verification was a laborious, repetitive loop of writing and running simulation test cases against the design under test. As chip designs have grown larger and more complex, the task of design verification has grown to the point where it now dominates the schedule of a design team. Looking for ways to improve design productivity, the electronic design automation industry developed the Property Specification Language.
In formal verification terms, a property is a factual statement about the expected or assumed behavior of another object. Ideally, for a given HDL description, a property or properties can be proven true or false using formal mathematical methods. In practical terms, many properties cannot be proven because they occupy an unbounded solution space. However, if provided a set of operating assumptions or constraints, a property checker can prove (or disprove) certain properties by narrowing the solution space.
The assertions do not model circuit activity, but capture and document the designer's intent in the HDL code. In a simulation environment, the simulator evaluates all specified assertions, reporting the location and severity of any violations. In a synthesis environment, the synthesis tool usually operates with the policy of halting synthesis upon any violation. Assertion based verification is still in its infancy, but is expected to become an integral part of the HDL design toolset.

HDL and programming languages[edit]
An HDL is grossly similar to a software programming language, but there are major differences. Most programming languages are inherently procedural (single-threaded), with limited syntactical and semantic support to handle concurrency. HDLs, on the other hand, resemble concurrent programming languages in their ability to model multiple parallel processes (such as flip-flops and adders) that automatically execute independently of one another. Any change to the process's input automatically triggers an update in the simulator's process stack.
Both programming languages and HDLs are processed by a compiler (often called a synthesizer in the HDL case), but with different goals. For HDLs, "compiling" refers to logic synthesis; the process of transforming the HDL code listing into a physically realizable gate netlist. The netlist output can take any of many forms: a "simulation" netlist with gate-delay information, a "handoff" netlist for post-synthesis placement and routing on a semiconductor die, or a generic industry-standard Electronic Design Interchange Format (EDIF) (for subsequent conversion to a JEDEC-format file).
On the other hand, a software compiler converts the source-code listing into a microprocessor-specific object code for execution on the target microprocessor. As HDLs and programming languages borrow concepts and features from each other, the boundary between them is becoming less distinct. However, pure HDLs are unsuitable for general purpose application software development,[why?] just as general-purpose programming languages are undesirable for modeling hardware.
Yet as electronic systems grow increasingly complex, and reconfigurable systems become increasingly common, there is growing desire in the industry for a single language that can perform some tasks of both hardware design and software programming. SystemC is an example of such—embedded system hardware can be modeled as non-detailed architectural blocks (black boxes with modeled signal inputs and output drivers). The target application is written in C or C++ and natively compiled for the host-development system; as opposed to targeting the embedded CPU, which requires host-simulation of the embedded CPU or an emulated CPU.
The high level of abstraction of SystemC models is well suited to early architecture exploration, as architectural modifications can be easily evaluated with little concern for signal-level implementation issues. However, the threading model used in SystemC relies on shared memory, causing the language not to handle parallel execution or low-level models well.

High-level synthesis[edit]
Main article: High-level synthesis
In their level of abstraction, HDLs have been compared to assembly languages.[citation needed] There are attempts to raise the abstraction level of hardware design in order to reduce the complexity of programming in HDLs, creating a sub-field called high-level synthesis.
Companies such as Cadence, Synopsys and Agility Design Solutions are promoting SystemC as a way to combine high-level languages with concurrency models to allow faster design cycles for FPGAs than is possible using traditional HDLs. Approaches based on standard C or C++ (with libraries or other extensions allowing parallel programming) are found in the Catapult C tools from Mentor Graphics, and the Impulse C tools from Impulse Accelerated Technologies.
A similar initiative from Intel is the use of Data Parallel C++, related to SYCL, as a high-level synthesis language.
Annapolis Micro Systems, Inc.'s CoreFire Design Suite[11] and National Instruments LabVIEW FPGA provide a graphical dataflow approach to high-level design entry and languages such as SystemVerilog, SystemVHDL, and Handel-C seek to accomplish the same goal, but are aimed at making existing hardware engineers more productive, rather than making FPGAs more accessible to existing software engineers.
It is also possible to design hardware modules using MATLAB and Simulink using the MathWorks HDL Coder tool[12] or DSP Builder for Intel FPGAs[13] or Xilinx System Generator (XSG) from Xilinx.[14]

Examples of HDLs[edit]
HDLs for analog circuit design[edit]


Name

Description


HDL-A

A proprietary analog HDL


SpectreHDL

A proprietary analog HDL from Cadence Design Systems for its Spectre circuit simulator


Verilog-AMS (Verilog for Analog and Mixed-Signal)

An Accellera standard extension of IEEE Std 1364 Verilog for analog and mixed-signal simulation


VHDL-AMS (VHDL with Analog/Mixed-Signal extension)

An IEEE standard extension (IEEE Std 1076.1) of VHDL for analog and mixed-signal simulation

HDLs for digital circuit design[edit]
The two most widely used and well-supported HDL varieties used in industry are Verilog and VHDL.



Status

Name

Host language

Description


In use

Altera Hardware Description Language (AHDL)



Proprietary language from Altera


A Hardware Programming language (AHPL)



Used as a tool for teaching


Amaranth

Python




Bluespec



High-level HDL based on Haskell (not embedded DSL)[15]


Bluespec SystemVerilog (BSV)



Based on Bluespec, with Verilog HDL like syntax, by Bluespec, Inc.


C-to-Verilog



Converter from C to Verilog


Chisel (Constructing Hardware in a Scala Embedded Language)[16]

Scala

Based on Scala (embedded DSL)


Clash



Functional hardware description language that borrows its syntax and semantics from the functional language Haskell


Common Oriented Language for Architecture of Multi Objects (COLAMO)[17][18]



Proprietary language from “Supercomputers and Neurocomputers Research Center” Co Ltd.


Compiler for Universal Programmable Logic (CUPL)[19]



Proprietary language from Logical Devices, Inc.


DSLX



Domain-specific language for XLS toolchain


ESys.net



.NET framework written in C#


Filament



HDL with a type system inspired by Rust


Handel-C



C-like design language


Hardcaml

OCaml

Based on OCaml (embedded DSL)[20]


HHDL

Haskell

Based on Haskell (embedded DSL)


Hardware Join Java (HJJ)

Join Java

Based on Join Java


Hardware ML (HML)

Standard ML

Based on Standard ML[21]


Hydra

Haskell

Based on Haskell


Impulse C



C-like HDL


Parallel C++ (ParC)



kusu extended with HDL style threading and communication for task-parallel programming


JHDL

Java

Based on Java


Lava

Haskell

Based on Haskell (embedded DSL)[22][23][24][25]


Lola



Simple language used for teaching


M



HDL from Mentor Graphics


Migen

Python




MyHDL

Python

Based on Python (embedded DSL)


PALASM



For Programmable Array Logic (PAL) devices


PipelineC



C-like hardware description language adding High-level synthesis-like automatic pipelining as a language construct and compiler feature.


PyMTL 3 (Mamba)

Python

Based on Python, from Cornell University


PyRTL

Python

Based on Python, from University of California, Santa Barbara


Riverside Optimizing Compiler for Configurable Computing (ROCCC)



Free and open-source C to HDL tool


RHDL

Ruby

Based on the Ruby programming language


Rapid Open Hardware Development (ROHD)[26]

Dart

Framework for hardware design and verification, written in Dart


Ruby (hardware description language)






Silice



HDL that simplifies designing hardware algorithms with parallelism and pipelines


Spade



HDL inspired by modern software languages like Rust


SystemC



Standardized class of C++ libraries for high-level behavioral and transaction modeling of digital hardware at a high level of abstraction, i.e., system-level


SystemVerilog



Superset of Verilog, with enhancements to address system-level design and verification


SpinalHDL

Scala

Based on Scala (embedded DSL)


SystemTCL



SDL based on Tcl


Templated HDL inspired by C++ (THDL++)



Extension of VHDL with inheritance, advanced templates and policy classes


Verik



Kotlin reinterpreted with the semantics of an HDL; transpiled to SystemVerilog


Transaction-Level Verilog (TL-Verilog)[27]



Extension of Verilog/SystemVerilog with constructs for pipelines and transactions.


Verilog



One of the most widely used and well-supported HDLs


Veryl



HDL designed as SystemVerilog alternative


VHDL (VHSIC HDL)



One of the most widely used and well-supported HDLs


No longer in common use

Advanced Boolean Expression Language (ABEL)



Obsolete HDL made by Data I/O Corporation in 1983


Confluence



Functional HDL, discontinued


CoWareC



C-based HDL by CoWare; discontinued in favor of SystemC


ELLA



No longer in common use


ISPS



Original HDL from CMU; no longer in common use


KAiserslautern Register Language (KARL)[9]



Pascal-like hardware description language; no longer in common use


nMigen

Python

Predecessor to Amaranth

HDLs for printed circuit board design[edit]
Several projects exist for defining printed circuit board connectivity using language based, textual-entry methods. Among these, new approaches have emerged that focus on enhancing readability, reusability, and validation. These modern methodologies employ open-source design languages specifically tailored for electronics, adopting declarative markup to specify what circuits should achieve. This shift integrates software development principles into hardware design, streamlining the process and emphasizing automation, reuse, and validation.



Name

Description


atopile

An open-source language and toolchain to describe electronic circuit boards with code.


PHDL (PCB HDL)

A free and open source HDL for defining printed circuit board connectivity.


EDAsolver

An HDL for solving schematic designs based on constraints.


SKiDL

Open source Python module to design electronic circuits.

See also[edit]

Bluespec
C to HDL
Flow to HDL
Gezel
Hardware verification language
Modeling language
Property Specification Language
Rosetta-lang
Specification language
SystemC
SystemVerilog
References[edit]


^ Ciletti, Michael D. (2011). Advanced Digital Design with Verilog HDL (2nd ed.). Prentice Hall. ISBN 9780136019282.

^ Barbacci, M. "A comparison of register transfer languages for describing computers and digital systems," Carnegie-Mellon Univ., Dept. of Computer Science, March 1973

^ Bell, C. G.; Newell, A. (1971). Computer Structures: Readings and Examples. McGraw-Hill. ISBN 0-07-004357-4.

^ Reilly, E.D. (2003). Milestones in computer science and information technology. Greenwood Press. p. 183. ISBN 1-57356-521-0.

^ Bell, C.G.; Grason, J.; Newell, A. (1972). Designing Computers and Digital Systems. Digital Press. LCCN 72-89566. OCLC 440245727.

^ Barbacci, M.C. (1976). The Symbolic Manipulation of Computer Descriptions: ISPL Compiler and Simulator (Report). Department of Computer Science, Carnegie-Mellon University. doi:10.1184/R1/6610790.v1.

^ Barbacci, M.C.; Barnes, G.E.; Cattell, R.G.G.; Siewiorek, D.P. (1977). The ISPS Computer Description Language (Report). Department of Computer Science, Carnegie-Mellon University. doi:10.1184/R1/6610637.v1.

^ Girardi, G.; Hartenstein, R. (1983). ABL specification (Report). CSELT and University of Kaiserslautern.

^ a b Hartenstein, Reiner W. (2012) [1993], "KARL and ABL", in Mermet, J. (ed.), Fundamentals and Standards in Hardware Description Languages, NATO Science Series E, vol. 249, Springer, pp. 447–, ISBN 9789401119146

^ Barbacci, M.C.; Grout, S.; Lindstrom, G.; Maloney, M.P. (1984). Ada as a hardware description language : an initial report (Report). Department of Computer Science, Carnegie-Mellon University. CiteSeerX 10.1.1.938.8003. doi:10.1184/R1/6602984.v1.

^ "VHDL-Based FPGA Programming Application Software Tool". Annapolis Micro Systems, Inc. Retrieved 2018-12-01.

^ "VHDL code - HDL Coder - MATLAB & Simulink". Mathworks.com. 2011-04-30. Retrieved 2012-08-11.

^ "Digital Signal Processing (DSP) Builder - Intel® FPGAs". Intel. Retrieved 2021-09-20.

^ "System Generator for DSP". Xilinx.com. Archived from the original on 2012-07-12. Retrieved 2012-08-11.

^ A History of Haskell: being lazy with class §12.4.2

^ "Chisel/FIRRTL Hardware Compiler Framework".

^ COLAMO

^ "Higher-level language COLAMO – НИЦ супер-ЭВМ и нейрокомпьютеров".

^ Eurich, J.P.; Roth, G. (1990). "EDIF grows up". IEEE Spectrum. 27 (11): 68–72. doi:10.1109/6.62219. S2CID 381119.

^ Hardcaml

^ Li, Yanbing; Leeser, M. (1995). "HML: An innovative hardware description language and its translation to VHDL". Proceedings of ASP-DAC'95/CHDL'95/VLSI'95 with EDA Technofair. pp. 691–696. doi:10.1109/ASPDAC.1995.486388. ISBN 4-930813-67-0. S2CID 14198160.

^ Chalmers Lava

^ Xilinx Lava

^ Kansas Lava

^ York Lava

^ "Rapid Open Hardware Development (ROHD) Framework". GitHub. 17 November 2021.

^ TL-Verilog


External links[edit]



Wikimedia Commons has media related to Hardware description languages.

HCT - The HDL Complexity tool, used to determine design complexity.
vteTypes of computer languageTypes
Architecture description
Data exchange
Hardware description
Knowledge representation
Markup
Modeling
Programming language
Query
Shading
Specification
Stylesheet
Transformation
See also
Category:Lists of computer languages
Category:Lists of programming languages
List of programming languages by type

vteProgrammable logicConcepts
ASIC
SoC
FPGA
Logic block
CPLD
EPLD
PLA
PAL
GAL
PSoC
Reconfigurable computing
Xputer
Soft microprocessor
Circuit underutilization
High-level synthesis
Hardware acceleration
Languages
Verilog
A
AMS
VHDL
AMS
VITAL
SystemVerilog
DPI
SystemC
AHDL
Handel-C
Lola
PSL
UPF
PALASM
ABEL
CUPL
C to HDL
Flow to HDL
MyHDL
ELLA
Chisel
Companies
Accellera
Achronix
AMD
Aldec
Arm
Cadence
Infineon
Intel
Lattice
Microchip Technology
NXP
Siemens
Synopsys
Texas Instruments
ProductsHardware
iCE
Stratix
Virtex
Software
Intel Quartus Prime
Xilinx ISE
Vivado
ModelSim
VTR
Simulators
IntellectualpropertyProprietary
ARC
ARM Cortex-M
LEON
LatticeMico8
MicroBlaze
PicoBlaze
Nios
Nios II
Open-source
JOP
LatticeMico32
OpenCores
OpenRISC
1200
Power ISA
Libre-SOC
Microwatt
RISC-V

vteDigital electronicsComponents
Transistor
Resistor
Inductor
Capacitor
Printed electronics
Printed circuit board
Electronic circuit
Flip-flop
Memory cell
Combinational logic
Sequential logic
Logic gate
Boolean circuit
Integrated circuit (IC)
Hybrid integrated circuit (HIC)
Mixed-signal integrated circuit
Three-dimensional integrated circuit (3D IC)
Emitter-coupled logic (ECL)
Erasable programmable logic device (EPLD)
Macrocell array
Programmable logic array (PLA)
Programmable logic device (PLD)
Programmable Array Logic (PAL)
Generic Array Logic (GAL)
Complex programmable logic device (CPLD)
Field-programmable gate array (FPGA)
Field-programmable object array (FPOA)
Application-specific integrated circuit (ASIC)
Tensor Processing Unit (TPU)
Theory
Digital signal
Boolean algebra
Logic synthesis
Logic in computer science
Computer architecture
Digital signal
Digital signal processing
Circuit minimization
Switching circuit theory
Gate equivalent
Design
Logic synthesis
Place and route
Placement
Routing
Transaction-level modeling
Register-transfer level
Hardware description language
High-level synthesis
Formal equivalence checking
Synchronous logic
Asynchronous logic
Finite-state machine
Hierarchical state machine
Applications
Computer hardware
Hardware acceleration
Digital audio
radio
Digital photography
Digital telephone
Digital video
cinematography
television
Electronic literature
Design issues
Metastability
Runt pulse

Authority control databases InternationalFASTNationalGermanyUnited StatesFranceBnF dataJapanSpainIsrael




Retrieved from "https://en.wikipedia.org/w/index.php?title=Hardware_description_language&oldid=1269959964"
Categories: Hardware description languagesTechnical communicationLogic designProgramming language classificationHidden categories: Articles with short descriptionShort description is different from WikidataArticles needing additional references from January 2013All articles needing additional referencesWikipedia articles that are too technical from April 2014All articles that are too technicalArticles with multiple maintenance issuesAll articles needing expert attentionArticles needing expert attention from April 2014All articles with unsourced statementsArticles with unsourced statements from July 2010All articles with vague or ambiguous timeVague or ambiguous time from April 2014Wikipedia articles needing clarification from December 2018Articles with unsourced statements from April 2014Commons category link from Wikidata






 This page was last edited on 17 January 2025, at 07:30 (UTC).
Text is available under the Creative Commons Attribution-ShareAlike 4.0 License;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.


Privacy policy
About Wikipedia
Disclaimers
Contact Wikipedia
Code of Conduct
Developers
Statistics
Cookie statement
Mobile view














Search













Search









Toggle the table of contents







Hardware description language




























27 languages


Add topic
















