https://en.wikipedia.org/wiki/Microsequencer




Microsequencer - Wikipedia


























Jump to content







Main menu





Main menu
move to sidebar
hide



		Navigation
	


Main pageContentsCurrent eventsRandom articleAbout WikipediaContact us





		Contribute
	


HelpLearn to editCommunity portalRecent changesUpload fileSpecial pages



















Search











Search






















Appearance
















Donate

Create account

Log in








Personal tools





Donate Create account Log in





		Pages for logged out editors learn more



ContributionsTalk




























Contents
move to sidebar
hide




(Top)





1
Simple example








2
Complex example




Toggle Complex example subsection





2.1
Functional branch format








2.2
CD = 0, 1, 3 format








2.3
CD = 2 format








2.4
Simplification










3
References


















Toggle the table of contents







Microsequencer



2 languages




العربية日本語

Edit links











ArticleTalk





English

















ReadEditView history







Tools





Tools
move to sidebar
hide



		Actions
	


ReadEditView history





		General
	


What links hereRelated changesUpload filePermanent linkPage informationCite this pageGet shortened URLDownload QR code





		Print/export
	


Download as PDFPrintable version





		In other projects
	


Wikidata item





















Appearance
move to sidebar
hide










From Wikipedia, the free encyclopedia


In computer architecture and engineering, a sequencer or microsequencer  generates the addresses used to step through the microprogram of a control store. It is used as a part of the control unit of a CPU or as a stand-alone generator for address ranges.
Usually the addresses are generated by some combination of a counter, a field from a microinstruction, and some subset of the instruction register.  A counter is used for the typical case, that the next microinstruction is the one to execute.  A field from the microinstruction is used for jumps, or other logic.
Since CPUs implement an instruction set, it's very useful to be able to decode the instruction's bits directly into the sequencer, to select a set of microinstructions to perform a CPU's instructions.
Most modern CISC processors use a combination of pipelined logic to process lower complexity opcodes which can be completed in one clock cycle, and microcode to implement ones that take multiple clock cycles to complete.
One of the first integrated microcoded processors was the IBM PALM Processor, which emulated all of the processor's instruction in microcode and was used on the IBM 5100, one of the first personal computers.
Recent examples of similar open-sourced microsequencer-based processors are the MicroCore Labs MCL86,  MCL51, and MCL65 cores which emulate the Intel 8086/8088, 8051 and MOS 6502 instruction sets entirely in microcode.


Simple example[edit]
The Digital Scientific Corp. Meta 4 Series 16 computer system was a user-microprogrammable system first available in 1970. Branches in the microcode sequence occur in
one of three ways.[1]

A branch microinstruction specifies the address of the next instruction, either conditionally or unconditionally. The logical index (IX) option causes the 16-bit Link register to be logical ORed into the branch address, thus providing a simple indexed branch capability.
All the arithmetic/logical instructions allow the jump (J) modifier, which redirects execution to the microinstruction addressed by the Link register.
All the arithmetic/logical instructions allow both the decrement counter (D) and jump (J) modifiers. In this case, the 8-bit loop counter register is decremented. If it is then not zero, a branch is taken to the contents of the Link register. If it is zero, execution continues with the next instruction.
One more sequencing option allowed on a branch instruction is the execute (XQ) option. When specified, the single instruction at the branch address is executed, but then execution continues after the original branch instruction. The IX option can be used with the XQ option.

Complex example[edit]
The IBM System/360 was a series of compatible computers introduced in 1964, many of which were microprogrammed.[2] The System/360 Model 40 is a good example of a microprogrammed machine with complex microsequencing.[3]
The microstore consists of 4,096 56-bit microinstructions that operate in
a horizontal microprogramming style. The store is addressed by the 12-bit
read-only address register (ROAR). Unlike most registers in the
S/360 architecture, bits in the ROAR are numbered from bit 0 on the right
to bit 11 on the left.

  +------------+
  |    ROAR    |
  +------------+
  11          0

The model 40 performs no sequential execution of microinstructions and
therefore the microsequencer doesn't really branch in the conventional
sense. Instead, each microinstruction specifies the address of the next one
to be executed. Four fields in the microinstruction contribute to the new
address.

CA, 4 bits: Part of the next address, depending on the other fields.
CB, 4 bits: Determines bit 1 of the next address.
CC, 4 bits: Determines bit 0 of the next address.
CD, 2 bits: Controls how the next address is assembled (except when the CB field contains 15).
There are essentially three combinations or formats of these fields.

Functional branch format[edit]
When the CB field contains 15, a functional branch occurs. The bits of
the new microstore address in the ROAR are determined as follows.

bits 11–10: CD field
bits 9–6: CA field
bit 5: always 0
bits 4–1: high-order 4 bits of the Q register, which is the right input to the 8-bit ALU
bit 0: result of the test specified by the CC field
The CC field can specify various tests of the state of the machine. It can
also specify a constant 0 or 1 for an unconditional bit. 
This format alters the flow of control to 1 of 16 instruction pairs
within the low 32 words of a 64-word block of microstore (because bit 5 is
always 0).  The CC field then determines which instruction of the pair
receives control.

CD = 0, 1, 3 format[edit]
When the CD field is 0, 1, or 3, flow of control is directed to an
instruction within the current 64-word block. The bits of the new microstore
address are determined as follows.

bits 11–6: remain the same
bits 5–2: CA field
bit 1: if CD = 0, result of the test specified by the CB field; otherwise 0
bit 0: result of the test specified by the CC field
The CA field selects 1 of 16 4-word groups within the current 64-word block.
The CB and CC fields then determine which instruction of the 4 receives
control.

CD = 2 format[edit]
When the CD field is 2, flow of control is directed in a nonobvious manner. The
bits of the new microstore address are determined as follows:

bits 11–10: remain the same
bits 9–6: CA field
bits 5–2: remain the same
bit 1: result of the test specified by the CB field
bit 0: result of the test specified by the CC field
The next instruction is in the same 1K-word region as the current
instruction, because bits 11–10 remain the same. The CA field determines
the 64-word block within the region. The instruction is in the same 4-word
group within the new block as the current instruction is within the current
block, because bits 5–2 remain the same.
The CB and CC fields then determine which instruction of the 4 receives
control.

Simplification[edit]
This description has been simplified. It ignores the following features.

The model 40 can run in CPU mode or channel mode. The description addresses only CPU mode.
If the microinstruction is not in functional branch format and the CD field is 1 or 3, bit 1 of the next address is always 0. In this case, the values of the CD and CB fields determine one of a set of control lines to raise.
References[edit]


^ Digital Scientific Meta 4 Series 16 Computer System Reference Manual (PDF). Digital Scientific Corporation. May 1971. 7032MO.

^ IBM System/360 Principles of Operation (PDF). International Business Machines Corp. September 1968. A22-6821-7.

^ System/360 Model 40 Functional Units (PDF). International Business Machines Corp. March 1970. SY22-2843-1.



vteProcessor technologiesModels
Abstract machine
Stored-program computer
Finite-state machine
with datapath
Hierarchical
Deterministic finite automaton
Queue automaton
Cellular automaton
Quantum cellular automaton
Turing machine
Alternating Turing machine
Universal
Post–Turing
Quantum
Nondeterministic Turing machine
Probabilistic Turing machine
Hypercomputation
Zeno machine
Belt machine
Stack machine
Register machines
Counter
Pointer
Random-access
Random-access stored program
Architecture
Microarchitecture
Von Neumann
Harvard
modified
Dataflow
Transport-triggered
Cellular
Endianness
Memory access
NUMA
HUMA
Load–store
Register/memory
Cache hierarchy
Memory hierarchy
Virtual memory
Secondary storage
Heterogeneous
Fabric
Multiprocessing
Cognitive
Neuromorphic
Instruction setarchitecturesTypes
Orthogonal instruction set
CISC
RISC
Application-specific
EDGE
TRIPS
VLIW
EPIC
MISC
OISC
NISC
ZISC
VISC architecture
Quantum computing
Comparison
Addressing modes
Instructionsets
Motorola 68000 series
VAX
PDP-11
x86
ARM
Stanford MIPS
MIPS
MIPS-X
Power
POWER
PowerPC
Power ISA
Clipper architecture
SPARC
SuperH
DEC Alpha
ETRAX CRIS
M32R
Unicore
Itanium
OpenRISC
RISC-V
MicroBlaze
LMC
System/3x0
S/360
S/370
S/390
z/Architecture
Tilera ISA
VISC architecture
Epiphany architecture
Others
ExecutionInstruction pipelining
Pipeline stall
Operand forwarding
Classic RISC pipeline
Hazards
Data dependency
Structural
Control
False sharing
Out-of-order
Scoreboarding
Tomasulo's algorithm
Reservation station
Re-order buffer
Register renaming
Wide-issue
Speculative
Branch prediction
Memory dependence prediction
ParallelismLevel
Bit
Bit-serial
Word
Instruction
Pipelining
Scalar
Superscalar
Task
Thread
Process
Data
Vector
Memory
Distributed
Multithreading
Temporal
Simultaneous
Hyperthreading
Simultaneous and heterogenous
Speculative
Preemptive
Cooperative
Flynn's taxonomy
SISD
SIMD
Array processing (SIMT)
Pipelined processing
Associative processing
SWAR
MISD
MIMD
SPMD
Processorperformance
Transistor count
Instructions per cycle (IPC)
Cycles per instruction (CPI)
Instructions per second (IPS)
Floating-point operations per second (FLOPS)
Transactions per second (TPS)
Synaptic updates per second (SUPS)
Performance per watt (PPW)
Cache performance metrics
Computer performance by orders of magnitude
Types
Central processing unit (CPU)
Graphics processing unit (GPU)
GPGPU
Vector
Barrel
Stream
Tile processor
Coprocessor
PAL
ASIC
FPGA
FPOA
CPLD
Multi-chip module (MCM)
System in a package (SiP)
Package on a package (PoP)
By application
Embedded system
Microprocessor
Microcontroller
Mobile
Ultra-low-voltage
ASIP
Soft microprocessor
Systemson chip
System on a chip (SoC)
Multiprocessor (MPSoC)
Cypress PSoC
Network on a chip (NoC)
Hardwareaccelerators
Coprocessor
AI accelerator
Graphics processing unit (GPU)
Image processor
Vision processing unit (VPU)
Physics processing unit (PPU)
Digital signal processor (DSP)
Tensor Processing Unit (TPU)
Secure cryptoprocessor
Network processor
Baseband processor

Word size
1-bit
4-bit
8-bit
12-bit
15-bit
16-bit
24-bit
32-bit
48-bit
64-bit
128-bit
256-bit
512-bit
bit slicing
others
variable
Core count
Single-core
Multi-core
Manycore
Heterogeneous architecture
Components
Core
Cache
CPU cache
Scratchpad memory
Data cache
Instruction cache
replacement policies
coherence
Bus
Clock rate
Clock signal
FIFO
Functionalunits
Arithmetic logic unit (ALU)
Address generation unit (AGU)
Floating-point unit (FPU)
Memory management unit (MMU)
Load–store unit
Translation lookaside buffer (TLB)
Branch predictor
Branch target predictor
Integrated memory controller (IMC)
Memory management unit
Instruction decoder
Logic
Combinational
Sequential
Glue
Logic gate
Quantum
Array
Registers
Processor register
Status register
Stack register
Register file
Memory buffer
Memory address register
Program counter
Control unit
Hardwired control unit
Instruction unit
Data buffer
Write buffer
Microcode ROM
Counter
Datapath
Multiplexer
Demultiplexer
Adder
Multiplier
CPU
Binary decoder
Address decoder
Sum-addressed decoder
Barrel shifter
Circuitry
Integrated circuit
3D
Mixed-signal
Power management
Boolean
Digital
Analog
Quantum
Switch

Powermanagement
PMU
APM
ACPI
Dynamic frequency scaling
Dynamic voltage scaling
Clock gating
Performance per watt (PPW)
Related
History of general-purpose CPUs
Microprocessor chronology
Processor design
Digital electronics
Hardware security module
Semiconductor device fabrication
Tick–tock model
Pin grid array
Chip carrier





Retrieved from "https://en.wikipedia.org/w/index.php?title=Microsequencer&oldid=1251219622"
Category: Central processing unit






 This page was last edited on 15 October 2024, at 00:51 (UTC).
Text is available under the Creative Commons Attribution-ShareAlike 4.0 License;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.


Privacy policy
About Wikipedia
Disclaimers
Contact Wikipedia
Code of Conduct
Developers
Statistics
Cookie statement
Mobile view














Search













Search









Toggle the table of contents







Microsequencer




























2 languages


Add topic
















