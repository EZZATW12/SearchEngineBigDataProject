https://en.wikipedia.org/wiki/Abstract_machine




Abstract machine - Wikipedia



























Jump to content







Main menu





Main menu
move to sidebar
hide



		Navigation
	


Main pageContentsCurrent eventsRandom articleAbout WikipediaContact us





		Contribute
	


HelpLearn to editCommunity portalRecent changesUpload fileSpecial pages



















Search











Search






















Appearance
















Donate

Create account

Log in








Personal tools





Donate Create account Log in





		Pages for logged out editors learn more



ContributionsTalk




























Contents
move to sidebar
hide




(Top)





1
Classification








2
Implementation








3
Programming language implementation




Toggle Programming language implementation subsection





3.1
Imperative languages








3.2
Object-oriented languages








3.3
String processing languages








3.4
Functional programming languages








3.5
Logical languages










4
Structure




Toggle Structure subsection





4.1
Processing primitive data








4.2
Sequence control








4.3
Controlling data transfers








4.4
Memory management










5
Hierarchies








6
See also








7
References








8
Further reading


















Toggle the table of contents







Abstract machine



23 languages




العربيةবাংলাCatalàDeutschΕλληνικάEspañolفارسیFrançais한국어HrvatskiIdoItalianoMagyar日本語PortuguêsРусскийSimple EnglishSuomiSvenskaTürkçeУкраїнська粵語中文

Edit links











ArticleTalk





English

















ReadEditView history







Tools





Tools
move to sidebar
hide



		Actions
	


ReadEditView history





		General
	


What links hereRelated changesUpload filePermanent linkPage informationCite this pageGet shortened URLDownload QR code





		Print/export
	


Download as PDFPrintable version





		In other projects
	


Wikimedia CommonsWikidata item





















Appearance
move to sidebar
hide










From Wikipedia, the free encyclopedia


Theoretical computer used for defining a model of computation
Not to be confused with Virtual machine.
In computer science, an abstract machine is a theoretical model that allows for a detailed and precise analysis of how a computer system functions.[1] It is similar to a mathematical function in that it receives inputs and produces outputs based on predefined rules. Abstract machines vary from literal machines in that they are expected to perform correctly and independently of hardware.[2] Abstract machines are "machines" because they allow step-by-step execution of programs; they are "abstract" because they ignore many aspects of actual (hardware) machines.[3] A typical abstract machine consists of a definition in terms of input, output, and the set of allowable operations used to turn the former into the latter. They can be used for purely theoretical reasons as well as models for real-world computer systems.[2] In the theory of computation, abstract machines are often used in thought experiments regarding computability or to analyse the complexity of algorithms.[3] This use of abstract machines is fundamental to the field of computational complexity theory, such as with finite state machines, Mealy machines, push-down automata, and Turing machines.[4]


Classification[edit]
Abstract machines are typically categorized into two types based on the quantity of operations they can execute simultaneously at any given moment: deterministic abstract machines and non-deterministic abstract machines.[2] A deterministic abstract machine is a system in which a particular beginning state or condition always yields the same outputs. There is no randomness or variation in how inputs are transformed into outputs.[5] In contrast, a non-deterministic abstract machine can provide various outputs for the same input on different executions.[2] Unlike a deterministic algorithm, which gives the same result for the same input regardless of the number of iterations, a non-deterministic algorithm takes various paths to arrive to different outputs.[6] Non-deterministic algorithms are helpful for obtaining approximate answers when deriving a precise solution using a deterministic approach is difficult or costly.[7]

A run of a Turing machine
Turing machines, for example, are some of the most fundamental abstract machines in computer science.[2] These machines conduct operations on a tape (a string of symbols) of any length. Their instructions provide for both modifying the symbols and changing the symbol that the machine’s pointer is currently at. For example, a rudimentary Turing machine could have a single command, "convert symbol to 1 then move right", and this machine would only produce a string of 1s.[8] This basic Turing machine is deterministic; however, nondeterministic Turing machines that can execute several actions given the same input may also be built.[2]

Implementation[edit]
Any implementation of an abstract machine in the case of physical implementation (in hardware) uses some kind of physical device (mechanical or electronic) to execute the instructions of a programming language. An abstract machine, however, can also be implemented in software or firmware at levels between the abstract machine and underlying physical device.[9]

Implementation in hardware: The direct implementation of abstract machine in hardware is a matter of using physical devices such as memory, arithmetic and logic circuits, buses, etc., to implement a physical machine whose machine language coincides with the programming language. Once constructed, it would be virtually hard to change such a machine.[9] A CPU may be thought of as a concrete hardware realisation of an abstract machine, particularly the processor's design.[10]
Simulation using software: Implementing an abstract machine with software entails writing programmes in a different language to implement the data structures and algorithms needed by the abstract machine. This provides the most flexibility since programmes implementing abstract machine constructs can be easily changed.[9] An abstract machine implemented as a software simulation, or for which an interpreter exists, is called a virtual machine.[11]
Emulation using firmware: Firmware implementation sits between hardware and software implementation. It consists of microcode simulations of data structures and algorithms for abstract machines.[9] Microcode allows a computer programmer to write machine instructions without needing to fabricate electrical circuitry.[12]
Programming language implementation[edit]
An abstract machine is, intuitively, just an abstraction of the idea of a physical computer.[13] For actual execution, algorithms must be properly formalised using the constructs offered by a programming language. This implies that the algorithms to be executed must be expressed using programming language instructions.[3] The syntax of a programming language enables the construction of programs using a finite set of constructs known as instructions. Most abstract machines share a program store and a state, which often includes a stack and registers.[9][14] In digital computers, the stack is simply a memory unit with an address register that can count only positive integers (after an initial value is loaded into it). The address register for the stack is known as a stack pointer because its value always refers to the top item on the stack.[15] The program consists of a series of instructions, with a stack pointer indicating the next instruction to be performed. When the instruction is completed, a stack pointer is advanced. This fundamental control mechanism of an abstract machine is also known as its execution loop.[3] Thus, an abstract machine for a programming language is any collection of data structures and algorithms capable of storing and running programs written in the programming language. It bridges the gap between the high level of a programming language and the low level of an actual machine by providing an intermediate language step for compilation. An abstract machine's instructions are adapted to the unique operations necessary to implement operations of a certain source language or set of source languages.[9]

Imperative languages[edit]
In the late 1950s, the Association for Computing Machinery (ACM) and other allied organisations developed many proposals for Universal Computer Oriented Language (UNCOL), such as Conway's machine. The UNCOL concept is good, but it has not been widely used due to the poor performance of the generated code. In many areas of computing, its performance will continue to be an issue despite the development of the Java Virtual Machine in the late 1990s. Algol Object Code (1964), P4-machine (1976), UCSD P-machine (1977), and Forth (1970) are some successful abstract machines of this kind.[3]

Object-oriented languages[edit]
Abstract machines for object-oriented programming languages are often stack-based and have special access instructions for object fields and methods. In these machines, memory management is often implicit performed by a garbage collector (memory recovery feature built into programming languages).[16] Smalltalk-80 (1980), Self (1989), and Java (1994) are examples of this implementation.[3]

String processing languages[edit]
A string processing language is a computer language that focuses on processing strings rather than numbers. There have been string processing languages in the form of command shells, programming tools, macro processors, and scripting languages for decades.[17] Using a suitable abstract machine has two benefits: increased execution speed and enhanced portability. Snobol4 and ML/I are two notable instances of early string processing languages that use an abstract machine to gain machine independence.[3]

Functional programming languages[edit]
Pictorial representation of a Krivine machineThe early abstract machines for functional languages, including the SECD machine (1964) and Cardelli's Functional Abstract Machine (1983), defined strict evaluation, also known as eager or call-by-value evaluation,[3] in which function arguments are evaluated before the call and precisely once. Recently, the majority of research has been on lazy (or call-by-need) evaluation,[18] such as the G-machine (1984), Krivine machine (1985), and Three Instruction Machine (1986), in which function arguments are evaluated only if necessary and at most once. One reason is because effective implementation of strict evaluation is now well-understood, therefore the necessity for an abstract machine has diminished.[3]
Logical languages[edit]
Predicate calculus (first order logic) is the foundation of logic programming languages. The most well-known logic programming language is Prolog. The rules in Prolog are written in a uniform format known as universally quantified 'Horn clauses', which means to begin the calculation that attempts to discover a proof of the objective. The Warren Abstract Machine WAM (1983),[3] which has become the de facto standard in Prolog program compilation, has been the focus of most study. It provides special purpose instructions such as data unification instructions and control flow instructions to support backtracking (searching algorithm).[19]

Structure[edit]
A generic abstract machine is made up of a memory and an interpreter. The memory is used to store data and programs, while the interpreter is the component that executes the instructions included in programs.[9]

The structure of an abstract machine
The interpreter must carry out the operations that are unique to the language it is interpreting. However, given the variety of languages, it is conceivable to identify categories of operations and an "execution mechanism" shared by all interpreters. The interpreter's operations and accompanying data structures are divided into the following categories:[9][20]

Operations for processing primitive data:
Operations and data structures for controlling the sequence of execution of operations;
Operations and data structures for controlling data transfers;
Operations and data structures for memory management.
Processing primitive data[edit]
An abstract machine must contain operations for manipulating primitive data types such as strings and integers.[9] For example, integers are nearly universally considered a basic data type for both physical abstract machines and the abstract machines used by many programming languages. The machine carries out the arithmetic operations necessary, such as addition and multiplication, within a single time step.[21]

Sequence control[edit]
Operations and structures for "sequence control" allow controlling the execution flow of program instructions. When certain conditions are met, it is necessary to change the typical sequential execution of a program.[9] Therefore, the interpreter employs data structures (such as those used to store the address of the next instruction to execute) that are modified by operations distinct from those used for data manipulation (for example, operations to update the address of the next instruction to execute).[22]

Controlling data transfers[edit]
Data transfer operations are used to control how operands and data are transported from memory to the interpreter and vice versa. These operations deal with the store and the retrieval order of operands from the store.[9]

Memory management[edit]
Memory management is concerned with the operations performed in memory to allocate data and applications. In the abstract machine, data and programmes can be held indefinitely, or in the case of programming languages, memory can be allocated or deallocated using a more complex mechanism.[9]

Hierarchies[edit]
This section relies largely or entirely on a single source. Relevant discussion may be found on the talk page. Please help improve this article by introducing  citations to additional sources.Find sources: "Abstract machine" – news · newspapers · books · scholar · JSTOR (January 2023)
A hierarchy of abstract machines
Abstract machine hierarchies are often employed, in which each machine uses the functionality of the level immediately below and adds additional functionality of its own to meet the level immediately above. A hardware computer, constructed with physical electronic devices, can be added at the most basic level. Above this level, the abstract microprogrammed machine level may be introduced. The abstract machine supplied by the operating system, which is implemented by a program written in machine language, is located immediately above (or directly above the hardware if the firmware level is not there). On the one hand, the operating system extends the capability of the physical machine by providing higher-level primitives that are not available on the physical machine (for example, primitives that act on files). The host machine is formed by the abstract machine given by the operating system, on which a high-level programming language is implemented using an intermediary machine, such as the Java Virtual machine and its byte code language. The level given by the abstract machine for the high-level language (for example, Java) is not usually the final level of hierarchy. At this point, one or more applications that deliver additional services together may be introduced. A "web machine" level, for example, can be added to implement the functionalities necessary to handle Web communications (communications protocols or HTML code presentation). The "Web Service" level is located above this, and it provides the functionalities necessary to make web services communicate, both in terms of interaction protocols and the behaviour of the processes involved. At this level, entirely new languages that specify the behaviour of so-called "business processes" based on Web services may be developed (an example is the Business Process Execution Language). Finally, a specialised application can be found at the highest level (for example, E-commerce) which has very specific and limited functionality.[9]

See also[edit]
Abstract interpretation – Approach to static program analysis
Bulk synchronous parallel – model for designing parallel algorithmsPages displaying wikidata descriptions as a fallback
Discrete time – Frameworks for modeling variables that evolve over timePages displaying short descriptions of redirect targets
Flynn's taxonomy – Classification of computer architectures
Formal models of computation – Ability to solve a problem in an effective manner
Model of computation – Mathematical model describing how an output of a function is computed given an input
Parallel random-access machine – Abstract computer for designing parallel algorithmsPages displaying short descriptions of redirect targets, the de facto standard model
SECD machine – Abstract machine as a target for compilers
State space – Set of all possible values of a systemPages displaying short descriptions of redirect targets
References[edit]

^ Weisstein, Eric W. "Abstract Machine". mathworld.wolfram.com. Retrieved 2022-05-16.

^ a b c d e f "What is an Abstract Machine?". EasyTechJunkie. Retrieved 2022-05-16.

^ a b c d e f g h i j Diehl, Stephan; Hartel, Pieter; Sestoft, Peter (May 2000). "Abstract machines for programming language implementation". Future Generation Computer Systems. 16 (7): 739–751. doi:10.1016/S0167-739X(99)00088-6.

^ "9.1.1: Finite-State Machine Overview". Engineering LibreTexts. 2021-04-29. Retrieved 2022-05-31.

^ "What is Deterministic System? - Definition from Techopedia". Techopedia.com. 29 August 2019. Retrieved 2022-05-30.

^ Stearns, Richard E. (January 2003). "Deterministic versus nondeterministic time and lower bound problems". Journal of the ACM. 50 (1): 91–95. doi:10.1145/602382.602409. ISSN 0004-5411. S2CID 2194820.

^ Armoni, Michal; Gal-Ezer, Judith (December 2007). "Non-determinism: An abstract concept in computer science studies". Computer Science Education. 17 (4): 243–262. Bibcode:2007CSEd...17..243A. doi:10.1080/08993400701442885. ISSN 0899-3408. S2CID 41928460.

^ Gill, John (December 1977). "Computational Complexity of Probabilistic Turing Machines". SIAM Journal on Computing. 6 (4): 675–695. doi:10.1137/0206049. ISSN 0097-5397.

^ a b c d e f g h i j k l m Gabbrielli, Maurizio; Martini, Simone (2010), "Abstract Machines", Programming Languages: Principles and Paradigms, London: Springer London, pp. 1–25, doi:10.1007/978-1-84882-914-5_1, ISBN 978-1-84882-913-8, retrieved 2022-05-16

^ Bair, Ray; Chien, Andrew; Cook, Jeanine; Donofrio, Dave; Grider, Gary; Kuehn, Jeff; Moore, Shirley; Shalf, John; Vetter, Jeff (2018-02-01). Hardware Evaluation: Abstract Machine Models and Proxy Architectures for Exascale Computing (Technical report). U.S. Department of Energy Office of Scientific and Technical Information. doi:10.2172/1733300. OSTI 1733300.

^ "abstract machine from FOLDOC". foldoc.org. Retrieved 2021-08-07.

^ Gee, J.; Melvin, S. W.; Patt, Y. N. (1986). "The implementation of Prolog via VAX 8600 microcode". Proceedings of the 19th annual workshop on Microprogramming. New York, New York, USA: ACM Press. pp. 68–74. doi:10.1145/19551.19538. ISBN 081860736X. S2CID 3846072.

^ "abstract machine". Oxford Reference. Retrieved 2022-05-16.

^ García-Martín, Julio Manuel; Sutil-Martin, Miguel (August 15, 1999). "The Abstract Machine: A Pattern for Designing Abstract Machines" (PDF). Proceedings of Pattern Languages of Programs '99.

^ upscfever.com (2017-01-25). "Computer Organization and Architecture (Stack Organization) - UPSC FEVER". upscfever.com. Retrieved 2022-05-31.

^ "What is Object-Oriented Programming (OOP)?". SearchAppArchitecture. Retrieved 2022-05-31.

^ "Design considerations for string processing languages", A Study in String Processing Languages, Lecture Notes in Computer Science, vol. 205, Berlin, Heidelberg: Springer Berlin Heidelberg, pp. 17–37, 1985, doi:10.1007/3-540-16041-8_2, ISBN 978-3-540-16041-0, retrieved 2022-05-31

^ Hackett, Jennifer; Hutton, Graham (2019-07-26). "Call-by-need is clairvoyant call-by-value". Proceedings of the ACM on Programming Languages. 3 (ICFP): 1–23. doi:10.1145/3341718. ISSN 2475-1421. S2CID 195782686.

^ "Prolog | An Introduction". GeeksforGeeks. 2018-05-26. Retrieved 2022-05-31.

^ Accattoli, Beniamino; Barenbaum, Pablo; Mazza, Damiano (2014-11-26). "Distilling abstract machines". ACM SIGPLAN Notices. 49 (9): 363–376. doi:10.1145/2692915.2628154. ISSN 0362-1340. S2CID 234775413.

^ baeldung (2018-01-11). "Introduction to Java Primitives | Baeldung". www.baeldung.com. Retrieved 2022-05-31.

^ Kuchana, Partha (2004), "Interpreter", Software Architecture Design Patterns in Java, Auerbach Publications, doi:10.1201/9780203496213, ISBN 978-0-8493-2142-9


Further reading[edit]
Peter van Emde Boas, Machine Models and Simulations pp. 3–66, appearing in:
Jan van Leeuwen, ed. "Handbook of Theoretical Computer Science. Volume A: Algorithms and Complexity, The MIT PRESS/Elsevier, 1990. ISBN 0-444-88071-2 (volume A). QA 76.H279 1990
Stephan Diehl, Pieter Hartel and Peter Sestoft, Abstract Machines for Programming Language Implementation, Future Generation Computer Systems, Vol. 16(7), Elsevier, 2000.
Werner Kluge (2006). Abstract Computing Machines: A Lambda Calculus Perspective. Springer. ISBN 978-3-540-27359-2.




Retrieved from "https://en.wikipedia.org/w/index.php?title=Abstract_machine&oldid=1279086959"
Categories: Abstract machinesAutomata (computation)Models of computationHidden categories: Articles with short descriptionShort description is different from WikidataArticles needing additional references from January 2023All articles needing additional referencesPages displaying wikidata descriptions as a fallback via Module:Annotated linkPages displaying short descriptions of redirect targets via Module:Annotated link






 This page was last edited on 6 March 2025, at 13:07 (UTC).
Text is available under the Creative Commons Attribution-ShareAlike 4.0 License;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.


Privacy policy
About Wikipedia
Disclaimers
Contact Wikipedia
Code of Conduct
Developers
Statistics
Cookie statement
Mobile view














Search













Search









Toggle the table of contents







Abstract machine




























23 languages


Add topic
















