https://en.wikipedia.org/wiki/Standard_Template_Library




Standard Template Library - Wikipedia



























Jump to content







Main menu





Main menu
move to sidebar
hide



		Navigation
	


Main pageContentsCurrent eventsRandom articleAbout WikipediaContact us





		Contribute
	


HelpLearn to editCommunity portalRecent changesUpload fileSpecial pages



















Search











Search






















Appearance
















Donate

Create account

Log in








Personal tools





Donate Create account Log in





		Pages for logged out editors learn more



ContributionsTalk




























Contents
move to sidebar
hide




(Top)





1
History








2
Composition




Toggle Composition subsection





2.1
Containers








2.2
Iterators








2.3
Algorithms








2.4
Functions










3
Criticisms




Toggle Criticisms subsection





3.1
Quality of implementation of C++ compilers








3.2
Other issues










4
Implementations








5
See also








6
Notes








7
References








8
External links


















Toggle the table of contents







Standard Template Library



32 languages




العربيةБеларускаяБеларуская (тарашкевіца)БългарскиCatalàČeštinaDeutschEestiEspañolفارسیFrançais한국어हिन्दीItalianoעבריתҚазақшаMagyarМакедонскиമലയാളംNederlands日本語PolskiPortuguêsРусскийСрпски / srpskiSrpskohrvatski / српскохрватскиSuomiSvenskaไทยTürkçeУкраїнська中文

Edit links











ArticleTalk





English

















ReadEditView history







Tools





Tools
move to sidebar
hide



		Actions
	


ReadEditView history





		General
	


What links hereRelated changesUpload filePermanent linkPage informationCite this pageGet shortened URLDownload QR code





		Print/export
	


Download as PDFPrintable version





		In other projects
	


WikibooksWikidata item





















Appearance
move to sidebar
hide










From Wikipedia, the free encyclopedia


Software library for the C++ programming language
Not to be confused with C++ Standard Library.For other uses, see STL.


C++ Standard Library
Input/output
Strings
algorithm
functional

Containers
Sequence containers
Associative containers
Unordered associative containers

C standard library
Data types
Character classification
Strings
Mathematics
File input/output
Date/time
Localization
Memory allocation
Process control
Signals
Alternative tokens
Miscellaneous headers:
<assert.h>
<errno.h>
<setjmp.h>
<stdarg.h>
vte
The Standard Template Library (STL) is a software library originally designed by Alexander Stepanov for the C++ programming language that influenced many parts of the C++ Standard Library. It provides four components called algorithms, containers, functors, and iterators.[1]
The STL provides a set of common classes for C++, such as containers and associative arrays, that can be used with any built-in type or user-defined type that supports some elementary operations (such as copying and assignment). STL algorithms are independent of containers, which significantly reduces the complexity of the library.
The STL achieves its results through the use of templates. This approach provides compile-time polymorphism that is often more efficient than traditional run-time polymorphism. Modern C++ compilers are tuned to minimize abstraction penalties arising from heavy use of the STL.
The STL was created as the first library of generic algorithms and data structures for C++, with four ideas in mind: generic programming, abstractness without loss of efficiency, the Von Neumann computation model,[2] and value semantics.
The STL and the C++ Standard Library are two distinct entities.[3]


History[edit]
Main article: History of the Standard Template Library
In November 1993 Alexander Stepanov presented a library based on generic programming to the ANSI/ISO committee for C++ standardization. The committee's response was overwhelmingly favorable and led to a request from Andrew Koenig for a formal proposal in time for the March 1994 meeting.  The committee had several requests for changes and extensions and the committee members met with Stepanov and Meng Lee to help work out the details. The requirements for the most significant extension (associative containers) had to be shown to be consistent by fully implementing them, a task Stepanov delegated to David Musser.  A proposal received final approval at the July 1994 ANSI/ISO committee meeting.  Subsequently, the Stepanov and Lee document 17 was incorporated into the ANSI/ISO C++ draft standard (1, parts of clauses 17 through 27).
The prospects for early widespread dissemination of the STL were considerably improved with Hewlett-Packard's decision to make its implementation freely available on the Internet in August 1994. This implementation, developed by Stepanov, Lee, and Musser during the standardization process, became the basis of many implementations offered by compiler and library vendors today.

Composition[edit]
Containers[edit]
The STL contains sequence containers and associative containers. The containers are objects that store data. The standard sequence containers include vector, deque, and list. The standard associative containers are set, multiset, map, multimap, hash_set, hash_map, hash_multiset and hash_multimap. There are also container adaptors queue, priority_queue, and stack, that are containers with specific interface, using other containers as implementation.



Container

Description


Simple containers


pair

The pair container is a simple associative container consisting of a 2-tuple of data elements or objects, called 'first' and 'second', in that fixed order. The STL 'pair' can be assigned, copied and compared. The array of objects allocated in a map or hash_map (described below) are of type 'pair' by default, where all the 'first' elements act as the unique keys, each associated with their 'second' value objects.


Sequences (arrays/linked lists): ordered collections


vector

a dynamic array, like C array (i.e., capable of random access) with the ability to resize itself automatically when inserting or erasing an object. Inserting an element to the back of the vector at the end takes amortized constant time. Removing the last element takes only constant time, because no resizing happens. Inserting and erasing at the beginning or in the middle is linear in time.
A optimization for type bool exists, which can optimize for space by grouping bool values together.[4]



list

a doubly linked list; elements are not stored in contiguous memory. Opposite performance from a vector. Slow lookup and access (linear time), but once a position has been found, quick insertion and deletion (constant time).


slist

a singly linked list; elements are not stored in contiguous memory. Opposite performance from a vector. Slow lookup and access (linear time), but once a position has been found, quick insertion and deletion (constant time). It has slightly more efficient insertion and deletion, and uses less memory than a doubly linked list, but can only be iterated forwards. It is implemented in the C++ standard library as forward_list.


deque (double-ended queue)

a vector with insertion/erase at the beginning or end in amortized constant time, however lacking some guarantees on iterator validity after altering the deque.


Container adaptors


queue

Provides FIFO queue interface in terms of push/pop/front/back operations.
Any sequence supporting operations front(), back(), push_back(), and pop_front() can be used to instantiate queue (e.g. list and deque).



priority queue

Provides priority queue interface in terms of push/pop/top operations (the element with the highest priority is on top).
Any random-access sequence supporting operations front(), push_back(), and pop_back() can be used to instantiate priority_queue (e.g. vector and deque). It is implemented using a heap.
Elements should additionally support comparison (to determine which element has a higher priority and should be popped first).



stack

Provides LIFO stack interface in terms of push/pop/top operations (the last-inserted element is on top).
Any sequence supporting operations back(), push_back(), and pop_back() can be used to instantiate stack (e.g. vector, list, and deque).



Associative containers: unordered collections


set

a mathematical set; inserting/erasing elements in a set does not invalidate iterators pointing in the set. Provides set operations union, intersection, difference, symmetric difference and test of inclusion. Type of data must implement comparison operator < or custom comparator function must be specified; such comparison operator or comparator function must guarantee strict weak ordering, otherwise behavior is undefined. Typically implemented using a self-balancing binary search tree.


multiset

same as a set, but allows duplicate elements (mathematical multiset).


map

an associative array; allows mapping from one data item (a key) to another (a value). Type of key must implement comparison operator < or custom comparator function must be specified; such comparison operator or comparator function must guarantee strict weak ordering, otherwise behavior is undefined. Typically implemented using a self-balancing binary search tree.


multimap

same as a map, but allows duplicate keys.


hash_sethash_multisethash_maphash_multimap

similar to a set, multiset, map, or multimap, respectively, but implemented using a hash table; keys are not ordered, but a hash function must exist for the key type. These types were left out of the C++ standard; similar containers were standardized in C++11, but with different names (unordered_set and unordered_map).


Other types of containers


bitset

stores series of bits similar to a fixed-sized vector of bools. Implements bitwise operations and lacks iterators. Not a sequence. Provides random access.


valarray

Another array data type, intended for numerical use (especially to represent vectors and matrices); the C++ standard allows specific optimizations for this intended purpose. According to Josuttis, valarray was badly designed, by people "who left the [C++ standard] committee a long time before the standard was finished", and expression template libraries are to be preferred.[5] A proposed rewrite of the valarray part of the standard in this vein was rejected, instead becoming a permission to implement it using expression template.[6]

Iterators[edit]
The STL implements five different types of iterators. These are input iterators (that can only be used to read a sequence of values), output iterators (that can only be used to write a sequence of values), forward iterators (that can be read, written to, and move forward), bidirectional iterators (that are like forward iterators, but can also move backwards) and random-access iterators (that can move freely any number of steps in one operation).
A fundamental STL concept is a range which is a pair of iterators that designate the beginning and end of the computation, and most of the library's algorithmic templates that operate on data structures have interfaces that use ranges.[7]
It is possible to have bidirectional iterators act like random-access iterators, so moving forward ten steps could be done by simply moving forward a step at a time a total of ten times. However, having distinct random-access iterators offers efficiency advantages. For example, a vector would have a random-access iterator, but a list only a bidirectional iterator.
Iterators are the major feature that allow the generality of the STL. For example, an algorithm to reverse a sequence can be implemented using bidirectional iterators, and then the same implementation can be used on lists, vectors and deques. User-created containers only have to provide an iterator that implements one of the five standard iterator interfaces, and all the algorithms provided in the STL can be used on the container.
This generality also comes at a price at times. For example, performing a search on an associative container such as a map or set can be much slower using iterators than by calling member functions offered by the container itself. This is because an associative container's methods can take advantage of knowledge of the internal structure, which is opaque to algorithms using iterators.

Algorithms[edit]
A large number of algorithms to perform activities such as searching and sorting are provided in the STL, each implemented to require a certain level of iterator (and therefore will work on any container that provides an interface by iterators). Searching algorithms like binary_search and lower_bound use binary search and like sorting algorithms require that the type of data must implement comparison operator < or custom comparator function must be specified; such comparison operator or comparator function must guarantee strict weak ordering. Apart from these, algorithms are provided for making heap from a range of elements, generating lexicographically ordered permutations of a range of elements, merge sorted ranges and perform union, intersection, difference of sorted ranges.

Functions[edit]
The STL includes classes that overload the function call operator (operator()). Instances of such classes are called functors or function objects. Functors allow the behavior of the associated function to be parameterized (e.g. through arguments passed to the functor's constructor) and can be used to keep associated per-functor state information along with the function. Since both functors and function pointers can be invoked using the syntax of a function call, they are interchangeable as arguments to templates when the corresponding parameter only appears in function call contexts.
A particularly common type of functor is the predicate. For example, algorithms like find_if take a unary predicate that operates on the elements of a sequence. Algorithms like sort, partial_sort, nth_element and all sorted containers use a binary predicate that must provide a strict weak ordering, that is, it must behave like a membership test on a transitive, non-reflexive and asymmetric binary relation. If none is supplied, these algorithms and containers use less by default, which in turn calls the less-than-operator <.

Criticisms[edit]
Quality of implementation of C++ compilers[edit]
The Quality of Implementation (QoI) of the C++ compiler has a large impact on usability of the STL (and templated code in general):

Error messages involving templates tend to be very long and difficult to decipher. This problem has been considered so severe that a number of tools have been written that simplify and prettyprint STL-related error messages to make them more comprehensible.
Careless use of templates can lead to code bloat.[8] This has been countered with special techniques within STL implementations (e.g. using void* containers internally and other "diet template" techniques) and improving compilers' optimization techniques. However, this symptom is similar to naively manually copying a set of functions to work with a different type, in that both can be avoided with care and good technique.
Template instantiation can increase compilation time and memory usage, in exchange for typically reducing runtime decision-making (e.g. via virtual functions). Until the compiler technology improves enough, this problem can be only partially eliminated by careful coding, avoiding certain idioms, and simply not using templates where they are not appropriate or where compile-time performance is prioritized.
Other issues[edit]
Initialization of STL containers with constants within the source code is not as easy as data structures inherited from C (addressed in C++11 with initializer lists).
STL containers are not intended to be used as base classes (their destructors are deliberately non-virtual); deriving from a container is a common mistake.[9][10]
The concept of iterators as implemented by the STL can be difficult to understand at first: for example, if a value pointed to by the iterator is deleted, the iterator itself is then no longer valid. This is a common source of errors. Most implementations of the STL provide a debug mode that is slower, but can locate such errors if used. A similar problem exists in other languages, for example Java. Ranges have been proposed as a safer, more flexible alternative to iterators.[11]
Certain iteration patterns such as callback enumeration APIs cannot be made to fit the STL model without the use of coroutines,[12] which were outside the C++ standard until C++20.
Compiler compliance does not guarantee that Allocator objects, used for memory management for containers, will work with state-dependent behavior. For example, a portable library can not define an allocator type that will pull memory from different pools using different allocator objects of that type. (Meyers, p. 50) (addressed in C++11).
The set of algorithms is not complete: for example, the copy_if algorithm was left out,[13] though it has been added in C++11.[14]
Implementations[edit]
Original STL implementation by Stepanov and Lee. 1994, Hewlett-Packard. No longer maintained.
SGI STL, based on original implementation by Stepanov & Lee. 1997, Silicon Graphics. No longer maintained.
STLPort, based on SGI STL
Rogue Wave Standard Library (HP, SGI, SunSoft, Siemens-Nixdorf)
Apache C++ Standard Library (The starting point for this library was the 2005 version of the Rogue Wave standard library[15])
Libstdc++ uses code derived from SGI STL for the algorithms and containers defined in C++03.
Dinkum STL library by P.J. Plauger
The Microsoft STL which ships with Visual C++ is a licensed derivative of Dinkum's STL. Source is available on Github.
EASTL, developed by Paul Pedriana at Electronic Arts and published as part of EA Open Source.
See also[edit]
List of C++ template libraries
Boost C++ Libraries
Notes[edit]


^ Holzner, Steven (2001). C++ : Black Book. Scottsdale, Ariz.: Coriolis Group. p. 648. ISBN 1-57610-777-9. The STL is made up of containers, iterators, function objects, and algorithms

^ Musser, David (2001). STL tutorial and reference guide: C++ programming with the standard template library. Addison Wesley. ISBN 0-201-37923-6.

^ Lightness Races in Orbit (5 March 2011). "What's the difference between "STL" and "C++ Standard Library"?". Stack Overflow. Retrieved 21 October 2021.

^ "[vector.bool]". Eelis. Retrieved 22 December 2024.

^ Josuttis, Nicolai M. (1999). The C++ Standard Library: A Tutorial and Handbook. Addison-Wesley Professional. p. 547. ISBN 9780201379266.

^ Vandevoorde, David; Josuttis, Nicolai M. (2002). C++ Templates: The Complete Guide. Addison Wesley. ISBN 0-201-73484-2.

^ Stepanov, Alexander; Lee, Meng (31 October 1995). "The Standard Template Library" (PDF). Retrieved 16 December 2018. Most of the library's algorithmic templates that operate on data structures have interfaces that use ranges. A range is a pair of iterators that designate the beginning and end of the computation. [...] in general, a range [i, j) refers to the elements in the data structure starting with the one pointed to by i and up to but not including the one pointed to by j. Range [i, j) is valid if and only if j is reachable from i.

^ Adrian Stone. "Minimizing Code Bloat: Template Overspecialization".

^ Meyers, Scott (2005). Effective C++ Third Edition – 55 Specific Ways to Improve Your Designs. Addison Wesley. ISBN 0-321-33487-6.

^ Sutter, Herb; Alexandrescu, Andrei (2004). C++ Coding Standards: 101 Rules, Guidelines, and Best Practices. Addison-Wesley. ISBN 0-321-11358-6.

^ Andrei Alexandrescu (6 May 2009). "Iterators Must Go" (PDF). BoostCon 2009. Retrieved 19 March 2011.

^ Matthew Wilson (February 2004). "Callback Enumeration APIs & the Input Iterator Concept". Dr. Dobb's Journal.

^ Bjarne Stroustrup (2000). The C++ Programming Language (3rd ed.). Addison-Wesley. ISBN 0-201-70073-5.: p.530 

^ More STL algorithms (revision 2)

^ "Apache C++ Standard Library". stdcxx.apache.org. Retrieved 1 March 2023.


References[edit]

Alexander Stepanov and Meng Lee, The Standard Template Library. HP Laboratories Technical Report 95-11(R.1), 14 November 1995. (Revised version of A. A. Stepanov and M. Lee: The Standard Template Library, Technical Report X3J16/94-0095, WG21/N0482, ISO Programming Language C++ Project, May 1994.)
Alexander Stepanov (2007). Notes on Programming (PDF). Stepanov reflects about the design of the STL.
Nicolai M. Josuttis (2000). The C++ Standard Library: A Tutorial and Reference. Addison-Wesley. ISBN 0-201-37926-0.
Scott Meyers (2001). Effective STL: 50 Specific Ways to Improve Your Use of the Standard Template Library. Addison-Wesley. ISBN 0-201-74962-9.
Al Stevens (March 1995). "Al Stevens Interviews Alex Stepanov". Dr. Dobb's Journal. Retrieved 18 July 2007.
David Vandevoorde and Nicolai M. Josuttis (2002). C++ Templates: The Complete Guide. Addison-Wesley Professional. ISBN 0-201-73484-2.
Atul Saini and David R. Musser (1996). STL Tutorial and Reference Guide: C+ + Programming with the Standard Template Library. Foreword by Alexander Stepanov; Copyright Modena Software Inc. Addison-Wesley. ISBN 0-201-63398-1.

External links[edit]
C++ reference
C++ STL reference, includes C++11 features
STL programmer's guide from SGI. Originally at [1] (retired content).
Apache (formerly Rogue Wave) C++ Standard Library Class Reference
Apache (formerly Rogue Wave) C++ Standard Library User Guide
Bjarne Stroustrup on The emergence of the STL (Page 5, Section 3.1)
C++ Standard Specification
vteC++
C++
Outline
C++98
C++03
C++11
C++14
C++17
C++20
C++23
C++26
Libraries
Features
C++ syntax
Classes
Concepts
Copy constructor
Exception handling (Exception safety)
Function overloading
Modules
Move semantics
new and delete
Operator overloading
Operators
Preprocessor
References
Templates
Virtual functions
Standard Library
I/O Streams
Smart pointers
STL
Strings
Ideas
As-if rule
Barton–Nackman trick
Curiously recurring template pattern
Most vexing parse
One Definition Rule
Resource acquisition is initialization
Rule of three
Slicing
Special member functions
Substitution failure is not an error
Template metaprogramming
Compilers
Comparison of C++ compilers
Borland C++
Borland Turbo C++
C++Builder
Clang
GCC
Intel C++ Compiler
Oracle Solaris Studio
Visual C++ (MSVC)
Watcom C/C++
IDEs
Comparison of C IDEs
Anjuta
CLion
Code::Blocks
CodeLite
Dev-C++
Eclipse
Geany
NetBeans
KDevelop
Qt Creator
Visual Studio
Superset languages
Objective-C++
C++/CLI
C++/CX
C++/WinRT
Ch
SYCL
Dialects
Embedded C++
Relative toother languages
Comparison of programming languages
Comparison of Java and C++
Compatibility of C and C++
Criticism of C++
People
David Abrahams
Andrei Alexandrescu
Pete Becker
Rick Mascitti
Scott Meyers
Alexander Stepanov
Bjarne Stroustrup
Herb Sutter
 Category




Retrieved from "https://en.wikipedia.org/w/index.php?title=Standard_Template_Library&oldid=1281620342"
Categories: C++ Standard LibraryGeneric programmingHidden categories: Articles with short descriptionShort description matches WikidataUse dmy dates from October 2020Articles with example C++ code






 This page was last edited on 21 March 2025, at 13:33 (UTC).
Text is available under the Creative Commons Attribution-ShareAlike 4.0 License;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.


Privacy policy
About Wikipedia
Disclaimers
Contact Wikipedia
Code of Conduct
Developers
Statistics
Cookie statement
Mobile view














Search













Search









Toggle the table of contents







Standard Template Library




























32 languages


Add topic
















