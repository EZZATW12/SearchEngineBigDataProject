https://en.wikipedia.org/wiki/PDP-8




PDP-8 - Wikipedia



































Jump to content







Main menu





Main menu
move to sidebar
hide



		Navigation
	


Main pageContentsCurrent eventsRandom articleAbout WikipediaContact us





		Contribute
	


HelpLearn to editCommunity portalRecent changesUpload fileSpecial pages



















Search











Search






















Appearance
















Donate

Create account

Log in








Personal tools





Donate Create account Log in





		Pages for logged out editors learn more



ContributionsTalk




























Contents
move to sidebar
hide




(Top)





1
Overview








2
Architectural significance








3
Description








4
Models




Toggle Models subsection





4.1
Latter-day implementations










5
Input/output








6
Programming facilities








7
Instruction set




Toggle Instruction set subsection





7.1
Basic instructions








7.2
IOT (Input-Output Transfer) instructions








7.3
OPR (OPeRate)






7.3.1
Group 1








7.3.2
Group 2, Or Group








7.3.3
Group 2, And Group








7.3.4
Group 3












8
Memory control








9
Examples




Toggle Examples subsection





9.1
Comparing two numbers








9.2
String output








9.3
Subroutines








9.4
Software stack








9.5
Linked list










10
Interrupts








11
Books








12
Unlicensed clones








13
References








14
External links


















Toggle the table of contents







PDP-8



19 languages




AsturianuCatalàDeutschΕλληνικάEspañolFrançais한국어ItalianoMagyarNederlands日本語Norsk bokmålPolskiPortuguêsРусскийСрпски / srpskiSuomiУкраїнська中文

Edit links











ArticleTalk





English

















ReadEditView history







Tools





Tools
move to sidebar
hide



		Actions
	


ReadEditView history





		General
	


What links hereRelated changesUpload filePermanent linkPage informationCite this pageGet shortened URLDownload QR code





		Print/export
	


Download as PDFPrintable version





		In other projects
	


Wikimedia CommonsWikidata item





















Appearance
move to sidebar
hide










From Wikipedia, the free encyclopedia


Minicomputer product line
PDP-8A PDP-8 on display at The National Museum of Computing in Bletchley, England. This example is from the first generation of PDP-8s, built with discrete transistors and later known as the Straight 8.DeveloperDigital Equipment CorporationProduct familyProgrammed Data ProcessorTypeMinicomputerRelease dateMarch 22, 1965; 60 years ago (1965-03-22)Introductory priceUS$18,500, equivalent to about $184,600 in 2024Units sold50,000+PlatformDEC 12-bitPredecessorPDP-5SuccessorPDP-12
The PDP-8 is a family of 12-bit minicomputers that was produced by Digital Equipment Corporation (DEC). It was the first commercially successful minicomputer, with over 50,000 units sold during the model's lifetime.[1] Its basic design follows the pioneering LINC but has a smaller instruction set, which is an expanded version of the PDP-5 instruction set.[2] Similar machines from DEC are the PDP-12 which is a modernized version of the PDP-8 and LINC concepts, and the PDP-14 industrial controller system.


Overview[edit]
An open PDP-8/E with its logic modules behind the front panel and one dual TU56 DECtape drive at the top
A "Straight-8" running at the Stuttgart Computer Museum
The earliest PDP-8 model, informally known as a "Straight-8", was introduced on 22 March 1965 priced at $18,500[3] (equivalent to about $184,600 in 2024[4]). It uses diode–transistor logic packaged on flip chip cards in a machine about the size of a small household refrigerator. It was the first computer to be sold for under $20,000,[5] making it the best-selling computer in history at that time.[6][failed verification][7][failed verification] The Straight-8 was supplanted in 1966 by the PDP-8/S, which was available in desktop and rack-mount models. Using a one-bit serial arithmetic logic unit (ALU) allowed the PDP-8/S to be smaller and less expensive, although slower than the original PDP-8. A basic 8/S sold for under $10,000, the first machine to reach that milestone.[5][8]
Later systems (the PDP-8/I and /L, the PDP-8/E, /F, and /M, and the PDP-8/A) returned to a faster, fully parallel implementation but use much less costly transistor–transistor logic (TTL) MSI logic. Most surviving PDP-8s are from this era. The PDP-8/E is common, and well-regarded because many types of I/O devices were available for it. The last commercial PDP-8 models introduced in 1979 are called "CMOS-8s", based on CMOS microprocessors. They were not priced competitively, and the offering failed. Intersil sold the integrated circuits commercially through 1982 as the Intersil 6100 family. By virtue of their CMOS technology they had low power requirements and were used in some embedded military systems.
The chief engineer who designed the initial version of the PDP-8 was Edson de Castro, who later founded Data General.[9]

Architectural significance[edit]
The PDP-8 combines low cost,[3] simplicity, expandability, and careful engineering for value. The greatest historical significance was that the PDP-8's low cost and high volume made a computer available to many new customers for many new uses. Its continuing significance is as a historical example of value-engineered[10] computer design.
The low complexity brought other costs. It made programming cumbersome, as is seen in the examples in this article and from the discussion of "pages" and "fields". Much of one's code performed the required mechanics, as opposed to setting out the algorithm. For example, subtracting a number involves computing its two's complement then adding it; writing a conditional jump involves writing a conditional skip around the jump, the skip coding the condition negative to the one desired. Some ambitious programming projects failed to fit in memory or developed design defects that could not be solved. For example, as noted below, inadvertent recursion of a subroutine produces defects that are difficult to trace to the subroutine in question.
As design advances reduced the costs of logic and memory, the programmer's time became relatively more important.[11] Subsequent computer designs emphasized ease of programming, typically using larger and more intuitive instruction sets.[12]
Eventually, most machine code was generated by compilers and report generators.[13] The reduced instruction set computer returned full-circle to the PDP-8's emphasis on a simple instruction set and achieving multiple actions in a single instruction cycle, in order to maximize execution speed, although the newer computers have much longer instruction words.

Description[edit]

PDP-8 registers





11

10

9

8

7

6

5

4

3

2

1

0

(bit position)


Main registers


AC

ACcumulator


MQ

Multiplier Quotient


Program counter


PC

Program Counter


Status flags


 

L

Link register


The PDP-8's predecessor, the PDP-5, shared many architectural features with the 18-bit PDP-4.[14] It also used ideas from several 12-bit predecessors such as the LINC designed by W.A. Clark and C.E. Molnar, who were inspired by Seymour Cray's CDC 160 minicomputer.[2][15]

PDP-8/e at the Living Computers Museum.
The PDP-8 uses 12 bits for its word size and arithmetic (on unsigned integers from 0 to 4095 or signed integers from −2048 to +2047). However, software can do multiple-precision arithmetic. An interpreter was available for floating point operations, for example, that uses a 36-bit floating point representation with a two-word (24-bit) significand (mantissa) and one-word exponent.[16] Subject to speed and memory limitations, the PDP-8 can perform calculations similar to more expensive contemporary electronic computers, such as the IBM 1130 and various models of the IBM System/360, while being easier to interface with external devices.
The memory address space is also 12 bits, so the PDP-8's basic configuration has a main memory of 4,096 (212) twelve-bit words, or 6 KiB in modern terms. An optional memory-expansion unit can switch banks of memories using an IOT instruction. The memory is magnetic-core memory with a cycle time of 1.5 microseconds (0.667 MHz), so that a typical two-cycle (Fetch, Execute) memory-reference instruction runs at a speed of 0.333 MIPS. The 1974 Pocket Reference Card for the PDP-8/E gives a basic instruction time of 1.2 microseconds, or 2.6 microseconds for instructions that reference memory.
The PDP-8 was designed in part to handle contemporary telecommunications and text. Six-bit character codes were in widespread use at the time, and the PDP-8's twelve-bit words can efficiently store two such characters. In addition, a six-bit teleprinter code called the teletypesetting or TTS code was in widespread use by the news wire services, and an early application for the PDP-8 was typesetting using this code.[17]
PDP-8 instructions have a three-bit opcode, so there are only eight major instructions. The programmer can use many additional instruction mnemonics, which the assembler translates to specific OPR or IOT instructions. The PDP-8 has only three programmer-visible registers: A 12-bit accumulator (AC), a program counter (PC), and a carry flag called the "link register" (L). Additional registers not visible to the programmer are a memory-buffer register and a memory-address register. To save money, these serve multiple purposes at different points in the operating cycle. For example, the memory buffer register provides arithmetic operands, is part of the instruction register, and stores data to rewrite the core memory, which is erased when read.
For input and output, the PDP-8 has a single interrupt shared by all devices, an I/O bus accessed by I/O instructions and a direct memory access (DMA) channel. The programmed I/O bus typically runs low to medium-speed peripherals, such as printers, teletypes, paper tape punches and readers, while DMA is used for cathode-ray tube screens with a light pen, analog-to-digital converters, digital-to-analog converters, tape drives, and disk drives.
To save money, the design uses inexpensive main memory for many purposes that are served by more expensive flip-flop registers in other computers,[18] such as auxiliary counters and subroutine linkage.
Basic models use software to do multiplication and division. For faster math, the Extended Arithmetic Element (EAE) provides multiply and divide instructions with an additional register, the Multiplier/Quotient (MQ) register. The EAE was an option on the original PDP-8,[19] the 8/I,[20] and the 8/E, but it is an integral part of the Intersil 6100 microprocessor.
The PDP-8 is optimized for simplicity of design. Compared to more complex machines, unnecessary features were removed and logic is shared when possible. Instructions use autoincrement, autoclear, and indirect access to increase the software's speed, reduce memory use, and substitute inexpensive memory for expensive registers.
Because of their simplicity, early PDP-8 models were less expensive than most other commercially available computers. However, they used costly production methods often used for prototypes. They used thousands of very small, standardized logic-modules, with gold connectors, integrated by a costly, complex wire-wrapped backplane in a large cabinet.
In the later 8/S model, introduced in August 1966,[8] two different logic voltages increased the fan-out of the inexpensive diode–transistor logic.[21] The 8/S also reduced the number of logic gates by using a serial, single-bit-wide data path to do arithmetic. The CPU of the PDP-8/S has only about 519 logic gates. In comparison, small microcontrollers (as of 2008) usually have 15,000 or more. The reductions in the electronics permitted a much smaller case, about the size of a bread-box. The 8/S was designed by Saul Dinman.[22]
The even later PDP-8/E is a larger, more capable computer, but further reengineered for better value. It employs faster transistor–transistor logic, in integrated circuits. The core memory was redesigned. It allows expansion with less expense because it uses the OMNIBUS in place of the wire-wrapped backplane on earlier models. (A personal account of the development of the PDP-8/E can be read on the Engineering and Technology History Wiki.[23])

Models[edit]
PDP-8/S front panelPDP-8/L front panelPDP-8/I front panelPDP-8/E front panelPDP-8/F front panelPDP-8/A 400 front panel
The total sales figure for the PDP-8 family has been estimated at over 300,000 machines.[24] The following models were manufactured:


PDP-8 models summary[25]


Model

Description

Year

Price

Quantity produced

Weight


PDP-8

Semi-discrete components.  Used some hybrid ICs.  DTL.

1965

$18,000

1450

250 pounds (113 kg)[26]


LINC-8

Could run either LINC or PDP-8 code

1966

$38,500

142




PDP-8/S

Lower-cost serial version of the PDP-8

1966

$10,000

1024

84 pounds (38 kg)[27]


PDP-8/I

First PDP-8 made out of standard TTL ICs

1968

$12,800

3698

250 pounds (110 kg)[28]


PDP-8/L

Lower-cost counterpart to the PDP-8/I

1968

$8,500

3902

80 pounds (36 kg)[29]


PDP-12

A PDP-8/I with support for LINC instructions (replaced the LINC-8)

1969

$27,900

755




PDP-8/E

Fewer, larger boards to improve price and efficiency

1970

$6,500



90 pounds (41 kg) (typical)[30]


PDP-8/F

Lower-cost counterpart to the PDP-8/E

1972





57 pounds (26 kg) (typical)[31]


PDP-8/M

An OEM PDP-8/F with altered front panel

1972

$5,000[32]



57 pounds (26 kg) (typical)[33]


PDP-8/A

LSI logic allowed the CPU to fit on a single board

1974

$1,835






Intersil 6100

Single-chip PDP-8-compatible microprocessor (used in the VT78)

1975[34][35]








Harris 6120

CMOS single-chip PDP-8-compatible microprocessor (used in the DECmate word processors)

1976[35]







Latter-day implementations[edit]
PiDP-8, a PDP-8/I replica based on a Raspberry Pi
The PDP-8 is readily emulated, as its instruction set is much simpler than modern architectures. Enthusiasts have created entire PDP-8s using single FPGA devices.
Several software simulations of a PDP-8 are available on the Internet, as well as open-source hardware re-implementations. The best of these correctly execute DEC's operating systems and diagnostic software. The software simulations often simulate late-model PDP-8s with all possible peripherals. Even these use only a tiny fraction of the capacity of a modern personal computer.
One of the first commercial versions of a PDP-8/S virtual machine ran on a Kaypro 386 (an 80386-based computer) and was written in the C computer language (before the ANSI-C standard was finalized) and assembler by David Beecher of Denver, Colorado.  It replaced a failing PDP-8/S computer that operated the fuel handling machine at Reactor #85, the Platteville, Colorado Nuclear Fuel powered Electric Generating Station, Ft. St. Vrain.  It was reviewed by Rockwell International and performed flawlessly for 2.5 years during the operation of the Fuel Handling Machine while it was used to remove fuel from the reactor core and decommission the plant.  It included a simulated paper tape loader and front panel.

Input/output[edit]
The I/O systems underwent huge changes during the PDP-8 era. Early PDP-8 models use a front panel interface, a paper-tape reader and a teletype printer with an optional paper-tape punch. Over time, I/O systems such as magnetic tape, RS-232 and current loop dumb terminals, punched card readers, and fixed-head disks were added. Toward the end of the PDP-8 era, floppy disks and moving-head cartridge disk drives were popular I/O devices. Modern enthusiasts have created standard PC style IDE hard disk adapters for real and simulated PDP-8 computers.
Several types of I/O are supported:

In-backplane dedicated slots for I/O controllers
A "Negative" I/O bus (using negative voltage signalling)
A "Positive" I/O bus (the same architecture using TTL signalling)
The Omnibus (a backplane of undedicated system bus slots) introduced in the PDP-8/E. (Details are described in the referenced IEEE article listed below.)
A simplified, inexpensive form of DMA called "three-cycle data break" is supported; this requires the assistance of the processor. The "data break" method moves some of common logic needed to implement DMA I/O from each I/O device into one common copy of the logic within the processor. "Data break" places the processor in charge of maintaining the DMA address and word count registers. In three successive memory cycles, the processor updates the word count, updates the transfer address, and stores or retrieves the actual I/O data word.
One-cycle data break effectively triples the DMA transfer rate because only the target data needed to be transferred to and from the core memory. However, the I/O devices need more electronic logic to manage their own word count and transfer address registers. By the time the PDP-8/E was introduced, electronic logic had become less expensive and "one-cycle data break" became more popular.

Programming facilities[edit]
Early PDP-8 systems were shipped with no pre-installed software; each time the PDP-8 was powered up, the user hand-entered instructions using a bank of 12 toggle switches. Typically, these instructions were a bootstrap loader to read a program from the paper tape reader. Program development could then proceed, using paper tape input and output.
Paper-tape versions of a number of programming languages became available, including DEC's FOCAL interpreter[36] and a 4K FORTRAN compiler and runtime.
Toward the end of the PDP-8 era, operating systems such as OS/8 and COS-310 allowed a traditional line mode editor and command-line compiler development system using languages such as PAL-III assembly language, FORTRAN, BASIC, and DIBOL.
Fairly modern and advanced real-time operating system (RTOS) and preemptive multitasking multi-user systems were available: a real-time system (RTS-8) was available as were multiuser commercial systems (COS-300 and COS-310) and a dedicated single-user word-processing system (WPS-8).
A time-sharing system, TSS-8, was also available. TSS-8 allows multiple users to log into the system via 110-baud terminals, and edit, compile and debug programs. Languages include a special version of BASIC, a FORTRAN subset similar to FORTRAN-1 (no user-written subroutines or functions), an ALGOL subset, FOCAL, and an assembler called PAL-D.
A fair amount of user-donated software for the PDP-8 was available from DECUS, the Digital Equipment Corporation User Society, and often came with full source listings and documentation.

Instruction set[edit]
The three high-order bits of the 12-bit instruction word (labelled bits 0 through 2) are the operation code. For the six operations that refer to memory, bits 5 through 11 provide a seven-bit address. Bit 4, if set, says to complete the address using the five high-order bits of the program counter (PC) register, meaning that the addressed location was within the same 128 words as the instruction. If bit 4 is clear, zeroes are used, so the addressed location is within the first 128 words of memory. Bit 3 specifies indirection; if set, the address obtained as described so far points to a 12-bit value in memory that gives the actual effective address for the instruction; this way, operands can be anywhere in memory at the expense of an additional word. The JMP instruction does not operate on a memory word, except if indirection is specified, but has the same bit fields.



0



2

3

4

5











11


Operation

I

Z

Offset

Memory pages
This use of the instruction word divides the 4,096-word memory into 128-word pages; bit 4 of the instruction selects either the current page or page 0 (addresses 0000–0177 in octal). Memory in page 0 is at a premium, since variables placed here can be addressed directly from any page. (Moreover, address 0000 is where any interrupt service routine must start, and addresses 0010–0017 have the special property of auto-incrementing preceding any indirect reference through them.)
The standard assembler places constant values for arithmetic in the current page. Likewise, cross-page jumps and subroutine calls use an indirect address in the current page.
It was important to write routines to fit within 128-word pages, or to arrange routines to minimize page transitions, as references and jumps outside the current page require an extra word. Consequently, much time was spent cleverly conserving one or several words. Programmers deliberately placed code at the end of a page to achieve a free transition to the next page as PC was incremented.

Basic instructions[edit]
000 – AND – AND the memory operand with AC.
001 – TAD – Two's complement ADd the memory operand to <L,AC> (a 12 bit signed value (AC) w. carry in L).
010 – ISZ – Increment the memory operand and Skip next instruction if result is Zero.
011 – DCA – Deposit AC into the memory operand and Clear AC.
100 – JMS – JuMp to Subroutine (storing return address in first word of subroutine!).
101 – JMP – JuMP.
110 – IOT – Input/Output Transfer (see below).
111 – OPR – microcoded OPeRations (see below).
IOT (Input-Output Transfer) instructions[edit]
The PDP-8 processor defined few of the IOT instructions, but simply provided a framework. Most IOT instructions were defined by the individual I/O devices.



0



2

3









8

9



11


6=IOT

Device

Function

Device
Bits 3 through 8 of an IOT instruction select an I/O device. Some of these device addresses are standardized by convention:

00 is handled by the processor and not sent to any I/O device (see below).
01 is usually the high-speed paper tape reader.
02 is the high-speed paper tape punch.
03 is the console keyboard (and any associated low-speed paper tape reader).
04 is the console printer (and any associated low-speed paper tape punch).
Instructions for device 0 affect the processor as a whole. For example, ION (6001) enables interrupt processing, and IOFF (6002) disables it.

Function
Bits 9 through 11 of an IOT instruction select the function(s) the device performs. Simple devices (such as the paper tape reader and punch and the console keyboard and printer) use the bits in standard ways:

Bit 11 causes the processor to skip the next instruction if the I/O device is ready.
Bit 10 clears AC.
Bit 9 moves a word between AC and the device, initiates another I/O transfer, and clears the device's "ready" flag.
These operations take place in a well-defined order that gives useful results if more than one bit is set.
More complicated devices, such as disk drives, use these 3 bits in device-specific fashions. Typically, a device decodes the 3 bits to give 8 possible function codes.

OPR (OPeRate)[edit]
Many operations are achieved using OPR, including most of the conditionals. OPR does not address a memory location; conditional execution is achieved by conditionally skipping the following instruction, which is typically a JMP.
The OPR instruction was said to be "microcoded." This did not mean what the word means today (that a lower-level program fetched and interpreted the OPR instruction), but meant that each bit of the instruction word specifies a certain action, and the programmer could achieve several actions in a single instruction cycle by setting multiple bits. In use, a programmer can write several instruction mnemonics alongside one another, and the assembler combines them with OR to devise the actual instruction word. Many I/O devices support "microcoded" IOT instructions.
Microcoded actions take place in a well-defined sequence designed to maximize the utility of many combinations.
The OPR instructions come in Groups. Bits 3, 8 and 11 identify the Group of an OPR instruction, so it is impossible to combine the microcoded actions from different groups.
One action (and corresponding bit) which is the same in all groups is bit 4, CLA.  If set, the accumulator is cleared.

Group 1[edit]
        00 01 02 03 04 05 06 07 08 09 10 11
        ___________________________________
       | 1| 1| 1| 0|  |  |  |  |  |  |  |  |
       |__|__|__|__|__|__|__|__|__|__|__|__|
                   |CLA   CMA   RAR   BSW
                       CLL   CML   RAL   IAC

    Execution order  1  1  2  2  4  4  4  3

7200 – CLA – Clear Accumulator
7100 – CLL – Clear the L Bit
7040 – CMA – Ones Complement Accumulator
7020 – CML – Complement L Bit
7001 – IAC – Increment <L,AC>
7010 – RAR – Rotate <L,AC> Right
7004 – RAL – Rotate <L,AC> Left
7012 – RTR – Rotate <L,AC> Right Twice
7006 – RTL – Rotate <L,AC> Left Twice
7002 – BSW – Byte Swap 6-bit "bytes" (PDP 8/e and up)
In most cases, the operations are sequenced so that they can be combined in the most useful ways. For example, combining CLA (CLear Accumulator), CLL (CLear Link), and IAC (Increment ACcumulator) first clears the AC and Link, then increments the accumulator, leaving it set to 1. Adding RAL to the mix (so CLA CLL IAC RAL) causes the accumulator to be cleared, incremented, then rotated left, leaving it set to 2. In this way, small integer constants were placed in the accumulator with a single instruction.
The combination CMA IAC, which the assembler lets you abbreviate as CIA, produces the arithmetic inverse of AC: the twos-complement negation. Since there is no subtraction instruction, only the twos-complement add (TAD), computing the difference of two operands, requires first negating the subtrahend.
A Group 1 OPR instruction that has none of the microprogrammed bits set performs no action. The programmer can write NOP (No Operation) to assemble such an instruction.

Group 2, Or Group[edit]
         00 01 02 03 04 05 06 07 08 09 10 11
        ___________________________________
       | 1| 1| 1| 1|  |  |  |  | 0|  |  | 0|
       |__|__|__|__|__|__|__|__|__|__|__|__|
                   |CLA   SZA      OSR
                       SMA   SNL      HLT

                     2  1  1  1     3  3

7600 – CLA – Clear AC
7500 – SMA – Skip on AC < 0 (or group)
7440 – SZA – Skip on AC = 0 (or group)
7420 – SNL – Skip on L ≠ 0 (or group)
7404 – OSR – logically 'or' front-panel switches with AC
7402 – HLT – Halt
Three of the bits (CLA, OSR, HLT) perform actions if set.  Another three bits (SMA, SZA, SNL) encode skip conditions; a skip is performed if any of the specified conditions are true.  For example, "SMA SZA", opcode 7540, skips if AC ≤ 0.
A Group 2 OPR instruction that has none of the microprogrammed bits set is another No-Op instruction.

Group 2, And Group[edit]
         00 01 02 03 04 05 06 07 08 09 10 11
        ___________________________________
       | 1| 1| 1| 1|  |  |  |  | 1|  |  | 0|
       |__|__|__|__|__|__|__|__|__|__|__|__|
                   |CLA   SNA      OSR
                       SPA   SZL      HLT

                     2  1  1  1     3  2

7410 – SKP – Skip Unconditionally
7610 – CLA – Clear AC
7510 – SPA – Skip on AC ≥ 0 (and group)
7450 – SNA – Skip on AC ≠ 0 (and group)
7430 – SZL – Skip on L = 0 (and group)
When bit 8 is set, the Group 2 skip condition is inverted; the skip is not performed if any of the or group conditions are true.  By De Morgan's laws, this means that the skip is performed if all of the specified inverted conditions are true.  For example, "SPA SNA", opcode 7550, skips if AC > 0. If none of bits 5–7 are set, then the skip is unconditional.
The actions (CLA, OSR, HLT) are not affected by bit 8.

Group 3[edit]
Unused bit combinations of OPR are defined as a third Group of microprogrammed actions mostly affecting the MQ (Multiplier/Quotient) register.  The MQ register and the extended arithmetic element (EAE) instructions are optional and only exist when EAE option was purchased.[37]

        00 01 02 03 04 05 06 07 08 09 10 11
        ___________________________________
       | 1| 1| 1| 1|  |  |  |  |  |  |  | 1|
       |__|__|__|__|__|__|__|__|__|__|__|__|
                   |CLA   SCA   \_    _/
                   |   MQA   MQL  CODE

                     1* 2  2  2     3

7601 – CLA – Clear AC
7501 – MQA – Multiplier Quotient with AC (logical or MQ into AC)
7441 – SCA – Step counter load into AC
7421 – MQL – Multiplier Quotient Load (Transfer AC to MQ, clear AC)
7621 – CAM – CLA + MQL clears both AC and MQ.
Typically CLA and MQA were combined to transfer MQ into AC. Another useful combination is MQA and MQL, to exchange the two registers.
Three bits specified a multiply/divide instruction to perform:

7401 – No operation
7403 – SCL – Step Counter Load (immediate word follows, PDP-8/I and up)
7405 – MUY – Multiply
7407 – DVI – Divide
7411 – NMI – Normalize
7413 – SHL – Shift left (immediate word follows)
7415 – ASR – Arithmetic shift right
7417 – LSR – Logical shift right
Memory control[edit]
PDP-8/I core memory stack
One of three inter-connected modules that make up a PDP-8 core memory plane.
One of three inter-connected modules that make up a PDP-8 core memory plane.  This is the middle of the three and contains the array of actual ferrite cores.
One of three inter-connected modules that make up a PDP-8 core memory plane.
A 12-bit word can have 4,096 different values, and this is the maximum number of words the original PDP-8 can address indirectly through a word pointer. 4,096 12-bit words represent 6,144 bytes in modern terminology, or 6 kB. As programs became more complex and the price of memory fell, it became desirable to expand this limit.
To maintain compatibility with pre-existing programs, new hardware outside the original design added high-order bits to the effective addresses generated by the program. The Memory Extension Controller expands the addressable memory by a factor of 8, to a total of 32,768 words. This expansion was thought sufficient because, with core memory then costing about 50 cents a word, a full 32K of memory would equal the cost of the CPU.
Each 4K of memory is called a field. The Memory Extension Controller contains two three-bit registers: the DF (Data Field) and the IF (Instruction Field). These registers specify a field for each memory reference of the CPU, making a total of 15 bits of address. The IF register specifies the field for instruction fetches and direct memory references; the DF register specifies the field for indirect data accesses. A program running in one field can reference data in the same field by direct addressing, and reference data in another field by indirect addressing.
A set of I/O instructions in the range 6200 through 6277 is handled by the Memory Extension Controller and give access to the DF and IF registers. The 62X1 instruction (CDF, Change Data Field) set the data field to X. Similarly 62X2 (CIF) set the instruction field, and 62X3 set both. Pre-existing programs would never execute CIF or CDF; the DF and IF registers would both point to the same field, a single field to which these programs were limited. The effect of the CIF instruction was deferred to coincide with the next JMP or JMS instruction, so that executing CIF would not cause a jump.
It was more complicated for multiple-field programs to deal with field boundaries and the DF and IF registers than it would have been if they could simply generate 15-bit addresses, but the design provided backward compatibility and is consistent with the 12-bit architecture used throughout the PDP-8. Compare the later Intel 8086, whose 16-bit memory addresses are expanded to 20 bits by combining them with the contents of a specified or implied segment register.
The extended memory scheme let existing programs handle increased memory with minimal changes. For example, 4K FOCAL normally had about 3K of code with only 1K left over for user program and data. With a few patches, FOCAL could use a second 4K field for user program and data. Moreover, additional 4K fields could be allocated to separate users, turning 4K FOCAL into a multi-user timesharing system.

Virtualization
On the PDP-8/E and later models, the Memory Extension Controller was enhanced to enable machine virtualization. A program written to use a PDP-8's entire resources can coexist with other such programs on the same PDP-8 under the control of a virtual machine manager. The manager can make all I/O instructions (including those that operated on the Memory Extension Controller) cause a trap (an interrupt handled by the manager). In this way, the manager can map memory references, map data or instruction fields, and redirect I/O to different devices. Each original program has complete access to a "virtual machine" provided by the manager.
New I/O instructions to the Memory Extension Controller retrieve the current value of the data and instruction fields, letting software save and restore most of the machine state across a trap. However, a program can not sense whether the CPU is in the process of deferring the effect of a CIF instruction (whether it has executed a CIF and not yet executed the matching jump instruction). The manager has to include a complete PDP-8 emulator (not difficult for an 8-instruction machine). Whenever a CIF instruction traps to the manager, it has to emulate the instructions up to the next jump. Fortunately, as a jump usually is the next instruction after CIF, this emulation does not slow programs down much, but it is a large workaround to a seemingly small design deficiency.[citation needed]
By the time of the PDP-8/A, memory prices had fallen enough that memory exceeding 32K was desirable. The 8/A added a new set of instructions for handling more than eight fields of memory. The field number could now be placed in the AC, rather than hard-coded into the instruction. However, by this time, the PDP-8 was in decline, so very little standard software was modified to use these new features.

Examples[edit]
The following examples show code in PDP-8 assembly language as one might write for the PAL-III assembler.

Comparing two numbers[edit]
The following piece of code shows what is needed just to compare two numbers:

    /Compare numbers in memory at OPD1 and OPD2
            CLA CLL     /Must start with 0 in AC and link
            TAD OPD1    /Load first operand into AC (by adding it to 0); link is still clear
            CIA         /Complement, then increment AC, negating it
            TAD OPD2    /AC now has OPD2-OPD1; if OPD2≥OPD1, sum overflows and link is set
            SZL         /Skip if link is clear
            JMP OP2GT   /Jump somewhere in the case that OPD2≥OPD1;
                        /Otherwise, fall through to code below.

As shown, much of the text of a typical PDP-8 program focuses not on the author's intended algorithm but on low-level mechanics. An additional readability problem is that in conditional jumps such as the one shown above, the conditional instruction (which skips around the JMP) highlights the opposite of the condition of interest.

String output[edit]
This complete PDP-8 assembly language program outputs "Hello, world!" to the teleprinter.

    *10                   / Set current assembly origin to address 10,
    STPTR,    STRNG-1     / An auto-increment register (one of eight at 10-17)

    *200                  / Set current assembly origin to program text area
    HELLO,  CLA CLL       / Clear AC and Link again (needed when we loop back from tls)
            TAD I Z STPTR / Get next character, indirect via PRE-auto-increment address from the zero page
            SNA           / Skip if non-zero (not end of string)
            HLT           / Else halt on zero (end of string)
            TLS           / Output the character in the AC to the teleprinter
            TSF           / Skip if teleprinter ready for character
            JMP .-1       / Else jump back and try again
            JMP HELLO     / Jump back for the next character

    STRNG,  310           / H
            345           / e
            354           / l
            354           / l
            357           / o
            254           /,
            240           / (space)
            367           / w
            357           / o
            362           / r
            354           / l
            344           / d
            241           / !
            0             / End of string
    $HELLO                /DEFAULT TERMINATOR

Subroutines[edit]
The PDP-8 processor does not implement a stack upon which to store registers or other context when a subroutine is called or an interrupt occurs. (A stack can be implemented in software, as demonstrated in the next section.) Instead, the JMS instruction simply stores the updated PC (pointing past JMS, to the return address) at the effective address and jumps to the effective address plus one. The subroutine returned to its caller using an indirect JMP instruction that addresses the subroutine's first word.
For example, here is "Hello, World!" re-written to use a subroutine. When the JMS instruction jumps to the subroutine, it modifies the 0 coded at location OUT1:

    *10                     / Set current assembly origin to address 10,
    STPTR,  STRNG-1         / An auto-increment register (one of eight at 10-17)

    *200                    / Set assembly origin (load address)
    LOOP,   TAD I STPTR     / Pre-increment mem location 10, fetch indirect to get the next character of our message
            SNA             / Skip on non-zero AC
            HLT             / Else halt at end of message
            JMS OUT1        / Write out one character
            JMP LOOP        / And loop back for more
    OUT1,   0               / Will be replaced by caller's updated PC
            TSF             / Skip if printer ready
            JMP .-1         / Wait for flag
            TLS             / Send the character in the AC
            CLA CLL         / Clear AC and Link for next pass
            JMP I OUT1      / Return to caller
    STRNG, "H               / A well-known message
           "e               /
           "l               / NOTE:
           "l               /
           "o               /   Strings in PAL-8 and PAL-III were "sixbit"
           ",               /   To use ASCII, we spell it out, character by character
           "                /
           "w               /
           "o               /
           "r               /
           "l               /
           "d               /
           "!               /
           015              /
           012              /
           0                / Mark the end of our null-terminated string (.ASCIZ hadn't been invented yet!)

The fact that the JMS instruction uses the word just before the code of the subroutine to deposit the return address prevents reentrancy and recursion without additional work by the programmer. It also makes it difficult to use ROM with the PDP-8 because read-write return-address storage is commingled with read-only code storage in the address space. Programs intended to be placed into ROMs approach this problem in several ways:

They copy themselves to read-write memory before execution, or
They are placed into special ROM cards that provide a few words of read/write memory, accessed indirectly through the use of a thirteenth flag bit in each ROM word.
They avoid the use of subroutines; or use code such as the following, instead of the JMS instruction, to put the return address in read-write memory:
    JUMPL, DCA TEMP         / Deposit the accumulator in some temporary location
           TAD JUMPL+3      / Load the return address into the accumulator: hard coded
           JMP SUBRO        / Go to the subroutine, and have it handle jumping back (to JUMPL+3)

The use of the JMS instruction makes debugging difficult. If a programmer makes the mistake of having a subroutine call itself, directly or by an intermediate subroutine, then the return address for the outer call is destroyed by the return address of the subsequent call, leading to an infinite loop. If one module is coded with an incorrect or obsolete address for a subroutine, it would not just fail to execute the entire code sequence of the subroutine, it might modify a word of the subroutine's code, depositing a return address that the processor might interpret as an instruction during a subsequent correct call to the subroutine. Both types of error might become evident during the execution of code that was written correctly.

Software stack[edit]
Though the PDP-8 does not have a hardware stack, stacks can be implemented in software.[38]
Here are example PUSH and POP subroutines, simplified to omit issues such as testing for stack overflow and underflow:

    *100              /make routines accessible for next example
    PUSH, 0
          DCA DATA
          CLA CMA     / -1
          TAD SP
          DCA SP
          TAD DATA
          DCA I SP
          JMP I PUSH     /Return

    POP,  0
          CLA CLL
          TAD I SP
          ISZ SP
          JMP I POP

    DATA, 0
    SP, 0

And here is "Hello World" with this "stack" implemented, and "OUT" subroutine:

    *200
    MAIN,  CLA CLL         /Set the message pointer
           TAD (MESSG      /To the beginning of the message (literal)
           DCA SP

    LOOP,  JMS POP
           SNA             /Stop execution if zero
           HLT
           JMS OUT         /Otherwise, output a character
           JMP LOOP

    MESSG, "H
           "e
           "l
           "l
           "o
           ",
           "
           "w
           "o
           "r
           "l
           "d
           "!
           015
           012
           0

    OUT,    0               / Will be replaced by caller's updated PC
            TSF             / Skip if printer ready
            JMP .-1         / Wait for flag
            TLS             / Send the character in the AC
            CLA CLL         / Clear AC and Link for next pass
            JMP I OUT       / Return to caller

Linked list[edit]
Another possible subroutine for the PDP-8 is a linked list.

     GETN, 0     /Gets the number pointed to and moves the pointer
     CLA CLL     /Clear accumulator
     TAD I PTR   /Gets the number pointed to
     DCA TEMP    /Save current value
     ISZ PTR     /Increment pointer
     TAD I PTR   /Get next address
     DCA PTR     /Put in pointer
     JMP I GETN  /return
     PTR,  0
     TEMP, 0

Interrupts[edit]
There is a single interrupt line on the PDP-8 I/O bus. The processor handles any interrupt by disabling further interrupts and executing a JMS to location 0000. As it is difficult to write reentrant subroutines, it is difficult to nest interrupts and this is usually not done; each interrupt runs to completion and re-enables interrupts just before executing the JMP I 0 instruction that returns from the interrupt.
Because there is only a single interrupt line on the I/O bus, the occurrence of an interrupt does not inform the processor of the source of the interrupt. Instead, the interrupt service routine has to serially poll each active I/O device to see if it is the source. The code that does this is called a skip chain because it consists of a series of PDP-8 "test and skip if flag set" I/O instructions. (It was not unheard-of for a skip chain to reach its end without finding any device in need of service.) The relative interrupt priority of the I/O devices is determined by their position in the skip chain: If several devices interrupt, the device tested earlier in the skip chain is serviced first.

Books[edit]
An engineering textbook popular in the 1980s, The Art of Digital Design by David Winkel and Franklin Prosser, contains an example problem spanning several chapters in which the authors demonstrate the process of designing a computer that is compatible with the PDP-8/I. The function of every component is explained. Although it is not a production design, as it uses more modern SSI and MSI components and solid state rather than core memory, the exercise provides a detailed description of the computer's operation.

Unlicensed clones[edit]
The USSR produced the minicomputers Saratov-1 and Saratov-2, which cloned the PDP-8 and PDP-8/E, respectively.
There was a minicomputer named IZOT-0310, produced in Bulgaria in 70s and 80s, which cloned PDP-8L.
In Cuba, the Instituto Central de Investigación Digital (ICID), now COMBIOMED, produced in the 70s the minicomputers CID-201, CID 201-A and CID 201-B, partial clones (architecture and instructions) of PDP-8/S and PDP-8/L.

References[edit]


^ "Early Computing at the NIH - Office of NIH History and Stetten Museum". history.nih.gov. Retrieved 2024-07-17.

^ a b "PDP-8 Summary of Models and Options". Section - What is a PDP-5.

^ a b Douglas W. Jones. "The Digital Equipment Corporation PDP-8 -- Frequently Asked Questions".

^ 1634–1699: McCusker, J. J. (1997). How Much Is That in Real Money? A Historical Price Index for Use as a Deflator of Money Values in the Economy of the United States: Addenda et Corrigenda (PDF). American Antiquarian Society. 1700–1799: McCusker, J. J. (1992). How Much Is That in Real Money? A Historical Price Index for Use as a Deflator of Money Values in the Economy of the United States (PDF). American Antiquarian Society. 1800–present: Federal Reserve Bank of Minneapolis. "Consumer Price Index (estimate) 1800–". Retrieved February 29, 2024.

^ a b Schein, Edgar H. (2004). DEC is dead, long live DEC: the lasting legacy of Digital Equipment Corporation. San Francisco, Calif.: Berrett-Koehler Publishers. p. 271. ISBN 1576753050.

^ Douglas W. Jones. "The Digital Equipment Corporation PDP-8".

^ "PDP-8 1965". History Wired. Smithsonian Institution. 16 March 2012. Archived from the original on 2015-02-17. Retrieved February 17, 2015.

^ a b "PDP-8/S #1". Rhode Island Computer Museum. Aug 18, 2020. Archived from the original on 2021-02-26. Retrieved May 7, 2021.

^ Glenn Rifkin; George Harrar (1988). The ultimate entrepreneur: the story of Ken Olsen and Digital Equipment Corporation. Contemporary Books. ISBN 978-1-55958-022-9.

^ Small Computer Handbook, NEW PDP 8/I edition (Forward). Digital Equipment Corporation. 1968.

^ "Benchmarking the Languages". PC Magazine. Vol. 4, no. 22. October 29, 1985. p. 112. the best use of today's most precious computer resource: a programmer's time ...

^ a phrase used in Section 1.1 of "Introduction to the Central Processing Unit (CPU)" of a 2007 document about a Texas Instruments microcomputer."TMS320C28x CPU and Instruction Set (Rev. F)" (PDF).

^ Torben Ægidius Mogensen (August 20, 2010). Basics of Compiler Design (PDF). p. 1. Another advantage of using a high-level level language is that the same program can be compiled to many different machine languages and, hence, be brought to run on many different machines.

^ Gordon Bell (1962). Programmed Data Procesor - 4 Technical Specification (PDF). Digital Equipment Corporation.

^ C. Gordon Bell; J. C. Mudge; J. E. McNamara (1978). Computer Engineering: A DEC View of Hardware Systems Design (PDF). Digital Press. pp. 175, 178-179. ISBN 0-932376-00-2.

^ PDP-8 Floating-Point System Programmers Reference Manual (PDF). Digital Equipment Corporation. September 1969. DEC-08-YQYB-D.

^ "PDP-8 Typesetting System" (PDF). Digital Equipment Corporation. 1965.

^ C. Gordon Bell, et al.; Computer Structures, Principles and Organization, 1982, PDP-8 chapter

^ "Chapter 8: Extended Arithmetic Element Type 182". PDP-8 User's Handbook. Digital Equipment Corporation. 1966. p. 41.

^ "Chapter 4: System Description and Operation". Introduction to Programming (PDF). Digital Equipment Corporation. 1969. pp. 4–22.

^ PDP-8/S Maintenance Manual. Digital Equipment Corporation. 1971.

^ "PDP -8/S". PDP-8 Technology Before The Millennium. Archived from the original on 2000-10-23. Retrieved 2021-05-13.

^ Remo J. Vogelsang (2013). "First-Hand:PDP-8/E OMNIBUS Ride".

^ "Doug Jones's DEC PDP-8 FAQs". homepage.cs.uiowa.edu. Retrieved 2024-03-24.

^ "PDP-8 Summary of Models and Options (posted every other month)". www.faqs.org.

^ "PDP-8 - A High Speed Digital Computer" (PDF). 1965. p. 18.

^ PDP-8/S Maintenance Manual (PDF) (5th ed.). October 1970. p. 1-2.

^ "Table 11. Installation data". Small Computer Handbook (PDF) (1967-68 ed.). 1968. p. 290 (300).

^ "Table 13-1 Installation data". Small Computer Handbook (PDF) (1970 ed.). 1970. p. 277 (291).

^ "PDP-8 Family Specifications". PDP-8/e/f/m Sales Brochure (PDF). p. 17.

^ "PDP-8 Family Specifications". PDP-8/e/f/m Sales Brochure (PDF). p. 17.

^ "System Source Computer Museum: PDP-8M".

^ "PDP-8 Family Specifications". PDP-8/e/f/m Sales Brochure (PDF). p. 17.

^ "The Explosion 1975-1976 » AntiqueTech". AntiqueTech.com. 2009-04-21. Archived from the original on 2017-07-03. Retrieved 2017-06-19.

^ a b Bell, Gordon (1980), Family Tree of Digital's Computers, (Poster), Digital Equipment Corporation, retrieved 2017-06-19

^ FOCAL Programming Manual for PDP-8, PDP-8/S, PDP-8/I, LAB-8, LINC-8 (PDF). Digital Equipment Corporation. 1968. DEC-08-AJAB-D.

^ Small Computer Handbook 1967–1968. Digital Equipment Corporation. 1968. pp. 130–136.

^ 
Mark Smotherman.
"DEC PDP-8 Subroutines".
2002.



C. Gordon Bell and Allen Newell, 1971, Computer Structures: Readings and Examples, McGraw-Hill Book Company, New York. Chapter 5 The DEC PDP-8, pages 120–136. With enough detail that an electrical engineer could build one (if able to find the parts).

External links[edit]



Wikimedia Commons has media related to PDP-8.

pdp-8 Documentation: The Small Computer Handbook (1966 Edition), Sections 1 and 2 and others are available from Simon Fraser University
"PDP-8 Frequently Asked Questions". Internet FAQ Archives. 27 March 2014. Retrieved 2018-12-16.
The Digital Equipment Corporation PDP-8, 1965 – Computer History Collection from the Smithsonian
Digital Equipment Corporation's PDP-8 Steve Gibson's explanation on how the PDP-8 works and how to program it.
vteDigital Equipment Corporation computersPDP
18-bit
PDP-1
PDP-4
PDP-7
PDP-9
PDP-15
12-bit
LINC
LINC-8
PDP-5
PDP-8
PDP-8/e
PDP-12
DECmate
PDP-14


36-bit
PDP-6
PDP-10
DECSYSTEM-20
16-bit
PDP-11
DEC Professional

VAX
VAX-11
MicroVAX
VAX 8000
VAXstation
Firefly
VAXserver
VAX 6000
VAX 4000
VAX 9000
VAXft
VAX 7000 and VAX 10000
x86
Rainbow 100
VAXmate
DECpc
DECstation
Multia
Digital Personal Workstation
HiNote
MIPS
DECstation
DECsystem servers
Alpha
DEC 3000 AXP
DEC 4000 AXP
DEC 7000 AXP and DEC 10000 AXP
DECpc AXP 150
DEC 2000 AXP
Multia
AlphaServer
AlphaStation
Digital Personal Workstation
See also
Compaq Professional Workstation 1000 XP
Itsy Pocket Computer
Jupiter project
List of VAX computers

 Company template
 Category
 Commons

Authority control databases: National United StatesIsrael




Retrieved from "https://en.wikipedia.org/w/index.php?title=PDP-8&oldid=1282790576"
Categories: DEC minicomputersTransistorized computers12-bit computersComputer-related introductions in 1965Serial computersHidden categories: Articles with short descriptionShort description is different from WikidataAll articles with failed verificationArticles with failed verification from October 2019All articles with unsourced statementsArticles with unsourced statements from February 2016Commons category link from Wikidata






 This page was last edited on 28 March 2025, at 16:43 (UTC).
Text is available under the Creative Commons Attribution-ShareAlike 4.0 License;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.


Privacy policy
About Wikipedia
Disclaimers
Contact Wikipedia
Code of Conduct
Developers
Statistics
Cookie statement
Mobile view














Search













Search









Toggle the table of contents







PDP-8




























19 languages


Add topic
















