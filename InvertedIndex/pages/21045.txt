https://en.wikipedia.org/wiki/Real-time_operating_system




Real-time operating system - Wikipedia



























Jump to content







Main menu





Main menu
move to sidebar
hide



		Navigation
	


Main pageContentsCurrent eventsRandom articleAbout WikipediaContact us





		Contribute
	


HelpLearn to editCommunity portalRecent changesUpload fileSpecial pages



















Search











Search






















Appearance
















Donate

Create account

Log in








Personal tools





Donate Create account Log in





		Pages for logged out editors learn more



ContributionsTalk




























Contents
move to sidebar
hide




(Top)





1
Characteristics








2
Design philosophies








3
Scheduling




Toggle Scheduling subsection





3.1
Algorithms










4
Intertask communication and resource sharing




Toggle Intertask communication and resource sharing subsection





4.1
Temporarily masking/disabling interrupts








4.2
Mutexes








4.3
Message passing










5
Interrupt handlers and the scheduler








6
Memory allocation








7
See also








8
References


















Toggle the table of contents







Real-time operating system



36 languages




العربيةБеларускаяБългарскиBosanskiCatalàČeštinaDanskDeutschEestiEspañolفارسیFrançais한국어Հայերենहिन्दीItalianoҚазақшаLietuviųNederlands日本語Norsk bokmålNorsk nynorskPolskiPortuguêsRomânăРусскийසිංහලSimple EnglishSuomiSvenskaதமிழ்ไทยTürkçeУкраїнськаTiếng Việt中文

Edit links











ArticleTalk





English

















ReadEditView history







Tools





Tools
move to sidebar
hide



		Actions
	


ReadEditView history





		General
	


What links hereRelated changesUpload filePermanent linkPage informationCite this pageGet shortened URLDownload QR code





		Print/export
	


Download as PDFPrintable version





		In other projects
	


Wikimedia CommonsWikidata item





















Appearance
move to sidebar
hide










From Wikipedia, the free encyclopedia


Computer operating system for applications with critical timing constraints
A real-time operating system (RTOS) is an operating system (OS) for real-time computing applications that processes data and events that have critically defined time constraints. A RTOS is distinct from a time-sharing operating system, such as Unix, which manages the sharing of system resources with a scheduler, data buffers, or fixed task prioritization in multitasking or multiprogramming environments. All operations must verifiably complete within given time and resource constraints or else fail safe. Real-time operating systems are event-driven and preemptive, meaning the OS can monitor the relevant priority of competing tasks, and make changes to the task priority.


Characteristics[edit]
A key characteristic of an RTOS is the level of its consistency concerning the amount of time it takes to accept and complete an application's task; the variability is "jitter".[1] A "hard" real-time operating system (hard RTOS) has less jitter than a "soft" real-time operating system (soft RTOS); a late answer is a wrong answer in a hard RTOS while a late answer is acceptable in a soft RTOS. The chief design goal is not high throughput, but rather a guarantee of a soft or hard performance category. An RTOS that can usually or generally meet a deadline is a soft real-time OS, but if it can meet a deadline deterministically it is a hard real-time OS.[2]
An RTOS has an advanced algorithm for scheduling. Scheduler flexibility enables a wider, computer-system orchestration of process priorities, but a real-time OS is more frequently dedicated to a narrow set of applications. Key factors in a real-time OS are minimal interrupt latency and minimal thread switching latency; a real-time OS is valued more for how quickly or how predictably it can respond than for the amount of work it can perform in a given period of time.[3]

Design philosophies[edit]
An RTOS is an operating system in which the time taken to process an input stimulus is less than the time lapsed until the next input stimulus of the same type.
The most common designs are:

Event-driven – switches tasks only when an event of higher priority needs servicing; called preemptive priority, or priority scheduling.
Time-sharing – switches tasks on a regular clocked interrupt, and on events; called round-robin.
Time sharing designs switch tasks more often than strictly needed, but give smoother multitasking, giving the illusion that a process or user has sole use of a machine.
Early CPU designs needed many cycles to switch tasks during which the CPU could do nothing else useful. Because switching took so long, early OSes tried to minimize wasting CPU time by avoiding unnecessary task switching.

Scheduling[edit]
In typical designs, a task has three states:

Running (executing on the CPU);
Ready (ready to be executed);
Blocked (waiting for an event, I/O for example).
Most tasks are blocked or ready most of the time because generally only one task can run at a time per CPU core. The number of items in the ready queue can vary greatly, depending on the number of tasks the system needs to perform and the type of scheduler that the system uses. On simpler non-preemptive but still multitasking systems, a task has to give up its time on the CPU to other tasks, which can cause the ready queue to have a greater number of overall tasks in the ready to be executed state (resource starvation).
Usually, the data structure of the ready list in the scheduler is designed to minimize the worst-case length of time spent in the scheduler's critical section, during which preemption is inhibited, and, in some cases, all interrupts are disabled, but the choice of data structure depends also on the maximum number of tasks that can be on the ready list.
If there are never more than a few tasks on the ready list, then a doubly linked list of ready tasks is likely optimal. If the ready list usually contains only a few tasks but occasionally contains more, then the list should be sorted by priority, so that finding the highest priority task to run does not require traversing the list. Instead, inserting a task requires walking the list.
During this search, preemption should not be inhibited. Long critical sections should be divided into smaller pieces. If an interrupt occurs that makes a high priority task ready during the insertion of a low priority task, that high priority task can be inserted and run immediately before the low priority task is inserted.
The critical response time, sometimes called the flyback time, is the time it takes to queue a new ready task and restore the state of the highest priority task to running. In a well-designed RTOS, readying a new task will take 3 to 20 instructions per ready-queue entry, and restoration of the highest-priority ready task will take 5 to 30 instructions.
In advanced systems, real-time tasks share computing resources with many non-real-time tasks, and the ready list can be arbitrarily long. In such systems, a scheduler ready list implemented as a linked list would be inadequate.

Algorithms[edit]
Some commonly used RTOS scheduling algorithms are:[4]

Cooperative scheduling
Preemptive scheduling
Rate-monotonic scheduling
Round-robin scheduling
Fixed-priority pre-emptive scheduling, an implementation of preemptive time slicing
Fixed-priority scheduling with deferred preemption
Fixed-priority non-preemptive scheduling
Critical section preemptive scheduling
Static-time scheduling
Earliest deadline first approach
Stochastic digraphs with multi-threaded graph traversal
Intertask communication and resource sharing[edit]
A multitasking operating system like Unix is poor at real-time tasks. The scheduler gives the highest priority to jobs with the lowest demand on the computer, so there is no way to ensure that a time-critical job will have access to enough resources. Multitasking systems must manage sharing data and hardware resources among multiple tasks. It is usually unsafe for two tasks to access the same specific data or hardware resource simultaneously.[5] There are three common approaches to resolve this problem:

Temporarily masking/disabling interrupts[edit]
General-purpose operating systems usually do not allow user programs to mask (disable) interrupts, because the user program could control the CPU for as long as it is made to. Some modern CPUs do not allow user mode code to disable interrupts as such control is considered a key operating system resource. Many embedded systems and RTOSs, however, allow the application itself to run in kernel mode for greater system call efficiency and also to permit the application to have greater control of the operating environment without requiring OS intervention.
On single-processor systems, an application running in kernel mode and masking interrupts is the lowest overhead method to prevent simultaneous access to a shared resource. While interrupts are masked and the current task does not make a blocking OS call, the current task has exclusive use of the CPU since no other task or interrupt can take control, so the critical section is protected. When the task exits its critical section, it must unmask interrupts; pending interrupts, if any, will then execute. Temporarily masking interrupts should only be done when the longest path through the critical section is shorter than the desired maximum interrupt latency. Typically this method of protection is used only when the critical section is just a few instructions and contains no loops. This method is ideal for protecting hardware bit-mapped registers when the bits are controlled by different tasks.

Mutexes[edit]
When the shared resource must be reserved without blocking all other tasks (such as waiting for Flash memory to be written), it is better to use mechanisms also available on general-purpose operating systems, such as a mutex and OS-supervised interprocess messaging. Such mechanisms involve system calls, and usually invoke the OS's dispatcher code on exit, so they typically take hundreds of CPU instructions to execute, while masking interrupts may take as few as one instruction on some processors.
A (non-recursive) mutex is either locked or unlocked. When a task has locked the mutex, all other tasks must wait for the mutex to be unlocked by its  owner - the original thread. A task may set a timeout on its wait for a mutex. There are several well-known problems with mutex based designs such as priority inversion and deadlocks.
In priority inversion a high priority task waits because a low priority task has a mutex, but the lower priority task is not given CPU time to finish its work. A typical solution is to have the task that owns a mutex 'inherit' the priority of the highest waiting task. But this simple approach gets more complex when there are multiple levels of waiting: task A waits for a mutex locked by task B, which waits for a mutex locked by task C. Handling multiple levels of inheritance causes other code to run in high priority context and thus can cause starvation of medium-priority threads.
In a deadlock, two or more tasks lock mutex without timeouts and then wait forever for the other task's mutex, creating a cyclic dependency. The simplest deadlock scenario occurs when two tasks alternately lock two mutex, but in the opposite order. Deadlock is prevented by careful design.

Message passing[edit]
The other approach to resource sharing is for tasks to send messages in an organized message passing scheme. In this paradigm, the resource is managed directly by only one task. When another task wants to interrogate or manipulate the resource, it sends a message to the managing task. Although their real-time behavior is less crisp than semaphore systems, simple message-based systems avoid most protocol deadlock hazards, and are generally better-behaved than semaphore systems. However, problems like those of semaphores are possible. Priority inversion can occur when a task is working on a low-priority message and ignores a higher-priority message (or a message originating indirectly from a high priority task) in its incoming message queue. Protocol deadlocks can occur when two or more tasks wait for each other to send response messages.

Interrupt handlers and the scheduler[edit]
Since an interrupt handler blocks the highest priority task from running, and since real-time operating systems are designed to keep thread latency to a minimum, interrupt handlers are typically kept as short as possible. The interrupt handler defers all interaction with the hardware if possible; typically all that is necessary is to acknowledge or disable the interrupt (so that it won't occur again when the interrupt handler returns) and notify a task that work needs to be done. This can be done by unblocking a driver task through releasing a semaphore, setting a flag or sending a message. A scheduler often provides the ability to unblock a task from interrupt handler context.
An OS maintains catalogues of objects it manages such as threads, mutexes, memory, and so on. Updates to this catalogue must be strictly controlled. For this reason, it can be problematic when an interrupt handler calls an OS function while the application is in the act of also doing so. The OS function called from an interrupt handler could find the object database to be in an inconsistent state because of the application's update. There are two major approaches to deal with this problem: the unified architecture and the segmented architecture. RTOSs implementing the unified architecture solve the problem by simply disabling interrupts while the internal catalogue is updated. The downside of this is that interrupt latency increases, potentially losing interrupts. The segmented architecture does not make direct OS calls but delegates the OS related work to a separate handler. This handler runs at a higher priority than any thread but lower than the interrupt handlers. The advantage of this architecture is that it adds very few cycles to interrupt latency. As a result, OSes which implement the segmented architecture are more predictable and can deal with higher interrupt rates compared to the unified architecture.[citation needed]
Similarly, the System Management Mode on x86 compatible hardware can take a lot of time before it returns control to the operating system.

Memory allocation[edit]
Memory allocation is more critical in a real-time operating system than in other operating systems.
First, for stability there cannot be memory leaks (memory that is allocated but not freed after use). The device should work indefinitely, without ever needing a reboot.[citation needed] For this reason, dynamic memory allocation is frowned upon.[citation needed] Whenever possible, all required memory allocation is specified statically at compile time.
Another reason to avoid dynamic memory allocation is memory fragmentation. With frequent allocation and releasing of small chunks of memory, a situation may occur where available memory is divided into several sections and the RTOS cannot allocate a large enough continuous block of memory, although there is enough free memory. Secondly, speed of allocation is important. A standard memory allocation scheme scans a linked list of indeterminate length to find a suitable free memory block,[6] which is unacceptable in a RTOS since memory allocation has to occur within a certain amount of time.
Because mechanical disks have much longer and more unpredictable response times, swapping to disk files is not used for the same reasons as RAM allocation discussed above.
The simple fixed-size-blocks algorithm works quite well for simple embedded systems because of its low overhead.

See also[edit]



The Wikibook Embedded Systems has a page on the topic of: Real-Time Operating Systems


Adaptive partition scheduler
Comparison of real-time operating systems (RTOS list)
DO-178B
Earliest deadline first scheduling
Firmware
Interruptible operating system
INtime
Least slack time scheduling
Rate-monotonic scheduling
Synchronous programming language
Time-triggered system
Time-utility function
List of operating systems

References[edit]


^ "Response Time and Jitter". Archived from the original on 2011-07-23. Retrieved 2010-12-04.

^ Tanenbaum, Andrew (2008). Modern Operating Systems. Upper Saddle River, NJ: Pearson/Prentice Hall. p. 160. ISBN 978-0-13-600663-3.

^ "RTOS Concepts". Archived from the original on 2011-07-23. Retrieved 2010-12-04.

^ Samek, Miro (23 May 2023). "Programming embedded systems: RTOS – what is real-time?". Embedded.com. Retrieved 13 September 2023.

^ Phraner, Ralph A. (Fall 1984). "The Future of Unix on the IBM PC". Byte. pp. 59–64.

^ "CS 241, University of Illinois" (PDF).


vteReal-time operating systems (RTOS)OperatingsystemsPOSIX supportUnix-like
DNIX
Junos OS
LynxOS
Multi-Environment Real-Time^ (MERT – Unix-RT)
OS2000
QNX^
Real-Time Linux°
RTLinux°
UNOS
LiteOS
LiteOS°
Partial
ChorusOS^
Integrity^
Nucleus RTOS^
NuttX^°
Operating System Embedded^ (OSE)
PX5 RTOS^
RIOT^°
RTEMS°
TRON support
ITRON project
T-Kernel
Micro T-Kernel
T-Engine Forum (organization)
T-License
Partial
eCos°
RTEMS°
Capability-based
EROS^°
seL4^°
Java virtual machine
Chorus/Jazz^ (JavaOS + ChorusOS^)
DOS
Multiuser DOS
Concurrent DOS
FlexOS
REAL/32
L4 kernel
L4Linux^°
PikeOS^
REX OS^
Wombat^°
Psion
EKA2^° kernel → Symbian OS^°
Microsoft
ThreadX^
Windows Embedded Compact
IBM
4680 OS
4690 OS
Transaction Processing Facility (TPF)
Texas Instruments
DSOS
TI-RTOS Kernel^°
DEC PDP-11 & VAX
RSX-11
RT-11
VAXELN
Low resource
ChibiOS/RT^°
Contiki°
ERIKA Enterprise°
FunkOS°
Mynewt°
Nano-RK°
OpenComRTOS^
PX5 RTOS^
RT-Thread° Nano
RIOT°
RTEMS°
ThreadX^
Zephyr^°

BeRTOS^°
DioneOS
embOS
FreeRTOS^°
µC/OS^°
µ-velOSity^
MQX^
OS-9 (Microware)
Phantom OS^°
pSOS
RMX
RT-Thread° Standard
ScreenOS
Sintran III
THEOS
Thoth^ → Harmony^
VRTX^
VxWorks
UniProtonFrameworks, kits
Robot Operating System° 2
RTAI°
TI-RTOS^°
Xenomai°
Developers
Gordon Bell
David Cheriton
Dave Cutler
Dan Dodge
Adam Dunkels
Ken Sakamura

Italics = discontinued
^ = Microkernel
° = Open-source software Comparison  Category

vteEmbedded systemsGeneral terms
ASIC
Board support package
Bootloader
Consumer electronics
Cross compiler
Embedded database
Embedded hypervisor
Embedded OS
Embedded software
FPGA
IoT
Memory footprint
Microcontroller
Single-board computer
Raspberry Pi
SoC
Firmware and controls
Firmware
Custom firmware
Proprietary firmware
Closed platform
Crippleware
Defective by Design
Hacking of consumer electronics
Homebrew (video games)
iOS jailbreaking
PlayStation 3 Jailbreak
Rooting (Android)
UEFI
Vendor lock-in
Boot loaders
U-Boot
Barebox
Software libraries
uClibc
dietlibc
Embedded GLIBC
lwIP
musl
Programming tools
Almquist shell
BitBake
Buildroot
BusyBox
OpenEmbedded
Stand-alone shell
Toybox
Yocto Project
Operating systems
Linux on embedded systems
Linux for mobile devices
Light-weight Linux distribution
Real-time operating system
Windows IoT
Win CE
Programming languages
Ada
Assembly language
CAPL
Embedded C
Embedded C++
Embedded Java
MISRA C
MicroPython

Lightweight browsers
List of open-source hardware
Open-source robotics

vteOperating systemsGeneral
Comparison
Forensic engineering
History
List
Timeline
Usage share
User features comparison
Variants
Disk operating system
Distributed operating system
Embedded operating system
Hobbyist operating system
Just enough operating system
Mobile operating system
Network operating system
Object-oriented operating system
Real-time operating system
Supercomputer operating system
KernelArchitectures
Exokernel
Hybrid
Microkernel
Monolithic
Multikernel
vkernel
Rump kernel
Unikernel
Components
Device driver
Loadable kernel module
User space and kernel space
Process managementConcepts
Computer multitasking (Cooperative, Preemptive)
Context switch
Interrupt
IPC
Process
Process control block
Real-time
Thread
Time-sharing
Schedulingalgorithms
Fixed-priority preemptive
Multilevel feedback queue
Round-robin
Shortest job next
Memory management,resource protection
Bus error
General protection fault
Memory paging
Memory protection
Protection ring
Segmentation fault
Virtual memory
Storage access,file systems
Boot loader
Defragmentation
Device file
File attribute
Inode
Journal
Partition
Virtual file system
Virtual tape library
Supporting concepts
API
Computer network
HAL
Live CD
Live USB
Shell
CLI
User interface
PXE





Retrieved from "https://en.wikipedia.org/w/index.php?title=Real-time_operating_system&oldid=1281093259"
Categories: Real-time operating systemsOperating systemsReal-time computingHidden categories: Articles with short descriptionShort description is different from WikidataAll articles with unsourced statementsArticles with unsourced statements from November 2017Articles with unsourced statements from September 2024Articles with unsourced statements from April 2018






 This page was last edited on 18 March 2025, at 07:18 (UTC).
Text is available under the Creative Commons Attribution-ShareAlike 4.0 License;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.


Privacy policy
About Wikipedia
Disclaimers
Contact Wikipedia
Code of Conduct
Developers
Statistics
Cookie statement
Mobile view














Search













Search









Toggle the table of contents







Real-time operating system




























36 languages


Add topic
















