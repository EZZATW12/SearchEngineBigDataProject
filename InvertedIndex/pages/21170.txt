https://en.wikipedia.org/wiki/MIPS_architecture




MIPS architecture - Wikipedia



























Jump to content







Main menu





Main menu
move to sidebar
hide



		Navigation
	


Main pageContentsCurrent eventsRandom articleAbout WikipediaContact us





		Contribute
	


HelpLearn to editCommunity portalRecent changesUpload fileSpecial pages



















Search











Search






















Appearance
















Donate

Create account

Log in








Personal tools





Donate Create account Log in





		Pages for logged out editors learn more



ContributionsTalk




























Contents
move to sidebar
hide




(Top)





1
History








2
Design








3
Versions




Toggle Versions subsection





3.1
MIPS I






3.1.1
Registers








3.1.2
Instruction formats








3.1.3
CPU instructions










3.2
MIPS II








3.3
MIPS III








3.4
MIPS IV








3.5
MIPS V








3.6
MIPS32/MIPS64








3.7
microMIPS










4
Application-specific extensions




Toggle Application-specific extensions subsection





4.1
MIPS MCU








4.2
MIPS16








4.3
MIPS Digital Signal Processing (DSP)








4.4
MIPS SIMD architecture (MSA)








4.5
MIPS virtualization








4.6
MIPS multi-threading








4.7
SmartMIPS








4.8
MIPS Digital Media eXtension (MDMX)








4.9
MIPS-3D










5
Calling conventions








6
Uses








7
Simulators








8
See also








9
References








10
Further reading








11
External links


















Toggle the table of contents







MIPS architecture



31 languages




العربيةCatalàЧӑвашлаČeštinaDanskDeutschEestiEspañolفارسیFrançais한국어Bahasa IndonesiaItalianoעבריתLatviešuMagyarNederlands日本語Norsk bokmålPolskiPortuguêsRomânăРусскийSimple EnglishSuomiSvenskaTürkçeУкраїнськаTiếng Việt吴语中文

Edit links











ArticleTalk





English

















ReadEditView history







Tools





Tools
move to sidebar
hide



		Actions
	


ReadEditView history





		General
	


What links hereRelated changesUpload filePermanent linkPage informationCite this pageGet shortened URLDownload QR code





		Print/export
	


Download as PDFPrintable version





		In other projects
	


Wikimedia CommonsWikidata item





















Appearance
move to sidebar
hide










From Wikipedia, the free encyclopedia


Instruction set architecture


MIPSDesignerMIPS Technologies, Imagination TechnologiesBits64-bit (32 → 64)Introduced1985; 40 years ago (1985)VersionMIPS32/64 Release 6 (2014)DesignRISCTypeLoad–storeEncodingFixedBranchingCompare and branch, with a 1 instruction delay after the branching condition checkEndiannessBiPage size4 KBExtensionsMDMX, MIPS-3DOpenPartly. The R16000 processor has been on the market for more than 20 years and as such cannot be subject to patent claims. Therefore, the R16000 and older processors are fully open.RegistersGeneral-purpose32Floating point32
MIPS (Microprocessor without Interlocked Pipelined Stages)[1] is a family of reduced instruction set computer (RISC) instruction set architectures (ISA)[2]: A-1 [3]: 19  developed by MIPS Computer Systems, now MIPS Technologies, based in the United States.
There are multiple versions of MIPS, including MIPS I, II, III, IV, and V, as well as five releases of MIPS32/64 (for 32- and 64-bit implementations, respectively). The early MIPS architectures were 32-bit; 64-bit versions were developed later. As of April 2017, the current version of MIPS is MIPS32/64 Release 6.[4][5] MIPS32/64 primarily differs from MIPS I–V by defining the privileged kernel mode System Control Coprocessor in addition to the user mode architecture.
The MIPS architecture has several optional extensions: MIPS-3D, a simple set of floating-point SIMD instructions dedicated to 3D computer graphics;[6] MDMX (MaDMaX), a more extensive integer SIMD instruction set using 64-bit floating-point registers; MIPS16e, which adds compression to the instruction stream to reduce the memory programs require;[7] and MIPS MT, which adds multithreading capability.[8]
Computer architecture courses in universities and technical schools often study the MIPS architecture.[9] The architecture greatly influenced later RISC architectures such as Alpha. In March 2021, MIPS announced that the development of the MIPS architecture had ended as the company is making the transition to RISC-V.[10]


History[edit]
This section needs expansion. You can help by adding to it.  (February 2020)
See also: MIPS Technologies § History, and Stanford MIPS
The first version of the MIPS architecture was designed by MIPS Computer Systems for its R2000 microprocessor, the first MIPS implementation. Both MIPS and the R2000 were introduced together in 1985.[11][failed verification] When MIPS II was introduced, MIPS was renamed MIPS I to distinguish it from the new version.[3]: 32 
MIPS Computer Systems' R6000 microprocessor (1989) was the first MIPS II implementation.[3]: 8  Designed for servers, the R6000 was fabricated and sold by Bipolar Integrated Technology, but was a commercial failure. During the mid-1990s, many new 32-bit MIPS processors for embedded systems were MIPS II implementations because the introduction of the 64-bit MIPS III architecture in 1991 left MIPS II as the newest 32-bit MIPS architecture until MIPS32 was introduced in 1999.[3]: 19 
MIPS Computer Systems' R4000 microprocessor (1991) was the first MIPS III implementation. It was designed for use in personal, workstation, and server computers. MIPS Computer Systems aggressively promoted the MIPS architecture and R4000, establishing the Advanced Computing Environment (ACE) consortium to advance its Advanced RISC Computing (ARC) standard, which aimed to establish MIPS as the dominant personal computing platform. ARC found little success in personal computers, but the R4000 (and the R4400 derivative) were widely used in workstation and server computers, especially by its largest user, Silicon Graphics. Other uses of the R4000 included high-end embedded systems and supercomputers. MIPS III was eventually implemented by a number of embedded microprocessors. Quantum Effect Design's R4600 (1993) and its derivatives was widely used in high-end embedded systems and low-end workstations and servers. MIPS Technologies' R4200 (1994), was designed for embedded systems, laptop, and personal computers. A derivative, the R4300i, fabricated by NEC Electronics, was used in the Nintendo 64 game console. The Nintendo 64, along with the PlayStation, were among the highest volume users of MIPS architecture processors in the mid-1990s.
The first MIPS IV implementation was the MIPS Technologies R8000 microprocessor chipset (1994). The design of the R8000 began at Silicon Graphics, Inc. and it was only used in high-end workstations and servers for scientific and technical applications where high performance on large floating-point workloads was important. Later implementations were the MIPS Technologies R10000 (1996) and the Quantum Effect Devices R5000 (1996) and RM7000 (1998). The R10000, fabricated and sold by NEC Electronics and Toshiba, and its derivatives were used by NEC, Pyramid Technology, Silicon Graphics, and Tandem Computers (among others) in workstations, servers, and supercomputers. The R5000 and R7000 found use in high-end embedded systems, personal computers, and low-end workstations and servers. A derivative of the R5000 from Toshiba, the R5900, was used in Sony Computer Entertainment's Emotion Engine, which powered its PlayStation 2 game console.
Announced on October 21, 1996, at the Microprocessor Forum 1996 alongside the MIPS Digital Media Extensions (MDMX) extension, MIPS V was designed to improve the performance of 3D graphics transformations.[12] In the mid-1990s, a major use of non-embedded MIPS microprocessors were graphics workstations from Silicon Graphics. MIPS V was completed by the integer-only MDMX extension to provide a complete system for improving the performance of 3D graphics applications.[13] MIPS V implementations were never introduced. On May 12, 1997, Silicon Graphics announced the H1 ("Beast") and H2 ("Capitan") microprocessors. The former was to have been the first MIPS V implementation, and was due to be introduced in the first half of 1999.[14] The H1 and H2 projects were later combined and eventually canceled in 1998. While there have not been any MIPS V implementations, MIPS64 Release 1 (1999) was based on MIPS V and retains all of its features as an optional Coprocessor 1 (FPU) feature called Paired-Single.
When MIPS Technologies was spun-out of Silicon Graphics in 1998, it refocused on the embedded market. Through MIPS V, each successive version was a strict superset of the previous version, but this property was found to be a problem,[citation needed] and the architecture definition was changed to define a 32-bit and a 64-bit architecture: MIPS32 and MIPS64. Both were introduced in 1999.[15] MIPS32 is based on MIPS II with some additional features from MIPS III, MIPS IV, and MIPS V; MIPS64 is based on MIPS V.[15] NEC, Toshiba and SiByte (later acquired by Broadcom) each obtained licenses for MIPS64 as soon as it was announced. Philips, LSI Logic, IDT, Raza Microelectronics, Inc., Cavium, Loongson Technology and Ingenic Semiconductor have since joined them. MIPS32/MIPS64 Release 5 was announced on December 6, 2012.[16] According to the Product Marketing Director at MIPS, Release 4 was skipped because the number four is perceived as unlucky in many Asian cultures.[17]
In December 2018, Wave Computing, the new owner of the MIPS architecture, announced that MIPS ISA would be open-sourced in a program dubbed the MIPS Open initiative.[18] The program was intended to open up access to the most recent versions of both the 32-bit and 64-bit designs making them available without any licensing or royalty fees as well as granting participants licenses to existing MIPS patents.[19][20][21]
In March 2019, one version of the architecture was made available under a royalty-free license,[22] but later that year the program was shut down again.[23]
In March 2021, Wave Computing announced that the development of the MIPS architecture has ceased. The company has joined the RISC-V foundation and future processor designs will be based on the RISC-V architecture.[10][24] In spite of this, some licensees such as Loongson continue with new extension of MIPS-compatible ISAs on their own.[25]
In January 2024, Loongson won a case over rights to use MIPS architecture.[26]

Design[edit]
This section needs expansion. You can help by adding to it.  (February 2020)
MIPS is a modular architecture supporting up to four coprocessors (CP0/1/2/3). In MIPS terminology, CP0 is the System Control Coprocessor (an essential part of the processor that is implementation-defined in MIPS I–V), CP1 is an optional floating-point unit (FPU) and CP2/3 are optional implementation-defined coprocessors (MIPS III removed CP3 and reused its opcodes for other purposes). For example, in the PlayStation video game console, CP2 is the Geometry Transformation Engine (GTE), which accelerates the processing of geometry in 3D computer graphics.

Versions[edit]
MIPS I[edit]
MIPS is a load/store architecture (also known as a register-register architecture); except for the load/store instructions used to access memory, all instructions operate on the registers.

Registers[edit]
MIPS I has thirty-two 32-bit general-purpose registers (GPR). Register $0 is hardwired to zero and writes to it are discarded. Register $31 is the link register. For integer multiplication and division instructions, which run asynchronously from other instructions, a pair of 32-bit registers, HI and LO, are provided. There is a small set of instructions for copying data between the general-purpose registers and the HI/LO registers.
The program counter has 32 bits. The two low-order bits always contain zero since MIPS I instructions are 32 bits long and are aligned to their natural word boundaries.

Instruction formats[edit]
Instructions are divided into three types: R (register), I (immediate), and J (jump). Every instruction starts with a 6-bit opcode. In addition to the opcode, R-type instructions specify three registers,[27] a shift amount field, and a function field; I-type instructions specify two registers and a 16-bit immediate value; J-type instructions follow the opcode with a 26-bit jump target.[2]: A-174 
The following are the three formats used for the core instruction set:



Type
-31-                                 format (bits)                                 -0-


R
opcode (6)
rs (5)
rt (5)
rd (5)
shamt (5)
funct (6)


I
opcode (6)
rs (5)
rt (5)
immediate (16)


J
opcode (6)
address (26)

CPU instructions[edit]
MIPS I has instructions that load and store 8-bit bytes, 16-bit halfwords, and 32-bit words. Only one addressing mode is supported: base + displacement. Since MIPS I is a 32-bit architecture, loading quantities fewer than 32 bits requires the datum to be either sign-extended or zero-extended to 32 bits. The load instructions suffixed by "unsigned" perform zero extension; otherwise sign extension is performed. Load instructions source the base from the contents of a GPR (rs) and write the result to another GPR (rt). Store instructions source the base from the contents of a GPR (rs) and the store data from another GPR (rt). All load and store instructions compute the memory address by summing the base with the sign-extended 16-bit immediate. MIPS I requires all memory accesses to be aligned to their natural word boundaries, otherwise an exception is signaled. To support efficient unaligned memory accesses, there are load/store word instructions suffixed by "left" or "right". All load instructions are followed by a load delay slot. The instruction in the load delay slot cannot use the data loaded by the load instruction. The load delay slot can be filled with an instruction that is not dependent on the load; a NOP is substituted if such an instruction cannot be found.
MIPS I has instructions to perform addition and subtraction. These instructions source their operands from two GPRs (rs and rt), and write the result to a third GPR (rd). Alternatively, addition can source one of the operands from a 16-bit immediate (which is sign-extended to 32 bits). The instructions for addition and subtraction have two variants: by default, an exception is signaled if the result overflows; instructions with the "unsigned" suffix do not signal an exception. The overflow check interprets the result as a 32-bit two's complement integer. MIPS I has instructions to perform bitwise logical AND, OR, XOR, and NOR. These instructions source their operands from two GPRs and write the result to a third GPR. The AND, OR, and XOR instructions can alternatively source one of the operands from a 16-bit immediate (which is zero-extended to 32 bits). The "Set on relation" instructions write one or zero to the destination register if the specified relation is true or false. These instructions source their operands from two GPRs or one GPR and a 16-bit immediate (which is sign-extended to 32 bits), and write the result to a third GPR. By default, the operands are interpreted as signed integers. The variants of these instructions that are suffixed with "unsigned" interpret the operands as unsigned integers (even those that source an operand from the sign-extended 16-bit immediate).
The Load Upper Immediate instruction copies the 16-bit immediate into the high-order 16 bits of a GPR. It is used in conjunction with the Or Immediate instruction to load a 32-bit immediate into a register.
MIPS I has instructions to perform left and right logical shifts and right arithmetic shifts. The operand is obtained from a GPR (rt), and the result is written to another GPR (rd). The shift distance is obtained from either a GPR (rs) or a 5-bit "shift amount" (the "sa" field).
MIPS I has instructions for signed and unsigned integer multiplication and division. These instructions source their operands from two GPRs and write their results to a pair of 32-bit registers called HI and LO, since they may execute separately from (and concurrently with) the other CPU instructions. For multiplication, the high- and low-order halves of the 64-bit product is written to HI and LO (respectively). For division, the quotient is written to LO and the remainder to HI. To access the results, a pair of instructions (Move from HI and Move from LO) is provided to copy the contents of HI or LO to a GPR. These instructions are interlocked: reads of HI and LO do not proceed past an unfinished arithmetic instruction that will write to HI and LO. Another pair of instructions (Move to HI or Move to LO) copies the contents of a GPR to HI and LO. These instructions are used to restore HI and LO to their original state after exception handling. Instructions that read HI or LO must be separated by two instructions that do not write to HI or LO.
All MIPS I control flow instructions are followed by a branch delay slot. Unless the branch delay slot is filled by an instruction performing useful work, a NOP is substituted. MIPS I branch instructions compare the contents of a GPR (rs) against zero or another GPR (rt) as signed integers and branch if the specified condition is true. Control is transferred to the address computed by shifting the 16-bit offset left by two bits, sign-extending the 18-bit result, and adding the 32-bit sign-extended result to the sum of the program counter (instruction address) and 810. Jumps have two versions: absolute and register-indirect. Absolute jumps ("Jump" and "Jump and Link") compute the address to which control is transferred by shifting the 26-bit instr_index left by two bits and concatenating the 28-bit result with the four high-order bits of the address of the instruction in the branch delay slot. Register-indirect jumps transfer control to the instruction at the address sourced from a GPR (rs). The address sourced from the GPR must be word-aligned, else an exception is signaled after the instruction in the branch delay slot is executed. Branch and jump instructions that link (except for "Jump and Link Register") save the return address to GPR 31. The "Jump and Link Register" instruction permits the return address to be saved to any writable GPR.
MIPS I has two instructions for software to signal an exception: System Call and Breakpoint. System Call is used by user mode software to make kernel calls; and Breakpoint is used to transfer control to a debugger via the kernel's exception handler. Both instructions have a 20-bit Code field that can contain operating environment-specific information for the exception handler.
MIPS has 32 floating-point registers. Two registers are paired for double precision numbers. Odd numbered registers cannot be used for arithmetic or branching, just as part of a double precision register pair, resulting in 16 usable registers for most instructions (moves/copies and loads/stores were not affected).
Single precision is denoted by the .s suffix, while double precision is denoted by the .d suffix.

MIPS II[edit]
MIPS II removed the load delay slot[3]: 41  and added several sets of instructions. For shared-memory multiprocessing, the Synchronize Shared Memory, Load Linked Word, and Store Conditional Word instructions were added.[28] A set of Trap-on-Condition instructions were added. These instructions caused an exception if the evaluated condition is true. All existing branch instructions were given branch-likely versions that executed the instruction in the branch delay slot only if the branch is taken.[3]: 40  These instructions improve performance in certain cases by allowing useful instructions to fill the branch delay slot.[3]: 212  Doubleword load and store instructions for COP1–3 were added. Consistent with other memory access instructions, these loads and stores required the doubleword to be naturally aligned.
The instruction set for the floating point coprocessor also had several instructions added to it. An IEEE 754-compliant floating-point square root instruction was added. It supported both single- and double-precision operands. A set of instructions that converted single- and double-precision floating-point numbers to 32-bit words were added. These complemented the existing conversion instructions by allowing the IEEE rounding mode to be specified by the instruction instead of the Floating Point Control and Status Register.

MIPS III[edit]
MIPS III is a backwards-compatible extension of MIPS II that added support for 64-bit memory addressing and integer operations. The 64-bit data type is called a doubleword, and MIPS III extended the general-purpose registers, HI/LO registers, and program counter to 64 bits to support it. New instructions were added to load and store doublewords, to perform integer addition, subtraction, multiplication, division, and shift operations on them, and to move doubleword between the GPRs and HI/LO registers. For shared-memory multiprocessing, the Load Linked Double Word, and Store Conditional Double Word instructions were added.[28] Existing instructions originally defined to operate on 32-bit words were redefined, where necessary, to sign-extend the 32-bit results to permit words and doublewords to be treated identically by most instructions. Among those instructions redefined was Load Word. In MIPS III it sign-extends words to 64 bits. To complement Load Word, a version that zero-extends was added.
The R instruction format's inability to specify the full shift distance for 64-bit shifts (its 5-bit shift amount field is too narrow to specify the shift distance for doublewords) required MIPS III to provide three 64-bit versions of each MIPS I shift instruction. The first version is a 64-bit version of the original shift instructions, used to specify constant shift distances of 0–31 bits. The second version is similar to the first, but adds 3210 the shift amount field's value so that constant shift distances of 32–63 bits can be specified. The third version obtains the shift distance from the six low-order bits of a GPR.
MIPS III added a supervisor privilege level in between the existing kernel and user privilege levels. This feature only affected the implementation-defined System Control Processor (Coprocessor 0).
MIPS III removed the Coprocessor 3 (CP3) support instructions, and reused its opcodes for the new doubleword instructions. The remaining coprocessors gained instructions to move doublewords between coprocessor registers and the GPRs. The floating general registers (FGRs) were extended to 64 bits and the requirement for instructions to use even-numbered register only was removed. This is incompatible with earlier versions of the architecture; a bit in the floating-point control/status register is used to operate the MIPS III floating-point unit (FPU) in a MIPS I- and II-compatible mode. The floating-point control registers were not extended for compatibility. The only new floating-point instructions added were those to copy doublewords between the CPU and FPU convert single- and double-precision floating-point numbers into doubleword integers and vice versa.

MIPS IV[edit]
MIPS IV is the fourth version of the architecture. It is a superset of MIPS III and is compatible with all existing versions of MIPS.[29]: A-1  MIPS IV was designed to mainly improve floating-point (FP) performance. To improve access to operands, an indexed addressing mode (base + index, both sourced from GPRs) for FP loads and stores was added, as were prefetch instructions for performing memory prefetching and specifying cache hints (these supported both the base + offset and base + index addressing modes).
MIPS IV added several features to improve instruction-level parallelism. To alleviate the bottleneck caused by a single condition bit, seven condition code bits were added to the floating-point control and status register, bringing the total to eight. FP comparison and branch instructions were redefined so they could specify which condition bit was written or read (respectively); and the delay slot in between an FP branch that read the condition bit written to by a prior FP comparison was removed. Support for partial predication was added in the form of conditional move instructions for both GPRs and FPRs; and an implementation could choose between having precise or imprecise exceptions for IEEE 754 traps.
MIPS IV added several new FP arithmetic instructions for both single- and double-precision FPNs: fused-multiply add or subtract, reciprocal, and reciprocal square-root. The FP fused-multiply add or subtract instructions perform either one or two roundings (it is implementation-defined), to exceed or meet IEEE 754 accuracy requirements (respectively). The FP reciprocal and reciprocal square-root instructions do not comply with IEEE 754 accuracy requirements, and produce results that differ from the required accuracy by one or two units of last place (it is implementation defined). These instructions serve applications where instruction latency is more important than accuracy.

MIPS V[edit]
MIPS V added a new data type, the Paired Single (PS), which consisted of two single-precision (32-bit) floating-point numbers stored in the existing 64-bit floating-point registers. Variants of existing floating-point instructions for arithmetic, compare and conditional move were added to operate on this data type in a SIMD fashion. New instructions were added for loading, rearranging and converting PS data.[3]: 426–429  It was the first instruction set to exploit floating-point SIMD with existing resources.[13]

MIPS32/MIPS64[edit]
The first release of MIPS32, based on MIPS II, added conditional moves, prefetch instructions, and other features from the R4000 and R5000 families of 64-bit processors.[15] The first release of MIPS64 adds a MIPS32 mode to run 32-bit code.[15] The MUL and MADD (multiply-add) instructions, previously available in some implementations, were added to the MIPS32 and MIPS64 specifications, as were cache control instructions.[15] For the purpose of cache control, both SYNC and SYNCI instructions were prepared.[30][31]
MIPS32/MIPS64 Release 6 in 2014 added the following:[32]

a new family of branches with no delay slot:
unconditional branches (BC) and branch-and-link (BALC) with a 26-bit offset,
conditional branch on zero/non-zero with a 21-bit offset,
full set of signed and unsigned conditional branches compare between two registers (e.g. BGTUC) or a register against zero (e.g. BGTZC),
full set of branch-and-link which compare a register against zero (e.g. BGTZALC).
index jump instructions with no delay slot designed to support large absolute addresses.
instructions to load 16-bit immediates at bit position 16, 32 or 48, allowing to easily generate large constants.
PC-relative load instructions, as well as address generation with large (PC-relative) offsets.
bit-reversal and byte-alignment instructions (previously only available with the DSP extension).
multiply and divide instructions redefined so that they use a single register for their result).
instructions generating truth values now generate all zeroes or all ones instead of just clearing/setting the 0-bit,
instructions using a truth value now only interpret all-zeroes as false instead of just looking at the 0-bit.
Removed infrequently used instructions:

some conditional moves
branch likely instructions (deprecated in previous releases).
integer overflow trapping instructions with 16-bit immediate
integer accumulator instructions (together HI/LO registers, moved to the DSP Application-Specific Extension)
unaligned load instructions (LWL and LWR), (requiring that most ordinary loads and stores support misaligned access, possibly via trapping and with the addition of a new instruction (BALIGN))
Reorganized the instruction encoding, freeing space for future expansions.

microMIPS[edit]
The microMIPS32/64 architectures are supersets of the MIPS32 and MIPS64 architectures (respectively) designed to replace the MIPS16e application-specific extension (ASE). A disadvantage of MIPS16e is that it requires a mode switch before any of its 16-bit instructions can be processed. microMIPS adds versions of the most-frequently used 32-bit instructions that are encoded as 16-bit instructions. This allows programs to intermix 16- and 32-bit instructions without having to switch modes. microMIPS was introduced alongside of MIPS32/64 Release 3, and each subsequent release of MIPS32/64 has a corresponding microMIPS32/64 version. A processor may implement microMIPS32/64 or both microMIPS32/64 and its corresponding MIPS32/64 subset. Starting with MIPS32/64 Release 6, support for MIPS16e ended, and microMIPS is the only form of code compression in MIPS.

Application-specific extensions[edit]
The base MIPS32 and MIPS64 architectures can be supplemented with a number of optional architectural extensions, which are collectively referred to as application-specific extensions (ASEs). These ASEs provide features that improve the efficiency and performance of certain workloads, such as digital signal processing.

MIPS MCU[edit]
Enhancements for microcontroller applications. The MCU ASE (application-specific extension) has been developed to extend the interrupt controller support, reduce the interrupt latency and enhance the I/O peripheral control function typically required in microcontroller system designs.

Separate priority and vector generation
Supports up to 256 interrupts in EIC (External Interrupt Controller) mode and eight hardware interrupt pins
Provides 16-bit vector offset address
Pre-fetching of the interrupt exception vector
Automated Interrupt Prologue – adds hardware to save and update system status before the interrupt handling routine
Automated Interrupt Epilogue – restores the system state previously stored in the stack for returning from the interrupt.
Interrupt Chaining – supports the service of pending interrupts without the need to exit the initial interrupt routine, saving the cycles required to store and restore multiple active interrupts
Supports speculative pre-fetching of the interrupt vector address. Reduces the number of interrupt service cycles by overlapping memory accesses with pipeline flushes and exception prioritization
Includes atomic bit set/clear instructions which enables bits within an I/O register that are normally used to monitor or control external peripheral functions to be modified without interruption, ensuring the action is performed securely.
MIPS16[edit]
MIPS16 is an Application-Specific Extension for MIPS I through to V designed by LSI Logic and MIPS Technologies, announced on October 21, 1996, alongside its first implementation, the LSI Logic TinyRISC processor.[33] MIPS16 was subsequently licensed by NEC Electronics, Philips Semiconductors, and Toshiba (among others); and implemented as an extension to the MIPS I, II, an III architectures. MIPS16 decreases the size of application by up to 40% by using 16-bit instructions instead of 32-bit instructions and also improves power efficiency, the instruction cache hit rate, and is equivalent in performance to its base architecture.[34] It is supported by hardware and software development tools from MIPS Technologies and other providers. MIPS16e is an improved version of MIPS16 first supported by MIPS32 and MIPS64 Release 1. MIPS16e2 is an improved version of MIPS16 that is supported by MIPS32 and MIPS64 (up to Release 5). Release 6 replaced it with microMIPS.

MIPS Digital Signal Processing (DSP)[edit]
The DSP ASE is an optional extension to the MIPS32/MIPS64 Release 2 and newer instruction sets which can be used to accelerate a large range of "media" computations—particularly audio and video. The DSP module comprises a set of instructions and state in the integer pipeline and requires minimal additional logic to implement in MIPS processor cores. Revision 2 of the ASE was introduced in the second half of 2006. This revision adds extra instructions to the original ASE, but is otherwise backwards-compatible with it.[35] Unlike the bulk of the MIPS architecture, it's a fairly irregular set of operations, many chosen for a particular relevance to some key algorithm. Its main novel features (vs original MIPS32):[36]

Saturating arithmetic (when a calculation overflows, deliver the representable number closest to the non-overflowed answer).
Fixed-point arithmetic on signed 32- and 16-bit fixed-point fractions with a range of -1 to +1 (these are widely called "Q31" and "Q15").
The existing integer multiplication and multiply-accumulate instructions, which deliver results into a double-size accumulator (called "hi/lo" and 64 bits on MIPS32 CPUs). The DSP ASE adds three more accumulators, and some different flavours of multiply-accumulate.
SIMD instructions operating on 4 x unsigned bytes or 2 x 16-bit values packed into a 32-bit register (the 64-bit variant of the DSP ASE supports larger vectors, too).
SIMD operations are basic arithmetic, shifts and some multiply-accumulate type operations.
MIPS SIMD architecture (MSA)[edit]
Instruction set extensions designed to accelerate multimedia.

32 vector registers of 16 x 8-bit, 8 x 16-bit, 4 x 32-bit, and 2 x 64 bit vector elements
Efficient vector parallel arithmetic operations on integer, fixed-point and floating-point data
Operations on absolute value operands
Rounding and saturation options available
Full precision multiply and multiply-add
Conversions between integer, floating-point, and fixed-point data
Complete set of vector-level compare and branch instructions with no condition flag
Vector (1D) and array (2D) shuffle operations
Typed load and store instructions for endian-independent operation
IEEE Standard for Floating-Point Arithmetic 754-2008 compliant
Element precise floating-point exception signaling
Pre-defined scalable extensions for chips with more gates/transistors
Accelerates compute-intensive applications in conjunction with leveraging generic compiler support
Software-programmable solution for consumer electronics applications or functions not covered by dedicated hardware
Emerging data mining, feature extraction, image and video processing, and human-computer interaction applications
High-performance scientific computing
MIPS virtualization[edit]
Hardware supported virtualization technology.

MIPS multi-threading[edit]
Each multi-threaded MIPS core can support up to two VPEs (Virtual Processing Elements) which share a single pipeline as well as other hardware resources. However, since each VPE includes a complete copy of the processor state as seen by the software system, each VPE appears as a complete standalone processor to an SMP Linux operating system. For more fine-grained thread processing applications, each VPE is capable of supporting up to nine TCs allocated across two VPEs. The TCs share a common execution unit but each has its own program counter and core register files so that each can handle a thread from the software. The MIPS MT architecture also allows the allocation of processor cycles to threads, and sets the relative thread priorities with an optional Quality of Service (QoS) manager block. This enables two prioritization mechanisms that determine the flow of information across the bus. The first mechanism allows the user to prioritize one thread over another. The second mechanism is used to allocate a specified ratio of the cycles to specific threads over time. The combined use of both mechanisms allows effective allocation of bandwidth to the set of threads, and better control of latencies. In real-time systems, system-level determinism is very critical, and the QoS block facilitates improvement of the predictability of a system. Hardware designers of advanced systems may replace the standard QoS block provided by MIPS Technologies with one that is specifically tuned for their application.

SmartMIPS[edit]
SmartMIPS is an Application-Specific Extension (ASE) designed by Gemplus International and MIPS Technologies to improve performance and reduce memory consumption for smart card software. It is supported by MIPS32 only, since smart cards do not require the capabilities of MIPS64 processors. Few smart cards use SmartMIPS.

MIPS Digital Media eXtension (MDMX)[edit]
Multimedia application accelerations that were common in the 1990s on RISC and CISC systems. 

MIPS-3D[edit]
Additional instructions for improving the performance of 3D graphics applications

Calling conventions[edit]
MIPS has had several calling conventions, especially on the 32-bit platform.
The O32 ABI is the most commonly-used ABI, owing to its status as the original System V ABI for MIPS.[37][38] It is strictly stack-based, with only four registers $a0-$a3 available to pass arguments. Space on the stack is reserved in case the callee needs to save its arguments, but the registers are not stored there by the caller. The return value is stored in register $v0; a second return value may be stored in $v1. The ABI took shape in 1990 and was last updated in 1994. This perceived slowness, along with an antique floating-point model with only 16 registers, has encouraged the proliferation of many other calling conventions. It is only defined for 32-bit MIPS, but GCC has created a 64-bit variation called O64.[39]
For 64-bit, the N64 ABI by Silicon Graphics is most commonly used. The most important improvement is that eight registers are now available for argument passing; it also increases the number of floating-point registers to 32. There is also an ILP32 version called N32, which uses 32-bit pointers for smaller code, analogous to the x32 ABI. Both run under the 64-bit mode of the CPU.[39] The N32 and N64 ABIs pass the first eight arguments to a function in the registers $a0-$a7; subsequent arguments are passed on the stack. The return value (or a pointer to it) is stored in the registers $v0; a second return value may be stored in $v1. In both the N32 and N64 ABIs all registers are considered to be 64-bits wide.
A few attempts have been made to replace O32 with a 32-bit ABI that resembles N32 more. A 1995 conference came up with MIPS EABI, for which the 32-bit version was quite similar.[40] EABI inspired MIPS Technologies to propose a more radical "NUBI" ABI additionally reuse argument registers for the return value.[41] MIPS EABI is supported by GCC but not LLVM, and neither supports NUBI.
For all of O32 and N32/N64, the return address is stored in a $ra register. This is automatically set with the use of the JAL (jump and link) or JALR (jump and link register) instructions. The function prologue of a (non-leaf) MIPS subroutine pushes the return address (in $ra) to the stack.[42][43]
On both O32 and N32/N64 the stack grows downwards, but the N32/N64 ABIs require 64-bit alignment for all stack entries. The frame pointer ($30) is optional and in practice rarely used except when the stack allocation in a function is determined at runtime, for example, by calling alloca().
For N32 and N64, the return address is typically stored 8 bytes before the stack pointer although this may be optional.
For the N32 and N64 ABIs, a function must preserve the $s0-$s7 registers, the global pointer ($gp or $28), the stack pointer ($sp or $29) and the frame pointer ($30). The O32 ABI is the same except the calling function is required to save the $gp register instead of the called function.
For multi-threaded code, the thread local storage pointer is typically stored in special hardware register $29 and is accessed by using the mfhw (move from hardware) instruction. At least one vendor is known to store this information in the $k0 register which is normally reserved for kernel use, but this is not standard.
The $k0 and $k1 registers ($26–$27) are reserved for kernel use and should not be used by applications since these registers can be changed at any time by the kernel due to interrupts, context switches or other events.


Registers for O32 calling convention


Name
Number
Use
Callee must preserve?


$zero

$0
constant 0
—


$at

$1
assembler temporary
No


$v0–$v1

$2–$3
values for function returns and expression evaluation
No


$a0–$a3

$4–$7
function arguments
No


$t0–$t7

$8–$15
temporaries
No


$s0–$s7

$16–$23
saved temporaries
Yes


$t8–$t9

$24–$25
temporaries
No


$k0–$k1

$26–$27
reserved for OS kernel
—


$gp

$28
global pointer
Yes (except PIC code)


$sp

$29
stack pointer
Yes


$fp

$30
frame pointer
Yes


$ra

$31
return address
—


Registers for N32 and N64 calling conventions[44]


Name
Number
Use
Callee must preserve?


$zero

$0
constant 0
—


$at

$1
assembler temporary
No


$v0–$v1

$2–$3
values for function returns and expression evaluation
No


$a0–$a7

$4–$11
function arguments
No


$t4–$t7

$12–$15
temporaries
No


$s0–$s7

$16–$23
saved temporaries
Yes


$t8–$t9

$24–$25
temporaries
No


$k0–$k1

$26–$27
reserved for OS kernel
—


$gp

$28
global pointer
Yes


$sp

$29
stack pointer
Yes


$s8

$30
frame pointer
Yes


$ra

$31
return address
—

Registers that are preserved across a call are registers that (by convention) will not be changed by a system call or procedure (function) call. For example, $s-registers must be saved to the stack by a procedure that needs to use them, and $sp and $fp are always incremented by constants, and decremented back after the procedure is done with them (and the memory they point to). By contrast, $ra is changed automatically by any normal function call (ones that use jal), and $t-registers must be saved by the program before any procedure call (if the program needs the values inside them after the call).
The userspace calling convention of position-independent code on Linux additionally requires that when a function is called the $t9 register must contain the address of that function.[45] This convention dates back to the System V ABI supplement for MIPS.[46]

Uses[edit]
This section needs expansion. You can help by adding to it.  (February 2020)
Parts of this article (those related to 2010s) need to be updated. Please help update this article to reflect recent events or newly available information. (August 2020)
MIPS processors are used in embedded systems such as residential gateways and routers. Originally, MIPS was designed for general-purpose computing. During the 1980s and 1990s, MIPS processors for personal, workstation, and server computers were used by many companies such as Digital Equipment Corporation, MIPS Computer Systems, NEC, Pyramid Technology, SiCortex, Siemens Nixdorf, Silicon Graphics, and Tandem Computers.
Historically, video game consoles such as the Nintendo 64, Sony PlayStation, PlayStation 2, and PlayStation Portable used MIPS processors. MIPS processors also used to be popular in supercomputers during the 1990s, but all such systems have dropped off the TOP500 list. These uses were complemented by embedded applications at first, but during the 1990s, MIPS became a major presence in the embedded processor market, and by the 2000s, most MIPS processors were for these applications.
In the mid- to late-1990s, it was estimated that one in three RISC microprocessors produced was a MIPS processor.[47]
By the late 2010s, MIPS machines were still commonly used in embedded markets, including automotive, wireless router, LTE modems (mainly via MediaTek), and microcontrollers (for example the Microchip Technology PIC32M). They have mostly faded out of the personal, server, and application space.

Simulators[edit]
Open Virtual Platforms (OVP)[48] includes the freely available for non-commercial use simulator OVPsim, a library of models of processors, peripherals and platforms, and APIs which enable users to develop their own models. The models in the library are open source, written in C, and include the MIPS 4K, 24K, 34K, 74K, 1004K, 1074K, M14K, microAptiv, interAptiv, proAptiv 32-bit cores and the MIPS 64-bit 5K range of cores. These models are created and maintained by Imperas[49] and in partnership with MIPS Technologies have been tested and assigned the MIPS-Verified mark. Sample MIPS-based platforms include both bare metal environments and platforms for booting unmodified Linux binary images. These platforms–emulators are available as source or binaries and are fast, free for non-commercial usage, and are easy to use. OVPsim is developed and maintained by Imperas and is very fast (hundreds of million of instructions per second), and built to handle multicore homogeneous and heterogeneous architectures and systems.
There is a freely available MIPS32 simulator (earlier versions simulated only the R2000/R3000) called SPIM for use in education. EduMIPS64[50] is a GPL graphical cross-platform MIPS64 CPU simulator, written in Java/Swing. It supports a wide subset of the MIPS64 ISA and allows the user to graphically see what happens in the pipeline when an assembly program is run by the CPU.
MARS[51] is another GUI-based MIPS emulator designed for use in education, specifically for use with Hennessy's Computer Organization and Design.
WebMIPS[52] is a browser-based MIPS simulator with visual representation of a generic, pipelined processor. This simulator is quite useful for register tracking during step by step execution.
QtMips provides a simple 5-stage pipeline visualization as well as cache principle visualization for basic computer architectures courses.[53][54][55] It is available both as a web application and as a downloadable program for Windows, Linux, and macOS.
More advanced free emulators are available from the GXemul (formerly known as the mips64emul project) and QEMU projects. These emulate the various MIPS III and IV microprocessors in addition to entire computer systems which use them.
Commercial simulators are available especially for the embedded use of MIPS processors, for example Wind River Simics (MIPS 4Kc and 5Kc, PMC RM9000, QED RM7000, Broadcom/Netlogic ec4400, Cavium Octeon I), Imperas (all MIPS32 and MIPS64 cores), VaST Systems (R3000, R4000), and CoWare (the MIPS4KE, MIPS24K, MIPS25Kf and MIPS34K).
The Creator simulator[56][57][58][59][60] is portable and allows the user to learn various assembly languages of different processors (Creator has examples with an implementation of MIPS32 and RISC-V instructions).
WepSIM[61][62] is a browser-based simulator where a subset of MIPS instructions are micro-programmed. 
This simulator is very useful in order to learn how a CPU works
(microprogramming Archived July 26, 2022, at the Wayback Machine,
MIPS routines Archived July 26, 2022, at the Wayback Machine,
interruptions Archived August 20, 2022, at the Wayback Machine,
system calls Archived July 26, 2022, at the Wayback Machine,
etc.)

See also[edit]
DLX
List of MIPS architecture processors
MIPS architecture processors
Pipeline (computing)
Prpl Foundation
References[edit]


^ Patterson, David (2014). Computer Organization and Design (PDF). Elsevier. pp. 4.16–4. ISBN 978-0-12-407726-3. Archived (PDF) from the original on September 4, 2019. Retrieved November 28, 2018.

^ a b Price, Charles (September 1995). MIPS IV Instruction Set (Revision 3.2), MIPS Technologies, Inc.

^ a b c d e f g h Sweetman, Dominic (1999). See MIPS Run. Morgan Kaufmann Publishers, Inc. ISBN 1-55860-410-3.

^ "MIPS32 Architecture". MIPS. Archived from the original on March 21, 2020. Retrieved March 20, 2020.

^ "MIPS64 Architecture". MIPS. Archived from the original on February 2, 2020. Retrieved March 20, 2020.

^ "MIPS-3D ASE". Imagination Technologies. Archived from the original on January 3, 2014. Retrieved January 4, 2014.

^ "MIPS16e". MIPS. Archived from the original on January 16, 2021. Retrieved March 20, 2020.

^ "MIPS Multithreading". MIPS. Archived from the original on October 26, 2020. Retrieved March 20, 2020.

^ University of California, Davis. "ECS 142 (Compilers) References & Tools page". Archived from the original on March 21, 2011. Retrieved May 28, 2009.

^ a b Turley, Jim (March 8, 2021). "Wait, What? MIPS Becomes RISC-V". Electronic Engineering Journal. Archived from the original on March 21, 2021. Retrieved March 28, 2021.

^ "The MIPS Processor". www.d.umn.edu. Archived from the original on May 17, 2023. Retrieved May 17, 2023.

^ "Silicon Graphics Introduces Enhanced MIPS Architecture to Lead the Interactive Digital Revolution" (Press release). Silicon Graphics, Inc. October 21, 1996. Archived from the original on June 6, 1997.

^ a b Gwennap, Linley (November 18, 1996). "Digital, MIPS Add Multimedia Extensions" (PDF). Microprocessor Report. 10 (15): 24–28. Archived (PDF) from the original on July 20, 2011.

^ "Silicon Graphics Previews New High-Performance MIPS Microprocessor Roadmap" (Press release). May 12, 1997.

^ a b c d e "MIPS Technologies, Inc. Enhances Architecture to Support Growing Need for IP Re-Use and Integration" (Press release). Business Wire. May 3, 1999. Archived from the original on December 1, 2018. Retrieved February 11, 2016.

^ "Latest Release of MIPS Architecture Includes Virtualization and SIMD Key Functionality for Enabling Next Generation of MIPS-Based Products" (Press release). MIPS Technologies. December 6, 2012. Archived from the original on December 13, 2012.

^ "MIPS skips Release 4 amid bidding war". EE Times. December 10, 2012. Archived from the original on April 17, 2014.

^ "Wave Computing Extends AI Lead by Targeting Edge of Cloud Through Acquisition of MIPS". June 15, 2018. Archived from the original on November 25, 2020. Retrieved December 19, 2018.

^ "Wave Computing® Launches the MIPS Open Initiative To Accelerate Innovation for the Renowned MIPS® Architecture". December 17, 2018. Archived from the original on July 28, 2021. Retrieved December 19, 2018.

^ "MIPS Processor ISA To Be Open-Sourced In 2019 - Phoronix". Archived from the original on March 6, 2021. Retrieved December 18, 2018.

^ Yoshida, Junko (December 17, 2018). "MIPS Goes Open Source". EE Times. Archived from the original on July 5, 2022. Retrieved July 18, 2022.

^ "MIPS R6 Architecture Now Available for Open Use". March 28, 2019. Archived from the original on August 4, 2020. Retrieved December 16, 2019.

^ "Wave Computing Closes Its MIPS Open Initiative with Immediate Effect, Zero Warning". November 15, 2019. Archived from the original on March 7, 2021. Retrieved December 16, 2019.

^ "Wave Computing and MIPS emerge from chapter 11 bankruptcy" (Press release). March 1, 2021. Archived from the original on May 13, 2021. Retrieved March 11, 2021.

^ Shilov, Anton (August 25, 2021). "Loongson Rips MIPS: Uses Old Code for New CPUs". Tom's Hardware. Archived from the original on January 25, 2022. Retrieved December 1, 2021.

^ Connatser, Matthew (January 19, 2024). "Chinese chipmaker Loongson wins case over rights to MIPS architecture - company's new CPU architecture heavily resembles existing MIPS". Tom's Hardware. Archived from the original on January 19, 2024. Retrieved January 19, 2024.

^ Harris, David Money; Harris, Sarah L. (2013). "Architecture". Digital Design and Computer Architecture. Elsevier. pp. 294–369. doi:10.1016/b978-0-12-394424-5.00006-9. ISBN 9780123944245. R-type is short for register-type. R-type instructions use three registers as operands: two as sources, and one as a destination.

^ a b "APPLICATION NOTE MIPS R4000 Synchronization Primitives" (PDF). p. 5. Archived (PDF) from the original on December 27, 2023. Retrieved December 27, 2023.

^ MIPS IV Instruction Set (PDF) (Revision 3.2 ed.). MIPS Technologies. September 1995. Archived (PDF) from the original on November 27, 2022. Retrieved August 24, 2022.

^ "MIPS instruction set R5" (PDF). p. 59-62. Archived (PDF) from the original on December 15, 2023. Retrieved December 15, 2023.

^ "MIPS® Coherence Protocol Specification, Revision 01.01" (PDF). p. 26,25,57. Archived (PDF) from the original on September 4, 2018. Retrieved December 15, 2023.

^ "MIPS – Market-leading RISC CPU IP processor solutions". imgtec.com. Archived from the original on March 9, 2016. Retrieved February 11, 2016.

^ "Silicon Graphics Introduces Compact MIPS RISC Microprocessor Code For High Performance at a Low Cost" (Press release). October 21, 1996.

^ Sweetman, Dominic (2007). See MIPS Run (2nd ed.). San Francisco, California: Morgan Kaufmann Publishers. pp. 425–427. ISBN 978-0-12-088421-6.

^ "Using the GNU Compiler Collection (GCC): MIPS DSP Built-in Functions". gcc.gnu.org. Archived from the original on April 20, 2017.

^ "Instruction Set Architecture - LinuxMIPS". www.linux-mips.org. Archived from the original on April 20, 2017.

^ Sweetman, Dominic (2007). See MIPS Run, 2nd edition. Morgan Kaufmann. ISBN 978-0-12088-421-6.

^ "MIPS32 Instruction Set Quick Reference". Archived (PDF) from the original on January 25, 2022. Retrieved August 17, 2020.

^ a b "MIPS ABI History". Archived from the original on August 26, 2018.

^ Eric Christopher (June 11, 2003). "mips eabi documentation". binutils@sources.redhat.com (Mailing list). Archived from the original on May 7, 2020. Retrieved June 19, 2020.

^ "NUBI". Archived from the original on July 29, 2021. Retrieved August 17, 2020.

^ Karen Miller (2006). "The MIPS Register Usage Conventions". Archived from the original on October 25, 2020.

^ Hal Perkins (2006). "MIPS Calling Convention" (PDF). Archived (PDF) from the original on September 30, 2020.

^ MIPSpro N32 ABI Handbook (PDF). Silicon Graphics. Archived from the original (PDF) on December 17, 2021. Retrieved August 17, 2020.

^ "PIC code – LinuxMIPS". www.linux-mips.org. Archived from the original on September 21, 2018. Retrieved September 21, 2018.

^ "System V Application Binary Interface MIPS RISC Processor Supplement, 3rd Edition" (PDF). pp. 3–12. Archived (PDF) from the original on November 12, 2020. Retrieved August 17, 2020.

^ Rubio, Victor P. "A FPGA Implementation of a MIPS RISC Processor for Computer Architecture Education" (PDF). New Mexico State University. Archived (PDF) from the original on April 15, 2012. Retrieved December 22, 2011.

^ "OVP: Fast Simulation, Free Open Source Models. Virtual Platforms for software development". Ovpworld.org. Archived from the original on June 8, 2012. Retrieved May 30, 2012.

^ "Imperas". Imperas. March 3, 2008. Archived from the original on June 14, 2012. Retrieved May 30, 2012.

^ "EduMIPS64". Edumips.org. Archived from the original on May 7, 2012. Retrieved May 30, 2012.

^ "MARS MIPS simulator - Missouri State University". Courses.missouristate.edu. Archived from the original on May 2, 2012. Retrieved May 30, 2012.

^ "WebMIPS - MIPS CPU PIPLINED SIMULATION On Line". Archived from the original on December 31, 2012. Retrieved January 13, 2012. (online demonstration) "Archived copy". Archived from the original on October 10, 2011. Retrieved January 13, 2012.{{cite web}}:  CS1 maint: archived copy as title (link) (source)

^ QtMips - MIPS CPU simulator for education purposes on GitHub

^ Kočí, Karel (2018). Graphical CPU Simulator with Cache Visualization (PDF) (MSc). Czech Technical University in Prague. Archived (PDF) from the original on November 19, 2020. Retrieved January 25, 2021.

^ Gizopoulos, Dimitris (December 6, 2020). "The basics of QtMips-v3" (PDF). National and Kapodistrian University of Athens. Retrieved January 25, 2021.[dead link]

^ Camarmas-Alonso, Diego; Garcia-Carballeira, Felix; Del-Pozo-Punal, Elias; Mateos, Alejandro Calderon (May 29, 2024). "CREATOR: An Educational Integrated Development Environment for RISC-V Programming". IEEE Access: 1–17. doi:10.1109/ACCESS.2024.3406935. ISSN 2169-3536. Retrieved July 24, 2024.

^ "CREATOR: Simulador didáctico y genérico para la programación en ensamblador" (in Spanish). July 23, 2021. Archived from the original on September 29, 2021. Retrieved September 29, 2021.

^ Camarmas-Alonso, Diego; Garcia-Carballeira, Felix; Del-Pozo-Punal, Elias; Mateos, Alejandro Calderon (August 2, 2022). A new generic simulator for the teaching of assembly programming. 2021 XLVII Latin American Computing Conference (CLEI) (in Spanish). pp. 1–9. doi:10.1109/CLEI53233.2021.9640144. ISBN 978-1-6654-9503-5. S2CID 245387555. Retrieved August 2, 2022.

^ "CREATOR Web with MIPS32 example". Archived from the original on September 29, 2021.

^ CREATOR source code on GitHub

^ "WepSIM with a MIPS32 example". WepSIM. Archived from the original on July 25, 2022. Retrieved July 25, 2022.

^ WepSIM source code on GitHub


Further reading[edit]
Farquhar, Erin; Philip Bunce (1994). MIPS Programmer's Handbook. Morgan Kaufmann Publishers. ISBN 1-55860-297-6.
Patterson, David A; John L. Hennessy (2004). Computer Organization and Design: The Hardware/Software Interface. Morgan Kaufmann Publishers. ISBN 1-55860-604-1.
Sweetman, Dominic (1999). See MIPS Run. Morgan Kaufmann Publishers. ISBN 1-55860-410-3.
Sweetman, Dominic (2007). See MIPS Run, 2nd edition. Morgan Kaufmann Publishers. ISBN 978-0-12-088421-6.
External links[edit]



Wikibooks has a book on the topic of: MIPS Assembly




Wikimedia Commons has media related to MIPS microprocessors.

MIPS Processors Archived May 11, 2022, at the Wayback Machine
MIPS Architecture history diagram at the Wayback Machine (archived 2013-05-30)
Online MIPS emulator Archived March 5, 2022, at the Wayback Machine
MIPS Instructions - MIPS Instruction Set Archived April 7, 2022, at the Wayback Machine
vteMIPS microprocessors
MIPS architecture
MIPS architecture processors
List of MIPS architecture processors
GeneralprocessorsMIPS64compatible
Loongson 3 Series
LS3A1000/LS3A1000-I(LS3A1000-i)
LS3A2000/LS3A1500-I
LS3A3000/LS3A3000-I(LS3A3000-i)
LS3A4000/LS3A4000-I(LS3A4000-i)
LS3B1000
LS3B1500
LS3B2000
LS3B3000
LS3B4000
ApplicationprocessorsMIPS32compatible
Ingenic XBurst
JZ4720
Ben NanoNote
JZ4730 (Skytone Alpha-400)
JZ4740 (Dingoo A320)
JZ4750 (Game Gadget)
JZ4760
Velocity Micro T103 Cruz
Velocity Micro T301 Cruz
JZ4770
Ainol Novo7 Paladin
NEOGEO-X
GCW-Zero
JZ4780
MIPS64compatible
Loongson 2 Series
LS2H
LS2K1000/LS2K2000
Microcontrollers(embedded device)M4K
Microchip Technology PIC32MX
4Kc/4KEc
ATI/AMD/Broadcom Xilleon
MIPS32compatible
Loongson 1 Series
LS1A0300
LS1B
LS1C300
LS1C101
LS1D
LS1G
LS1H
Networking4Kc/4KEc
Qualcomm Atheros
AR2313
AR2318
MediaTek
RT2880
Texas Instruments/Infineon/Lantiq
AR7
Lantiq
AMAZON
5Kc
Marvell
88E6318 "Link Street"
24Kc/24KEc
Qualcomm Atheros
AR7240
AR7161
AR9132
AR9331
MediaTek
RT3050
RT3052
RT3350
RT5350
RT6856
MT7620
MT7628
MT7688
Lantiq
DANUBE
VINAX
34Kc
Lantiq
AR188
VRX288
GRX388
Ikanos
Fusiv Vx175/173
Fusiv Vx180
Fusiv Vx185/183
74Kc
Qualcomm Atheros
AR9344
QCA9558
MediaTek
RT3662
RT3883
Broadcom
BCM4706
1004Kc
MediaTek
MT7621
1074Kc
Realtek
RTL8198C
MIPS32compatible
Broadcom
various
Cavium
various
Alchemy Semiconductor
Alchemy
RMI Corporation
XLR
MIPS64compatible
Broadcom
various
Cavium
Octeon
Gamingvarious
PlayStation 1 MIPS R3000A-compatible
Nintendo 64 NEC VR4300
PlayStation Portable R4000-based
PlayStation 2 Emotion Engine
SupercomputerMIPS64compatible
Loongson-based systems
LS2F/LS2F1000
LS3A1000
LS3B1000
SiCortex
AerospaceMIPS64compatible
Loongson 1 Series
LS1E0300/LS1E1000
MIPS32compatible
Loongson 1 Series
LS1E04
LS1F04/LS1F0300
LS1J
ClassicprocessorsMIPS I
R2000
R3000
MIPS II
R6000
MIPS III
R4000
R4400
R4200
R4300i
R4600
R4700
MIPS IV
R5000
R8000
R10000
R12000
R12000A
R14000
R14000A
R16000
R16000A
R18000
MIPS V
H1 "Beast"
H2 "Capitan"

vteReduced instruction set computer (RISC) architecturesOrigins
IBM 801
Berkeley RISC
Stanford MIPS
In active development
Analog Devices Blackfin
ARC
ARM
AVR
eSi-RISC
LatticeMico8, LatticeMico32
MIPS
OpenRISC
Power ISA
Renesas M32R, SuperH, V850
RISC-V
SPARC
Sunway
Unicore
Xilinx MicroBlaze, PicoBlaze
Development discontinued
Alpha
AMD Am29000
Apollo PRISM
Atmel AVR32
Clipper
CR16
CRISP
DEC PRISM
Intel i860, i960
META
MIPS-X
Motorola 88000, M·CORE
PA-RISC
POWER, PowerPC (active use in space exploration as RAD750), ROMP

vteProcessor technologiesModels
Abstract machine
Stored-program computer
Finite-state machine
with datapath
Hierarchical
Deterministic finite automaton
Queue automaton
Cellular automaton
Quantum cellular automaton
Turing machine
Alternating Turing machine
Universal
Post–Turing
Quantum
Nondeterministic Turing machine
Probabilistic Turing machine
Hypercomputation
Zeno machine
Belt machine
Stack machine
Register machines
Counter
Pointer
Random-access
Random-access stored program
Architecture
Microarchitecture
Von Neumann
Harvard
modified
Dataflow
Transport-triggered
Cellular
Endianness
Memory access
NUMA
HUMA
Load–store
Register/memory
Cache hierarchy
Memory hierarchy
Virtual memory
Secondary storage
Heterogeneous
Fabric
Multiprocessing
Cognitive
Neuromorphic
Instruction setarchitecturesTypes
Orthogonal instruction set
CISC
RISC
Application-specific
EDGE
TRIPS
VLIW
EPIC
MISC
OISC
NISC
ZISC
VISC architecture
Quantum computing
Comparison
Addressing modes
Instructionsets
Motorola 68000 series
VAX
PDP-11
x86
ARM
Stanford MIPS
MIPS
MIPS-X
Power
POWER
PowerPC
Power ISA
Clipper architecture
SPARC
SuperH
DEC Alpha
ETRAX CRIS
M32R
Unicore
Itanium
OpenRISC
RISC-V
MicroBlaze
LMC
System/3x0
S/360
S/370
S/390
z/Architecture
Tilera ISA
VISC architecture
Epiphany architecture
Others
ExecutionInstruction pipelining
Pipeline stall
Operand forwarding
Classic RISC pipeline
Hazards
Data dependency
Structural
Control
False sharing
Out-of-order
Scoreboarding
Tomasulo's algorithm
Reservation station
Re-order buffer
Register renaming
Wide-issue
Speculative
Branch prediction
Memory dependence prediction
ParallelismLevel
Bit
Bit-serial
Word
Instruction
Pipelining
Scalar
Superscalar
Task
Thread
Process
Data
Vector
Memory
Distributed
Multithreading
Temporal
Simultaneous
Hyperthreading
Simultaneous and heterogenous
Speculative
Preemptive
Cooperative
Flynn's taxonomy
SISD
SIMD
Array processing (SIMT)
Pipelined processing
Associative processing
SWAR
MISD
MIMD
SPMD
Processorperformance
Transistor count
Instructions per cycle (IPC)
Cycles per instruction (CPI)
Instructions per second (IPS)
Floating-point operations per second (FLOPS)
Transactions per second (TPS)
Synaptic updates per second (SUPS)
Performance per watt (PPW)
Cache performance metrics
Computer performance by orders of magnitude
Types
Central processing unit (CPU)
Graphics processing unit (GPU)
GPGPU
Vector
Barrel
Stream
Tile processor
Coprocessor
PAL
ASIC
FPGA
FPOA
CPLD
Multi-chip module (MCM)
System in a package (SiP)
Package on a package (PoP)
By application
Embedded system
Microprocessor
Microcontroller
Mobile
Ultra-low-voltage
ASIP
Soft microprocessor
Systemson chip
System on a chip (SoC)
Multiprocessor (MPSoC)
Cypress PSoC
Network on a chip (NoC)
Hardwareaccelerators
Coprocessor
AI accelerator
Graphics processing unit (GPU)
Image processor
Vision processing unit (VPU)
Physics processing unit (PPU)
Digital signal processor (DSP)
Tensor Processing Unit (TPU)
Secure cryptoprocessor
Network processor
Baseband processor

Word size
1-bit
4-bit
8-bit
12-bit
15-bit
16-bit
24-bit
32-bit
48-bit
64-bit
128-bit
256-bit
512-bit
bit slicing
others
variable
Core count
Single-core
Multi-core
Manycore
Heterogeneous architecture
Components
Core
Cache
CPU cache
Scratchpad memory
Data cache
Instruction cache
replacement policies
coherence
Bus
Clock rate
Clock signal
FIFO
Functionalunits
Arithmetic logic unit (ALU)
Address generation unit (AGU)
Floating-point unit (FPU)
Memory management unit (MMU)
Load–store unit
Translation lookaside buffer (TLB)
Branch predictor
Branch target predictor
Integrated memory controller (IMC)
Memory management unit
Instruction decoder
Logic
Combinational
Sequential
Glue
Logic gate
Quantum
Array
Registers
Processor register
Status register
Stack register
Register file
Memory buffer
Memory address register
Program counter
Control unit
Hardwired control unit
Instruction unit
Data buffer
Write buffer
Microcode ROM
Counter
Datapath
Multiplexer
Demultiplexer
Adder
Multiplier
CPU
Binary decoder
Address decoder
Sum-addressed decoder
Barrel shifter
Circuitry
Integrated circuit
3D
Mixed-signal
Power management
Boolean
Digital
Analog
Quantum
Switch

Powermanagement
PMU
APM
ACPI
Dynamic frequency scaling
Dynamic voltage scaling
Clock gating
Performance per watt (PPW)
Related
History of general-purpose CPUs
Microprocessor chronology
Processor design
Digital electronics
Hardware security module
Semiconductor device fabrication
Tick–tock model
Pin grid array
Chip carrier

Authority control databases: National United StatesIsrael




Retrieved from "https://en.wikipedia.org/w/index.php?title=MIPS_architecture&oldid=1273092561"
Categories: MIPS architectureAdvanced RISC ComputingComputer-related introductions in 1985MIPS TechnologiesHidden categories: CS1 maint: archived copy as titleAll articles with dead external linksArticles with dead external links from February 2022CS1 Spanish-language sources (es)Articles with short descriptionShort description matches WikidataUse mdy dates from November 2021Articles to be expanded from February 2020All articles to be expandedAll articles with failed verificationArticles with failed verification from May 2023All articles with unsourced statementsArticles with unsourced statements from June 2016Wikipedia articles in need of updating from August 2020All Wikipedia articles in need of updatingWebarchive template wayback linksCommons category link is on Wikidata






 This page was last edited on 31 January 2025, at 17:21 (UTC).
Text is available under the Creative Commons Attribution-ShareAlike 4.0 License;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.


Privacy policy
About Wikipedia
Disclaimers
Contact Wikipedia
Code of Conduct
Developers
Statistics
Cookie statement
Mobile view














Search













Search









Toggle the table of contents







MIPS architecture




























31 languages


Add topic
















