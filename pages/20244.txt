https://en.wikipedia.org/wiki/Microcode




Microcode - Wikipedia



























Jump to content







Main menu





Main menu
move to sidebar
hide



		Navigation
	


Main pageContentsCurrent eventsRandom articleAbout WikipediaContact us





		Contribute
	


HelpLearn to editCommunity portalRecent changesUpload fileSpecial pages



















Search











Search






















Appearance
















Donate

Create account

Log in








Personal tools





Donate Create account Log in





		Pages for logged out editors learn more



ContributionsTalk




























Contents
move to sidebar
hide




(Top)





1
Overview




Toggle Overview subsection





1.1
Instruction sets








1.2
Microcode








1.3
Design








1.4
Microprograms










2
Justification




Toggle Justification subsection





2.1
Benefits










3
History




Toggle History subsection





3.1
Early examples








3.2
The 360








3.3
Moving up the line








3.4
RISC enters










4
Examples








5
Implementation




Toggle Implementation subsection





5.1
Horizontal microcode








5.2
Vertical microcode










6
Writable control store








7
Comparison to VLIW and RISC








8
Micro-operations








9
See also








10
Notes








11
References








12
Further reading








13
External links


















Toggle the table of contents







Microcode



31 languages




العربيةAzərbaycancaBosanskiCatalàDanskDeutschEestiEspañolEsperantoفارسیFrançais한국어ՀայերենHrvatskiItalianoעבריתҚазақшаമലയാളംNederlands日本語Norsk bokmålPolskiРусскийSimple EnglishСрпски / srpskiSrpskohrvatski / српскохрватскиSuomiSvenskaTürkçeУкраїнська中文

Edit links











ArticleTalk





English

















ReadEditView history







Tools





Tools
move to sidebar
hide



		Actions
	


ReadEditView history





		General
	


What links hereRelated changesUpload filePermanent linkPage informationCite this pageGet shortened URLDownload QR code





		Print/export
	


Download as PDFPrintable version





		In other projects
	


Wikimedia CommonsWikidata item





















Appearance
move to sidebar
hide










From Wikipedia, the free encyclopedia


Layer of hardware-level instructions or data structures
For the CAD software vendor, see MicroCode Engineering, Inc.
Program execution
General concepts
Code
Translation
Compiler
Compile time
Optimizing compiler
Intermediate representation (IR)
Execution
Runtime system
Runtime
Executable
Interpreter
Virtual machine

Types of code
Source code
Object code
Bytecode
Machine code
Microcode

Compilation strategies
Ahead-of-time (AOT)
Just-in-time (JIT)
Tracing just-in-time
Compile and go system
Precompilation
Transcompilation
Recompilation

Notable runtimes
Android Runtime (ART)
BEAM (Erlang)
Common Language Runtime (CLR) and Mono
CPython and PyPy
crt0 (C target-specific initializer)
Java virtual machine (JVM)
LuaJIT
Objective-C and Swift's
V8 and Node.js
Zend Engine (PHP)

Notable compilers & toolchains
GNU Compiler Collection (GCC)
LLVM and Clang
MSVC
Glasgow Haskell Compiler (GHC)
vte
In processor design, microcode serves as an intermediary layer situated between the central processing unit (CPU) hardware and the programmer-visible instruction set architecture of a computer, also known as its machine code.[1][page needed] It consists of a set of hardware-level instructions that implement the higher-level machine code instructions or control internal finite-state machine sequencing in many digital processing components. While microcode is utilized in Intel and AMD general-purpose CPUs in contemporary desktops and laptops, it functions only as a fallback path for scenarios that the faster hardwired control unit is unable to manage.[2]
Housed in special high-speed memory, microcode translates machine instructions, state machine data, or other input into sequences of detailed circuit-level operations. It separates the machine instructions from the underlying electronics, thereby enabling greater flexibility in designing and altering instructions. Moreover, it facilitates the construction of complex multi-step instructions, while simultaneously reducing the complexity of computer circuits. The act of writing microcode is often referred to as microprogramming, and the microcode in a specific processor implementation is sometimes termed a microprogram.
Through extensive microprogramming, microarchitectures of smaller scale and simplicity can emulate more robust architectures with wider word lengths, additional execution units, and so forth. This approach provides a relatively straightforward method of ensuring software compatibility between different products within a processor family.
Some hardware vendors, notably IBM and Lenovo, use the term microcode interchangeably with firmware. In this context, all code within a device is termed microcode, whether it is microcode or machine code. For instance, updates to a hard disk drive's microcode often encompass updates to both its microcode and firmware.[3]


Overview[edit]
Instruction sets[edit]
At the hardware level, processors contain a number of separate areas of circuitry, or "units", that perform different tasks. Commonly found units include the arithmetic logic unit (ALU) which performs instructions such as addition or comparing two numbers, circuits for reading and writing data to external memory, and small areas of onboard memory to store these values while they are being processed. In most designs, additional high-performance memory, the register file, is used to store temporary values, not just those needed by the current instruction.[4]
To properly perform an instruction, the various circuits have to be activated in order. For instance, it is not possible to add two numbers if they have not yet been loaded from memory. In RISC designs, the proper ordering of these instructions is largely up to the programmer, or at least to the compiler of the programming language they are using. So to add two numbers, for instance, the compiler may output instructions to load one of the values into one register, the second into another, call the addition function in the ALU, and then write the result back out to memory.[4]
As the sequence of instructions needed to complete this higher-level concept, "add these two numbers in memory", may require multiple instructions, this can represent a performance bottleneck if those instructions are stored in main memory. Reading those instructions one by one is taking up time that could be used to read and write the actual data. For this reason, it is common for non-RISC designs to have many different instructions that differ largely on where they store data. For instance, the MOS 6502 has eight variations of the addition instruction, ADC, which differ only in where they look to find the two operands.[5]
Using the variation of the instruction, or "opcode", that most closely matches the ultimate operation can reduce the number of instructions to one, saving memory used by the program code and improving performance by leaving the data bus open for other operations. Internally, however, these instructions are not separate operations, but sequences of the operations the units actually perform. Converting a single instruction read from memory into the sequence of internal actions is the duty of the control unit, another unit within the processor.[6]

Microcode[edit]
The basic idea behind microcode is to replace the custom hardware logic implementing the instruction sequencing with a series of simple instructions run in a "microcode engine" in the processor. Whereas a custom logic system might have a series of diodes and gates that output a series of voltages on various control lines, the microcode engine is connected to these lines instead, and these are turned on and off as the engine reads the microcode instructions in sequence. The microcode instructions are often bit encoded to those lines, for instance, if bit 8 is true, that might mean that the ALU should be paused awaiting data. In this respect microcode is somewhat similar to the paper rolls in a player piano, where the holes represent which key should be pressed.
The distinction between custom logic and microcode may seem small, one uses a pattern of diodes and gates to decode the instruction and produce a sequence of signals, whereas the other encodes the signals as microinstructions that are read in sequence to produce the same results. The critical difference is that in a custom logic design, changes to the individual steps require the hardware to be redesigned. Using microcode, all that changes is the code stored in the memory containing the microcode. This makes it much easier to fix problems in a microcode system. It also means that there is no effective limit to the complexity of the instructions, it is only limited by the amount of memory one is willing to use.
The lowest layer in a computer's software stack is traditionally raw machine code instructions for the processor. In microcoded processors, fetching and decoding those instructions, and executing them, may be done by microcode. To avoid confusion, each microprogram-related element is differentiated by the micro prefix: microinstruction, microassembler, microprogrammer, etc.[7]
Complex digital processors may also employ more than one (possibly microcode-based) control unit in order to delegate sub-tasks that must be performed essentially asynchronously in parallel.  For example, the VAX 9000 has a hardwired IBox unit to fetch and decode instructions, which it hands to a microcoded EBox unit to be executed,[8] and the VAX 8800 has both a microcoded IBox and a microcoded EBox.[9]
A high-level programmer, or even an assembly language programmer, does not normally see or change microcode. Unlike machine code, which often retains some backward compatibility among different processors in a family, microcode only runs on the exact electronic circuitry for which it is designed, as it constitutes an inherent part of the particular processor design itself.

Design[edit]
Engineers normally write the microcode during the design phase of a processor, storing it in a read-only memory (ROM) or programmable logic array (PLA)[10] structure, or in a combination of both.[11] However, machines also exist that have some or all microcode stored in static random-access memory (SRAM) or flash memory. This is traditionally denoted as writable control store in the context of computers, which can be either read-only or read–write memory. In the latter case, the CPU initialization process loads microcode into the control store from another storage medium, with the possibility of altering the microcode to correct bugs in the instruction set, or to implement new machine instructions.

Microprograms[edit]
Microprograms consist of series of microinstructions, which control the CPU at a very fundamental level of hardware circuitry. For example, a single typical horizontal microinstruction might specify the following operations:

Connect register 1 to the A side of the ALU
Connect register 7 to the B side of the ALU
Set the ALU to perform two's-complement addition
Set the ALU's carry input to zero
Store the result value in register 8
Update the condition codes from the ALU status flags (negative, zero, overflow, and carry)
Microjump to a given μPC address for the next microinstruction
To simultaneously control all processor's features in one cycle, the microinstruction is often wider than 50 bits; e.g., 128 bits on a 360/85 with an emulator feature. Microprograms are carefully designed and optimized for the fastest possible execution, as a slow microprogram would result in a slow machine instruction and degraded performance for related application programs that use such instructions.

Justification[edit]
Microcode was originally developed as a simpler method of developing the control logic for a computer. Initially, CPU instruction sets were hardwired. Each step needed to fetch, decode, and execute the machine instructions (including any operand address calculations, reads, and writes) was controlled directly by combinational logic and rather minimal sequential state machine circuitry. While such hard-wired processors were very efficient, the need for powerful instruction sets with multi-step addressing and complex operations (see below) made them difficult to design and debug; highly encoded and varied-length instructions can contribute to this as well, especially when very irregular encodings are used.
Microcode simplified the job by allowing much of the processor's behaviour and programming model to be defined via microprogram routines rather than by dedicated circuitry. Even late in the design process, microcode could easily be changed, whereas hard-wired CPU designs were very cumbersome to change. Thus, this greatly facilitated CPU design.
From the 1940s to the late 1970s, a large portion of programming was done in assembly language; higher-level instructions mean greater programmer productivity, so an important advantage of microcode was the relative ease by which powerful machine instructions can be defined. The ultimate extension of this are "Directly Executable High Level Language" designs, in which each statement of a high-level language such as PL/I is entirely and directly executed by microcode, without compilation. The IBM Future Systems project and Data General Fountainhead Processor are examples of this. During the 1970s, CPU speeds grew more quickly than memory speeds and numerous techniques such as memory block transfer, memory pre-fetch and multi-level caches were used to alleviate this. High-level machine instructions, made possible by microcode, helped further, as fewer more complex machine instructions require less memory bandwidth. For example, an operation on a character string can be done as a single machine instruction, thus avoiding multiple instruction fetches.
Architectures with instruction sets implemented by complex microprograms included the IBM System/360 and Digital Equipment Corporation VAX. The approach of increasingly complex microcode-implemented instruction sets was later called complex instruction set computer (CISC). An alternate approach, used in many microprocessors, is to use one or more programmable logic array (PLA) or read-only memory (ROM) (instead of combinational logic) mainly for instruction decoding, and let a simple state machine (without much, or any, microcode) do most of the sequencing. The MOS Technology 6502 is an example of a microprocessor using a PLA for instruction decode and sequencing. The PLA is visible in photomicrographs of the chip,[12] and its operation can be seen in the transistor-level simulation.
Microprogramming is still used in modern CPU designs. In some cases, after the microcode is debugged in simulation, logic functions are substituted for the control store.[citation needed] Logic functions are often faster and less expensive than the equivalent microprogram memory.

Benefits[edit]
A processor's microprograms operate on a more primitive, totally different, and much more hardware-oriented architecture than the assembly instructions visible to normal programmers. In coordination with the hardware, the microcode implements the programmer-visible architecture. The underlying hardware need not have a fixed relationship to the visible architecture. This makes it easier to implement a given instruction set architecture on a wide variety of underlying hardware micro-architectures.
The IBM System/360 has a 32-bit architecture with 16 general-purpose registers, but most of the System/360 implementations use hardware that implements a much simpler underlying microarchitecture; for example, the System/360 Model 30 has 8-bit data paths to the arithmetic logic unit (ALU) and main memory and implemented the general-purpose registers in a special unit of higher-speed core memory, and the System/360 Model 40 has 8-bit data paths to the ALU and 16-bit data paths to main memory and also implemented the general-purpose registers in a special unit of higher-speed core memory. The Model 50 has full 32-bit data paths and implements the general-purpose registers in a special unit of higher-speed core memory.[13] The Model 65 through the Model 195 have larger data paths and implement the general-purpose registers in faster transistor circuits.[citation needed] In this way, microprogramming enabled IBM to design many System/360 models with substantially different hardware and spanning a wide range of cost and performance, while making them all architecturally compatible. This dramatically reduces the number of unique system software programs that must be written for each model.
A similar approach was used by Digital Equipment Corporation (DEC) in their VAX family of computers. As a result, different VAX processors use different microarchitectures, yet the programmer-visible architecture does not change.
Microprogramming also reduces the cost of field changes to correct defects (bugs) in the processor; a bug can often be fixed by replacing a portion of the microprogram rather than by changes being made to hardware logic and wiring.

History[edit]
Early examples[edit]
In 1947, the design of the MIT Whirlwind introduced the concept of a control store as a way to simplify computer design and move beyond ad hoc methods. The control store is a diode matrix: a two-dimensional lattice, where one dimension accepts "control time pulses" from the CPU's internal clock, and the other connects to control signals on gates and other circuits. A "pulse distributor" takes the pulses generated by the CPU clock and breaks them up into eight separate time pulses, each of which activates a different row of the lattice. When the row is activated, it activates the control signals connected to it.[14]
In 1951, Maurice Wilkes[15] enhanced this concept by adding conditional execution, a concept akin to a conditional in computer software. His initial implementation consisted of a pair of matrices: the first one generated signals in the manner of the Whirlwind control store, while the second matrix selected which row of signals (the microprogram instruction word, so to speak) to invoke on the next cycle. Conditionals were implemented by providing a way that a single line in the control store could choose from alternatives in the second matrix. This made the control signals conditional on the detected internal signal. Wilkes coined the term microprogramming to describe this feature and distinguish it from a simple control store.

The 360[edit]
Main article: System/360
Microcode remained relatively rare in computer design as the cost of the ROM needed to store the code was not significantly different from the cost of custom control logic. This changed through the early 1960s with the introduction of mass-produced core memory and core rope, which was far less expensive than dedicated logic based on diode arrays or similar solutions. The first to take real advantage of this was IBM in their 1964 System/360 series. This allowed the machines to have a very complex instruction set, including operations that matched high-level language constructs like formatting binary values as decimal strings, encoding the complex series of internal steps needed for this task in low cost memory.[16]
But the real value in the 360 line was that one could build a series of machines that were completely different internally, yet run the same ISA. For a low-end machine, one might use an 8-bit ALU that requires multiple cycles to complete a single 32-bit addition, while a higher end machine might have a full 32-bit ALU that performs the same addition in a single cycle. These differences could be implemented in control logic, but the cost of implementing a completely different decoder for each machine would be prohibitive. Using microcode meant all that changed was the code in the ROM. For instance, one machine might include a floating point unit and thus its microcode for multiplying two numbers might be only a few lines line, whereas on the same machine without the FPU this would be a program that did the same using multiple additions, and all that changed was the ROM.[16]
The outcome of this design was that customers could use a low-end model of the family to develop their software, knowing that if more performance was ever needed, they could move to a faster version and nothing else would change. This lowered the barrier to entry and the 360 was a runaway success. By the end of the decade, the use of microcode was de rigueur across the mainframe industry.

Moving up the line[edit]
The microcode (and "nanocode") of the Motorola 68000 is stored in the two large square blocks in the upper right and controlled by circuitry to the right of it. It takes up a significant amount of the total chip surface.
Early minicomputers were far too simple to require microcode, and were more similar to earlier mainframes in terms of their instruction sets and the way they were decoded. But it was not long before their designers began using more powerful integrated circuits that allowed for more complex ISAs. By the mid-1970s, most new minicomputers and superminicomputers were using microcode as well, such as most models of the PDP-11 and, most notably, most models of the VAX, which included high-level instruction not unlike those found in the 360.[17]
The same basic evolution occurred with microprocessors as well. Early designs were extremely simple, and even the more powerful 8-bit designs of the mid-1970s like the Zilog Z80 had instruction sets that were simple enough to be implemented in dedicated logic. By this time, the control logic could be patterned into the same die as the CPU, making the difference in cost between ROM and logic less of an issue. However, it was not long before these companies were also facing the problem of introducing higher-performance designs but still wanting to offer backward compatibility. Among early examples of microcode in micros was the Intel 8086.[6]
Among the ultimate implementations of microcode in microprocessors is the Motorola 68000. This offered a highly orthogonal instruction set with a wide variety of addressing modes, all implemented in microcode. This did not come without cost, according to early articles, about 20% of the chip's surface area (and thus cost) is the microcode system[18] and [citation needed] of the systems 68,000 transistors were part of the microcode system.

RISC enters[edit]
While companies continued to compete on the complexity of their instruction sets, and the use of microcode to implement these was unquestioned, in the mid-1970s an internal project in IBM was raising serious questions about the entire concept. As part of a project to develop a high-performance all-digital telephone switch, a team led by John Cocke began examining huge volumes of performance data from their customer's 360 (and System/370) programs. This led them to notice a curious pattern: when the ISA presented multiple versions of an instruction, the compiler almost always used the simplest one, instead of the one most directly representing the code. They learned that this was because those instructions were always implemented in hardware, and thus run the fastest. Using the other instruction might offer higher performance on some machines, but there was no way to know what machine they were running on. This defeated the purpose of using microcode in the first place, which was to hide these distinctions.[19]
The team came to a radical conclusion: "Imposing microcode between a computer and its users imposes an expensive overhead in performing the most frequently executed instructions."[19]
The result of this discovery was what is today known as the RISC concept. The complex microcode engine and its associated ROM is reduced or eliminated completely, and those circuits instead dedicated to things like additional registers or a wider ALU, which increases the performance of every program. When complex sequences of instructions are needed, this is left to the compiler, which is the entire purpose of using a compiler in the first place. The basic concept was soon picked up by university researchers in California, where simulations suggested such designs would trivially outperform even the fastest conventional designs. It was one such project, at the University of California, Berkeley, that introduced the term RISC.
The industry responded to the concept of RISC with both confusion and hostility, including a famous dismissive article by the VAX team at Digital.[20] A major point of contention was that implementing the instructions outside of the processor meant it would spend much more time reading those instructions from memory, thereby slowing overall performance no matter how fast the CPU itself ran.[20] Proponents pointed out that simulations clearly showed the number of instructions was not much greater, especially when considering compiled code.[19]
The debate raged until the first commercial RISC designs emerged in the second half of the 1980s, which easily outperformed the most complex designs from other companies. By the late 1980s it was over; even DEC was abandoning microcode for their DEC Alpha designs, and CISC processors switched to using hardwired circuitry, rather than microcode, to perform many functions.  For example, the Intel 80486 uses hardwired circuitry to fetch and decode instructions, using microcode only to execute instructions; register-register move and arithmetic instructions required only one microinstruction, allowing them to be completed in one clock cycle.[21]  The Pentium Pro's fetch and decode hardware fetches instructions and decodes them into series of micro-operations that are passed on to the execution unit, which schedules and executes the micro-operations, possibly doing so out-of-order.  Complex instructions are implemented by microcode that consists of predefined sequences of micro-operations.[22]
Some processor designs use machine code that runs in a special mode, with special instructions, available only in that mode, that have access to processor-dependent hardware, to implement some low-level features of the instruction set. The DEC Alpha, a pure RISC design, used PALcode to implement features such as translation lookaside buffer (TLB) miss handling and interrupt handling,[23] as well as providing, for Alpha-based systems running OpenVMS, instructions requiring interlocked memory access that are similar to instructions provided by the VAX architecture.[23] CMOS IBM System/390 CPUs, starting with the G4 processor, and z/Architecture CPUs use millicode to implement some instructions.[24]

Examples[edit]
The Analytical engine envisioned by Charles Babbage uses pegs inserted into rotating drums to store its internal procedures.
The EMIDEC 1100[25] reputedly uses a hard-wired control store consisting of wires threaded through ferrite cores, known as "the laces".
Most models of the IBM System/360 series are microprogrammed:
The Model 25 is unique among System/360 models in using the top 16 K bytes of core storage to hold the control storage for the microprogram. The 2025 uses a 16-bit microarchitecture with seven control words (or microinstructions). After system maintenance or when changing operating mode, the microcode is loaded from the card reader, tape, or other device.[26] The IBM 1410 emulation for this model is loaded this way.
The Model 30 uses an 8-bit microarchitecture with only a few hardware registers; everything that the programmer saw is emulated by the microprogram. The microcode for this model is also held on special punched cards, which are stored inside the machine in a dedicated reader per card, called "CROS" units (Capacitor Read-Only Storage).[27]: 2–5  Another CROS unit is added for machines ordered with 1401/1440/1460 emulation[27]: 4–29  and for machines ordered with 1620 emulation.[27]: 4–75 
The Model 40 uses 56-bit control words. The 2040 box implements both the System/360 main processor and the multiplex channel (the I/O processor). This model uses TROS dedicated readers similar to CROS units, but with an inductive pickup (Transformer Read-only Store).
The Model 50 has two internal datapaths which operated in parallel: a 32-bit datapath used for arithmetic operations, and an 8-bit data path used in some logical operations. The control store uses 90-bit microinstructions.
The Model 85 has separate instruction fetch (I-unit) and execution (E-unit) to provide high performance. The I-unit is hardware controlled. The E-unit is microprogrammed; the control words are 108 bits wide on a basic 360/85 and wider if an emulator feature is installed.
The NCR 315 is microprogrammed with hand wired ferrite cores (a ROM) pulsed by a sequencer with conditional execution. Wires routed through the cores are enabled for various data and logic elements in the processor.
The Digital Equipment Corporation PDP-9 processor, KL10 and KS10 PDP-10 processors, and PDP-11 processors with the exception of the PDP-11/20, are microprogrammed.[28]
Most Data General Eclipse minicomputers are microprogrammed. The task of writing microcode for the Eclipse MV/8000 is detailed in the Pulitzer Prize-winning book titled The Soul of a New Machine.
Many systems from Burroughs are microprogrammed:
The B700 "microprocessor" execute application-level opcodes using sequences of 16-bit microinstructions stored in main memory; each of these is either a register-load operation or mapped to a single 56-bit "nanocode" instruction stored in read-only memory. This allows comparatively simple hardware to act either as a mainframe peripheral controller or to be packaged as a standalone computer.
The B1700 is implemented with radically different hardware including bit-addressable main memory but has a similar multi-layer organisation. The operating system preloads the interpreter for whatever language is required. These interpreters present different virtual machines for COBOL, Fortran, etc.
Microdata produced computers in which the microcode is accessible to the user; this allows the creation of custom assembler level instructions. Microdata's Reality operating system design makes extensive use of this capability.
The Xerox Alto workstation used a microcoded design but, unlike many computers, the microcode engine is not hidden from the programmer in a layered design. Applications take advantage of this to accelerate performance.
The IBM System/38 is described as having both horizontal and vertical microcode.[29] In practice, the processor implements an instruction set architecture named the Internal Microprogrammed Interface (IMPI) using a horizontal microcode format. The so-called vertical microcode layer implements the System/38's hardware-independent Machine Interface (MI) instruction set by translating MI code to IMPI code and executing it. Prior to the introduction of the IBM RS64 processor line, early IBM AS/400 systems used the same architecture.[30]
The Nintendo 64's Reality Coprocessor (RCP), which serves as the console's graphics processing unit and audio processor, utilizes microcode; it is possible to implement new effects or tweak the processor to achieve the desired output. Some notable examples of custom RCP microcode include the high-resolution graphics, particle engines, and unlimited draw distances found in Factor 5's Indiana Jones and the Infernal Machine, Star Wars: Rogue Squadron, and Star Wars: Battle for Naboo;[31][32] and the full motion video playback found in Angel Studios' Resident Evil 2.[33]
Further information on Nintendo 64 microcode: Nintendo 64 programming characteristics and Nintendo 64 Game Pak
The VU0 and VU1 vector units in the Sony PlayStation 2 are microprogrammable; in fact, VU1 is only accessible via microcode for the first several generations of the SDK.
The MicroCore Labs MCL86 Archived 2016-11-03 at the Wayback Machine , MCL51 Archived 2017-02-02 at the Wayback Machine and MCL65 Archived 2018-12-21 at the Wayback Machine are examples of highly encoded "vertical" microsequencer implementations of the Intel 8086/8088, 8051, and MOS 6502.
The Digital Scientific Corp. Meta 4 Series 16 computer system was a user-microprogammable system first available in 1970. The microcode had a primarily vertical style with 32-bit microinstructions.[34] The instructions were stored on replaceable program boards with a grid of bit positions. One (1) bits were represented by small metal squares that were sensed by amplifiers, zero (0) bits by the absence of the squares.[35] The system could be configured with up to 4K 16-bit words of microstore. One of Digital Scientific's products was an emulator for the IBM 1130.[36][37]
The MCP-1600 is a microprocessor made by Western Digital from 1975 through the early 1980s. It was used to implement three different computer architectures in microcode: the Pascal MicroEngine, the WD16, and the DEC LSI-11, a cost-reduced PDP-11.[38]
Earlier x86 processors are fully microcoded. x86 processors implemented patchable microcode (patch by BIOS or operating system) since Intel P6 microarchitecture and AMD K7 microarchitecture. Such processors implemented microcode ROM and microcode SRAM in their silicon.
Many video cards and network interface controllers implement patchable microcode (patch by operating system). Such microcode is patched to device's SRAM or DRAM, for example, GDDR SDRAM of a video card.
Implementation[edit]
Each microinstruction in a microprogram provides the bits that control the functional elements that internally compose a CPU. The advantage over a hard-wired CPU is that internal CPU control becomes a specialized form of a computer program. Microcode thus transforms a complex electronic design challenge (the control of a CPU) into a less complex programming challenge. To take advantage of this, a CPU is divided into several parts:

An I-unit may decode instructions in hardware and determine the microcode address for processing the instruction in parallel with the E-unit.
A microsequencer picks the next word of the control store. A sequencer is mostly a counter, but usually also has some way to jump to a different part of the control store depending on some data, usually data from the instruction register and always some part of the control store. The simplest sequencer is just a register loaded from a few bits of the control store.
A register set is a fast memory containing the data of the central processing unit. It may include registers visible to application programs, such as general-purpose registers and the program counter, and may also include other registers that are not easily accessible to the application programmer. Often the register set is a triple-ported register file; that is, two registers can be read, and a third written at the same time.
An arithmetic and logic unit performs calculations, usually addition, logical negation, a right shift, and logical AND. It often performs other functions, as well.
There may also be a memory address register and a memory data register, used to access the main computer storage. Together, these elements form an "execution unit". Most modern CPUs have several execution units. Even simple computers usually have one unit to read and write memory, and another to execute user code. These elements could often be brought together as a single chip. This chip comes in a fixed width that would form a "slice" through the execution unit. These are known as "bit slice" chips. The AMD Am2900 family is one of the best known examples of bit slice elements.[39] The parts of the execution units and the whole execution units are interconnected by a bundle of wires called a bus.
Programmers develop microprograms, using basic software tools. A microassembler allows a programmer to define the table of bits symbolically. Because of its close relationship to the underlying architecture, "microcode has several properties that make it difficult to generate using a compiler."[1] A simulator program is intended to execute the bits in the same way as the electronics, and allows much more freedom to debug the microprogram. After the microprogram is finalized, and extensively tested, it is sometimes used as the input to a computer program that constructs logic to produce the same data.[citation needed] This program is similar to those used to optimize a programmable logic array. Even without fully optimal logic, heuristically optimized logic can vastly reduce the number of transistors from the number needed for a read-only memory (ROM) control store. This reduces the cost to produce, and the electricity used by, a CPU.
Microcode can be characterized as horizontal or vertical, referring primarily to whether each microinstruction controls CPU elements with little or no decoding (horizontal microcode)[a] or requires extensive decoding by combinatorial logic before doing so (vertical microcode). Consequently, each horizontal microinstruction is wider (contains more bits) and occupies more storage space than a vertical microinstruction.

Horizontal microcode[edit]
"Horizontal microcode has several discrete micro-operations that are combined in a single microinstruction for simultaneous operation."[1] Horizontal microcode is typically contained in a fairly wide control store; it is not uncommon for each word to be 108 bits or more. On each tick of a sequencer clock a microcode word is read, decoded, and used to control the functional elements that make up the CPU.
In a typical implementation a horizontal microprogram word comprises fairly tightly defined groups of bits. For example, one simple arrangement might be:



Register source A
Register source B
Destination register
Arithmetic and logic unit operation
Type of jump
Jump address

For this type of micromachine to implement a JUMP instruction with the address following the opcode, the microcode might require two clock ticks. The engineer designing it would write microassembler source code looking something like this:

   # Any line starting with a number-sign is a comment
   # This is just a label, the ordinary way assemblers symbolically represent a 
   # memory address.
 InstructionJUMP:
       # To prepare for the next instruction, the instruction-decode microcode has already
       # moved the program counter to the memory address register. This instruction fetches
       # the target address of the jump instruction from the memory word following the
       # jump opcode, by copying from the memory data register to the memory address register.
       # This gives the memory system two clock ticks to fetch the next 
       # instruction to the memory data register for use by the instruction decode.
       # The sequencer instruction "next" means just add 1 to the control word address.
    MDR, NONE, MAR, COPY, NEXT, NONE
       # This places the address of the next instruction into the PC.
       # This gives the memory system a clock tick to finish the fetch started on the
       # previous microinstruction.
       # The sequencer instruction is to jump to the start of the instruction decode.
    MAR, 1, PC, ADD, JMP, InstructionDecode
       # The instruction decode is not shown, because it is usually a mess, very particular
       # to the exact processor being emulated. Even this example is simplified.
       # Many CPUs have several ways to calculate the address, rather than just fetching
       # it from the word following the op-code. Therefore, rather than just one
       # jump instruction, those CPUs have a family of related jump instructions.

For each tick it is common to find that only some portions of the CPU are used, with the remaining groups of bits in the microinstruction being no-ops. With careful design of hardware and microcode, this property can be exploited to parallelise operations that use different areas of the CPU; for example, in the case above, the ALU is not required during the first tick, so it could potentially be used to complete an earlier arithmetic instruction.

Vertical microcode[edit]
In vertical microcode, each microinstruction is significantly encoded, that is, the bit fields generally pass through intermediate combinatory logic that, in turn, generates the control and sequencing signals for internal CPU elements (ALU, registers, etc.). This is in contrast with horizontal microcode, in which the bit fields either directly produce the control and sequencing signals or are only minimally encoded. Consequently, vertical microcode requires smaller instruction lengths and less storage, but requires more time to decode, resulting in a slower CPU clock.[40]
Some vertical microcode is just the assembly language of a simple conventional computer that is emulating a more complex computer. Some processors, such as DEC Alpha processors and the CMOS microprocessors on later IBM mainframes System/390 and z/Architecture, use machine code, running in a special mode that gives it access to special instructions, special registers, and other hardware resources unavailable to regular machine code, to implement some instructions and other functions,[41][42] such as page table walks on Alpha processors.[43]  This is called PALcode on Alpha processors and millicode on IBM mainframe processors.
Another form of vertical microcode has two fields:



Field select
Field value

The field select selects which part of the CPU will be controlled by this word of the control store. The field value controls that part of the CPU. With this type of microcode, a designer explicitly chooses to make a slower CPU to save money by reducing the unused bits in the control store; however, the reduced complexity may increase the CPU's clock frequency, which lessens the effect of an increased number of cycles per instruction.
As transistors grew cheaper, horizontal microcode came to dominate the design of CPUs using microcode, with vertical microcode being used less often.
When both vertical and horizontal microcode are used, the horizontal microcode may be referred to as nanocode or picocode.[44]

Writable control store[edit]
Main article: Writable control store
A few computers were built using writable microcode. In this design, rather than storing the microcode in ROM or hard-wired logic, the microcode is stored in a RAM called a writable control store or WCS. Such a computer is sometimes called a writable instruction set computer (WISC).[45]
Many experimental prototype computers use writable control stores; there are also commercial machines that use writable microcode, such as the Burroughs Small Systems, early Xerox workstations, the DEC VAX 8800 (Nautilus) family, the Symbolics L- and G-machines, a number of IBM System/360 and System/370 implementations, some DEC PDP-10 machines,[46] and the Data General Eclipse MV/8000.[47]
The IBM System/370 includes a facility called Initial-Microprogram Load (IML or IMPL)[48] that can be invoked from the console, as part of power-on reset (POR) or from another processor in a tightly coupled multiprocessor complex.
Some commercial machines, for example IBM 360/85,[49][50] have both a read-only storage and a writable control store for microcode.
WCS offers several advantages including the ease of patching the microprogram and, for certain hardware generations, faster access than ROMs can provide. User-programmable WCS allows the user to optimize the machine for specific purposes.
Starting with the Pentium Pro in 1995, several x86 CPUs have writable Intel Microcode.[51][52] This, for example, has allowed bugs in the Intel Core 2 and Intel Xeon microcodes to be fixed by patching their microprograms, rather than requiring the entire chips to be replaced. A second prominent example is the set of microcode patches that Intel offered for some of their processor architectures of up to 10 years in age, in a bid to counter the security vulnerabilities discovered in their designs – Spectre and Meltdown – which went public at the start of 2018.[53][54] A microcode update can be installed by Linux,[55] FreeBSD,[56] Microsoft Windows,[57] or the motherboard BIOS.[58]
Some machines offer user-programmable writable control stores as an option, including the HP 2100, DEC PDP-11/60, TI-990/12,[59][60] and Varian Data Machines V-70 series minicomputers.

Comparison to VLIW and RISC[edit]
This section does not cite any sources. Please help improve this section by adding citations to reliable sources. Unsourced material may be challenged and removed. (August 2023) (Learn how and when to remove this message)
This section needs to be updated. The reason given is: Many CISC processors now do instruction fetch and decode in hardware, and execute most if not all instructions in hardware, and both RISC and CISC processors execute several operations per clock cycle. Please help update this article to reflect recent events or newly available information. (December 2023)
The design trend toward heavily microcoded processors with complex instructions began in the early 1960s and continued until roughly the mid-1980s. At that point the RISC design philosophy started becoming more prominent.
A CPU that uses microcode generally takes several clock cycles to execute a single instruction, one clock cycle for each step in the microprogram for that instruction. Some CISC processors include instructions that can take a very long time to execute. Such variations interfere with both interrupt latency and, what is far more important in modern systems, pipelining.
When designing a new processor, a hardwired control RISC has the following advantages over microcoded CISC:

Programming has largely moved away from assembly level, so it's no longer worthwhile to provide complex instructions for productivity reasons.
Simpler instruction sets allow direct execution by hardware, avoiding the performance penalty of microcoded execution.
Analysis shows complex instructions are rarely used, hence the machine resources devoted to them are largely wasted.
The machine resources devoted to rarely used complex instructions are better used for expediting performance of simpler, commonly used instructions.
Complex microcoded instructions may require many clock cycles that vary, and are difficult to pipeline for increased performance.
There are counterpoints as well:

The complex instructions in heavily microcoded implementations may not take much extra machine resources, except for microcode space. For example, the same ALU is often used to calculate an effective address and to compute the result from the operands, e.g., the original Z80, 8086, and others.
The simpler non-RISC instructions (i.e., involving direct memory operands) are frequently used by modern compilers. Even immediate to stack (i.e., memory result) arithmetic operations are commonly employed. Although such memory operations, often with varying length encodings, are more difficult to pipeline, it is still fully feasible to do so - clearly exemplified by the i486, AMD K5, Cyrix 6x86, Motorola 68040, etc.
Non-RISC instructions inherently perform more work per instruction (on average), and are also normally highly encoded, so they enable smaller overall size of the same program, and thus better use of limited cache memories.
Many RISC and VLIW processors are designed to execute every instruction (as long as it is in the cache) in a single cycle. This is very similar to the way CPUs with microcode execute one microinstruction per cycle. VLIW processors have instructions that behave similarly to very wide horizontal microcode, although typically without such fine-grained control over the hardware as provided by microcode. RISC instructions are sometimes similar to the narrow vertical microcode.
Microcode has been popular in application-specific processors such as network processors, digital signal processors, channel controllers, disk controllers, network interface controllers, flash memory controllers, graphics processing units, and in other hardware.

Micro-operations[edit]
Modern CISC implementations, such as the x86 family starting with the NexGen Nx586, Intel Pentium Pro, and AMD K5, decode instructions into dynamically buffered micro-operations with an instruction encoding similar to RISC or traditional microcode. A hardwired instruction decode unit directly emits microoperations for common x86 instructions, but falls back to a more traditional microcode ROM containing microoperations for more complex or rarely used instructions.[2]
For example, an x86 might look up microoperations from microcode to handle complex multistep operations such as loop or string instructions, floating-point unit transcendental functions or unusual values such as denormal numbers, and special-purpose instructions such as CPUID.

See also[edit]

Electronics portal

Address generation unit (AGU)
CPU design
Finite-state machine (FSM)
Firmware
Floating-point unit (FPU)
Pentium FDIV bug
Instruction pipeline
Microsequencer
MikroSim
Millicode
Superscalar

Notes[edit]


^ IBM horizontally microcoded processors had multiple micro-orders and register select fields that required decoding.


References[edit]


^ a b c Kent, Allen; Williams, James G. (April 5, 1993). Encyclopedia of Computer Science and Technology: Volume 28 - Supplement 13. New York: Marcel Dekker, Inc. ISBN 0-8247-2281-7. Archived from the original on November 20, 2016. Retrieved Jan 17, 2016.

^ a b Fog, Agner (2017-05-02). The microarchitecture of Intel, AMD and VIA CPUs (PDF) (Report). Technical University of Denmark. Archived (PDF) from the original on 2017-03-28. Retrieved 2024-08-21.

^ "IBM pSeries Servers - Microcode Update for Ultrastar 73LZX (US73) 18/36 GB". IBM. Archived from the original on April 19, 2019. Retrieved January 22, 2015.

^ a b Both, David (23 July 2020). "The central processing unit (CPU): Its components and functionality". Red Hat.

^ Pickens, John. "NMOS 6502 Opcodes". 6502.org.

^ a b Shirriff, Ken. "How the 8086 processor's microcode engine works". Ken Shirriff's blog.

^ "ISO/IEC/IEEE 24765:2017(en) Systems and software engineering — Vocabulary". www.iso.org. Retrieved 2024-06-23.

^ VAX 9000 System Technical Description (PDF). Digital Equipment Corporation. May 1990. pp. 3-5 – 3-32. EK-KA90S-TD-001.

^ VAX 8800 System Technical Description Volume 2 (PDF). Digital Equipment Corporation. July 1986. EK-KA882-TD-PRE.

^ Manning, B.M.; Mitby, J.S; Nicholson, J.O. (November 1979). "Microprogrammed Processor Having PLA Control Store". IBM Technical Disclosure Bulletin. 22 (6). Archived from the original on 2012-10-01. Retrieved 2011-07-10.

^ Often denoted a ROM/PLA control store in the context of usage in a CPU; Supnik, Bob (24 February 2008). "J-11: DEC's fourth and last PDP-11 microprocessor design ... features ... ROM/PLA control store". Archived from the original on 2011-07-09. Retrieved 2011-07-10.

^ "6502 Images". Archived from the original on March 4, 2016. Retrieved January 22, 2015.

^ IBM System/360 Model 50 Functional Characteristics (PDF). IBM. 1967. p. 7. A22-6898-1. Retrieved October 29, 2021.

^ Everett, R.R.; Swain, F.E. (1947). Whirlwind I Computer Block Diagrams (PDF) (Technical report). MIT Servomechanisms Laboratory. R-127. Archived from the original (PDF) on June 17, 2012. Retrieved June 21, 2006.

^ Wilkes, Maurice (1951). The Best Way to Design an Automatic Calculating Machine (Technical report). University of Manchester.Wilkes, Maurice (1989). "The Best Way to Design an Automatic Calculating Machine" (PDF). In Campbell-Kelly, M. (ed.). The early British computer conferences. MIT Press. pp. 182–4. ISBN 978-0-262-23136-7.

^ a b Shirriff, Ken. "Simulating the IBM 360/50 mainframe from its microcode". Ken Shirriff's blog.

^ Supnik, Bob (May 1988). VLSI VAX Micro-Architecture (PDF). Digital Equipment.

^ Starnes, Thomas (April 1983). "Design Philosophy Behind Motorola's MC68000". Byte.

^ a b c Cocke, John; Markstein, Victoria (January 1990). "The evolution of RISC technology at IBM" (PDF). IBM Journal of Research and Development. 34 (1): 4–11. doi:10.1147/rd.341.0004.

^ a b Clark, Douglas; Strecker, William (September 1980). "Comments on "The Case for the Reduced Instruction Computer"". ACM. 8 (6): 34–38. doi:10.1145/641914.641918. S2CID 14939489.

^ "The execution pipeline of the Intel i486 CPU". Digest of Papers Compcon Spring '90. Thirty-Fifth IEEE Computer Society International Conference on Intellectual Leverage. San Francisco, CA: IEEE. doi:10.1109/CMPCON.1990.63682. ISBN 0-8186-2028-5.

^ "Pentium Pro Processor At 150, 166, 180, and 200 MHz" (PDF) (Datasheet). Intel. November 1995.

^ a b "Part I / Common Architecture, Chapter 6 Common PALcode Architecture". Alpha AXP Architecture Reference Manual (PDF) (Second ed.). Digital Press. 1995. ISBN 1-55558-145-5.

^ Rogers, Bob (Sep–Oct 2012). "The What and Why of zEnterprise Millicode". IBM Systems Magazine. Archived from the original on October 9, 2012.

^ "EMIDEC 1100 computer". Emidec.org.uk. Archived from the original on June 12, 2010. Retrieved April 26, 2010.

^ IBM System/360 Model 25 Functional Characteristics (PDF). IBM. January 1968. p. 22. A24-3510-0. Retrieved October 29, 2021.

^ a b c Field Engineering Theory of Operation, 2030 Processing Unit, System/360 Model 30 (PDF) (First ed.). IBM. June 1967. Y24-3360-1. Archived (PDF) from the original on 2020-04-01. Retrieved 2019-11-09.

^ Edward A. Snow; Daniel P. Siewiorek (1982). "Implementation and Performance Evaluation of the PDP-11 Family". In Daniel P. Siewiorek; C. Gordon Bell; Allen Newell (eds.). Computer Structures: Principles and Examples. New York, NY: McGraw-Hill Book Company. p. 671. ISBN 0-07-057302-6.

^ Soltis, Frank (September 1981). "Design of a Small Business Data Processing System". IEEE Computer. 14: 77–93. doi:10.1109/C-M.1981.220610. S2CID 398484.

^ Frank G. Soltis (1997). Inside the AS/400, Second Edition. Duke Press. ISBN 978-1882419661.

^ "Interview: Battling the N64 (Naboo)". IGN64. November 10, 2000. Archived from the original on September 13, 2007. Retrieved March 27, 2008.

^ "Indiana Jones and the Infernal Machine". IGN. December 12, 2000. Archived from the original on September 27, 2013. Retrieved September 24, 2013.

^ Meynink, Todd (July 28, 2000). "Postmortem: Angel Studios' Resident Evil 2 (N64 Version)". Gamasutra. United Business Media LLC. Archived from the original on October 21, 2012. Retrieved October 18, 2010.

^ Digital Scientific Meta 4 Series 16 Computer System Reference Manual (PDF). Digital Scientific Corporation. May 1971. 7032MO. Archived (PDF) from the original on 2020-01-14. Retrieved 2020-01-14.

^ Digital Scientific Meta 4 Computer System Read-Only Memory (ROM) Reference Manual (PDF). Digital Scientific Corporation. March 1970. 7024MO. Archived (PDF) from the original on 2019-09-23. Retrieved 2020-01-14.

^ The Digital Scientific Meta 4 Series 16 Computer System Preliminary System Manual (PDF). Digital Scientific Corporation. June 1970. 7006MO. Archived (PDF) from the original on 2019-09-23. Retrieved 2020-01-14.

^ Digital Scientific Meta 4 Computer System Typical ROM Pattern Listing and Program To Simulate The IBM 1130 Instruction Set (PDF). Digital Scientific Corporation. January 1970. M4/005P-170. Archived (PDF) from the original on 2020-03-24. Retrieved 2020-01-14.

^ "Western Digital 1600". AntiqueTech. Archived from the original on 3 January 2017. Retrieved 5 January 2017.

^ Hayes, John P. (1978). Computer Architecture and Organization. McGraw-Hill. p. 300. ISBN 0-07-027363-4.

^ Neal Harman; Andy Gimblett (2009-10-12). "CS-323: High Performance Microprocessors – Chapter 1. Microprogramming". mat.uson.mx. Archived from the original on 2015-04-19. Retrieved 2015-08-08.

^ Vaupel, Robert (2013). High Availability and Scalability of Mainframe Environments using System z and z/OS as example. KIT Scientific. p. 26. ISBN 978-3-7315-0022-3.

^ Rogers, Bob (September–October 2012). "The What and Why of zEnterprise Millicode". IBM Systems Magazine. Archived from the original on 2013-10-16. Retrieved 2013-11-07.

^ "PALcode for Alpha Microprocessors System Design Guide" (PDF). Digital Equipment Corporation. May 1996. Archived (PDF) from the original on August 15, 2011. Retrieved November 7, 2013.

^ Spruth, Wilhelm (December 2012). The Design of a Microprocessor. Springer Science & Business Media. p. 31. ISBN 978-3-642-74916-2. Archived from the original on November 20, 2016. Retrieved Jan 18, 2015.

^ Koopman, Philip Jr. (1987). "Writable instruction set, stack oriented computers: The WISC Concept" (PDF). The Journal of Forth Application and Research: 49–71. Archived (PDF) from the original on 2008-05-11.

^ Smith, Eric (3 September 2002). "Re: What was the size of Microcode in various machines". Newsgroup: alt.folklore.computers. Usenet: qhn0qyveyu.fsf@ruckus.brouhaha.com. Archived from the original on 26 January 2009. Retrieved 18 December 2008.

^ Smotherman, Mark. "CPSC 3300 / The Soul of a New Machine". Retrieved 2023-10-27. 4096 x 75-bit SRAM writable control store: 74-bit microinstruction with 1 parity bit (18 fields)

^ IBM System/370 Principles of Operation (PDF). Fourth Edition. IBM. September 1974. pp. 98, 245. GA22-7000-4. Archived (PDF) from the original on 2012-02-29. Retrieved 2012-08-27.

^ IBM System/360 Model 85 Functional Characteristics (PDF). SECOND EDITION. IBM. June 1968. A22-6916-1. Retrieved October 29, 2021.

^ IBM System/360 Special Feature Description 709/7090/7094 Compatibility Feature for IBM System/360 Model 85. First Edition. IBM. March 1969. GA27-2733-0.

^ Stiller, Andreas; Paul, Matthias R. (1996-05-12). "Prozessorgeflüster". c't – magazin für computertechnik. Trends & News (in German). Heise Verlag. Archived from the original on 2017-08-28. Retrieved 2017-08-28.

^ "9.11: Microcode update facilities". Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3A: System Programming Guide, Part 1 (PDF). Intel. September 2016.

^ Intel Patches All Recent CPUs, Promises Hardware Fixes For Upcoming 8th Gen Chips by Paul Alcorn on March 15, 2018

^ "Download Linux* Processor Microcode Data File". Archived from the original on 2018-03-19. Retrieved 2018-03-21.

^ "Intel Microcode Update Utility for Linux". Archived from the original on 2012-02-26.

^ "[ports] Index of /head/sysutils/cpupdate". Freebsd.org. Archived from the original on 2020-04-01. Retrieved 2020-01-16.

^ "A microcode reliability update is available that improves the reliability of systems that use Intel processors". Archived from the original on 2008-02-23. Retrieved 2008-02-25.

^ "Server Products - BIOS Update required when Missing Microcode message is seen during POST". Intel. January 24, 2013. Archived from the original on September 1, 2014.

^ "Model 990/12 LR Computer Depot Maintenance and Repair Manual" (PDF). Bitsavers.org. Texas Instruments. Retrieved 15 February 2024.

^ Texas Instruments Model 990 Computer MDS-990 Microcode Development System Programmer's Guide (15 August 1979 ed.). Texas Instruments Archives, RG-20 accession 94-08, Box 10, 45C. DeGolyer Library, Southern Methodist University, Dallas, TX USA.{{cite book}}:  CS1 maint: location (link)


Further reading[edit]
Smith, Richard E. (1988). "A Historical Overview of Computer Architecture". Annals of the History of Computing. 10 (4): 277–303. doi:10.1109/MAHC.1988.10039. S2CID 16405547. Retrieved June 21, 2006.
Smotherman, Mark (October 2022). "A Brief History of Microprogramming". Retrieved October 27, 2023.
Wilkes, M. V. (1986). "The Genesis of Microprogramming". Annals of the History of Computing. 8 (2): 116–126. doi:10.1109/MAHC.1986.10035. S2CID 1978847. Retrieved August 7, 2006.
Wilkes, M. V.; Stringer, J. B. (April 1953). "Microprogramming and the Design of the Control Circuits in an Electronic Digital Computer". Mathematical Proceedings of the Cambridge Philosophical Society. 49 (2): 230–238. Bibcode:1953PCPS...49..230W. doi:10.1017/S0305004100028322. S2CID 62230627. Retrieved August 23, 2006.
Husson, S.S. (1970). Microprogramming Principles and Practices. Prentice-Hall. ISBN 0-13-581454-5.
Tucker, S.G. (1967). "Microprogram control for SYSTEM/360". IBM Systems Journal. 6 (4): 222–241. doi:10.1147/sj.64.0222.
Shirriff, Ken (December 2022). "How the 8086 processor's microcode engine works".
External links[edit]



Look up microcode in Wiktionary, the free dictionary.

This article's use of external links may not follow Wikipedia's policies or guidelines. Please improve this article by removing excessive or inappropriate external links, and converting useful links where appropriate into footnote references. (February 2017) (Learn how and when to remove this message)
Writable Instruction Set Computer
Capacitor Read-only Store
Transformer Read-only Store
A Brief History of Microprogramming
Intel processor microcode security update (fixes the issues when running 32-bit virtual machines in PAE mode)
Notes on Intel Microcode Updates, March 2013, by Ben Hawkes, archived from the original on September 7, 2015
Hole seen in Intel's bug-busting feature, EE Times, 2002, by Alexander Wolfe, archived from the original on March 9, 2003
Opteron Exposed: Reverse Engineering AMD K8 Microcode Updates, July 26, 2004
WepSIM: An Online Interactive Educational Simulator Integrating Microdesign, Microprogramming, and Assembly Language Programming, July 26, 2022
vteProcessor technologiesModels
Abstract machine
Stored-program computer
Finite-state machine
with datapath
Hierarchical
Deterministic finite automaton
Queue automaton
Cellular automaton
Quantum cellular automaton
Turing machine
Alternating Turing machine
Universal
Post–Turing
Quantum
Nondeterministic Turing machine
Probabilistic Turing machine
Hypercomputation
Zeno machine
Belt machine
Stack machine
Register machines
Counter
Pointer
Random-access
Random-access stored program
Architecture
Microarchitecture
Von Neumann
Harvard
modified
Dataflow
Transport-triggered
Cellular
Endianness
Memory access
NUMA
HUMA
Load–store
Register/memory
Cache hierarchy
Memory hierarchy
Virtual memory
Secondary storage
Heterogeneous
Fabric
Multiprocessing
Cognitive
Neuromorphic
Instruction setarchitecturesTypes
Orthogonal instruction set
CISC
RISC
Application-specific
EDGE
TRIPS
VLIW
EPIC
MISC
OISC
NISC
ZISC
VISC architecture
Quantum computing
Comparison
Addressing modes
Instructionsets
Motorola 68000 series
VAX
PDP-11
x86
ARM
Stanford MIPS
MIPS
MIPS-X
Power
POWER
PowerPC
Power ISA
Clipper architecture
SPARC
SuperH
DEC Alpha
ETRAX CRIS
M32R
Unicore
Itanium
OpenRISC
RISC-V
MicroBlaze
LMC
System/3x0
S/360
S/370
S/390
z/Architecture
Tilera ISA
VISC architecture
Epiphany architecture
Others
ExecutionInstruction pipelining
Pipeline stall
Operand forwarding
Classic RISC pipeline
Hazards
Data dependency
Structural
Control
False sharing
Out-of-order
Scoreboarding
Tomasulo's algorithm
Reservation station
Re-order buffer
Register renaming
Wide-issue
Speculative
Branch prediction
Memory dependence prediction
ParallelismLevel
Bit
Bit-serial
Word
Instruction
Pipelining
Scalar
Superscalar
Task
Thread
Process
Data
Vector
Memory
Distributed
Multithreading
Temporal
Simultaneous
Hyperthreading
Simultaneous and heterogenous
Speculative
Preemptive
Cooperative
Flynn's taxonomy
SISD
SIMD
Array processing (SIMT)
Pipelined processing
Associative processing
SWAR
MISD
MIMD
SPMD
Processorperformance
Transistor count
Instructions per cycle (IPC)
Cycles per instruction (CPI)
Instructions per second (IPS)
Floating-point operations per second (FLOPS)
Transactions per second (TPS)
Synaptic updates per second (SUPS)
Performance per watt (PPW)
Cache performance metrics
Computer performance by orders of magnitude
Types
Central processing unit (CPU)
Graphics processing unit (GPU)
GPGPU
Vector
Barrel
Stream
Tile processor
Coprocessor
PAL
ASIC
FPGA
FPOA
CPLD
Multi-chip module (MCM)
System in a package (SiP)
Package on a package (PoP)
By application
Embedded system
Microprocessor
Microcontroller
Mobile
Ultra-low-voltage
ASIP
Soft microprocessor
Systemson chip
System on a chip (SoC)
Multiprocessor (MPSoC)
Cypress PSoC
Network on a chip (NoC)
Hardwareaccelerators
Coprocessor
AI accelerator
Graphics processing unit (GPU)
Image processor
Vision processing unit (VPU)
Physics processing unit (PPU)
Digital signal processor (DSP)
Tensor Processing Unit (TPU)
Secure cryptoprocessor
Network processor
Baseband processor

Word size
1-bit
4-bit
8-bit
12-bit
15-bit
16-bit
24-bit
32-bit
48-bit
64-bit
128-bit
256-bit
512-bit
bit slicing
others
variable
Core count
Single-core
Multi-core
Manycore
Heterogeneous architecture
Components
Core
Cache
CPU cache
Scratchpad memory
Data cache
Instruction cache
replacement policies
coherence
Bus
Clock rate
Clock signal
FIFO
Functionalunits
Arithmetic logic unit (ALU)
Address generation unit (AGU)
Floating-point unit (FPU)
Memory management unit (MMU)
Load–store unit
Translation lookaside buffer (TLB)
Branch predictor
Branch target predictor
Integrated memory controller (IMC)
Memory management unit
Instruction decoder
Logic
Combinational
Sequential
Glue
Logic gate
Quantum
Array
Registers
Processor register
Status register
Stack register
Register file
Memory buffer
Memory address register
Program counter
Control unit
Hardwired control unit
Instruction unit
Data buffer
Write buffer
Microcode ROM
Counter
Datapath
Multiplexer
Demultiplexer
Adder
Multiplier
CPU
Binary decoder
Address decoder
Sum-addressed decoder
Barrel shifter
Circuitry
Integrated circuit
3D
Mixed-signal
Power management
Boolean
Digital
Analog
Quantum
Switch

Powermanagement
PMU
APM
ACPI
Dynamic frequency scaling
Dynamic voltage scaling
Clock gating
Performance per watt (PPW)
Related
History of general-purpose CPUs
Microprocessor chronology
Processor design
Digital electronics
Hardware security module
Semiconductor device fabrication
Tick–tock model
Pin grid array
Chip carrier





Retrieved from "https://en.wikipedia.org/w/index.php?title=Microcode&oldid=1281358910"
Categories: Instruction processingFirmwareCentral processing unitBIOSHidden categories: CS1 German-language sources (de)CS1 maint: locationArticles with short descriptionShort description matches WikidataWikipedia articles needing page number citations from July 2022All articles with unsourced statementsArticles with unsourced statements from March 2014Articles with unsourced statements from September 2011Articles with unsourced statements from December 2024Webarchive template wayback linksArticles with unsourced statements from February 2018Articles needing additional references from August 2023All articles needing additional referencesWikipedia articles in need of updating from December 2023All Wikipedia articles in need of updatingWikipedia external links cleanup from February 2017






 This page was last edited on 19 March 2025, at 22:16 (UTC).
Text is available under the Creative Commons Attribution-ShareAlike 4.0 License;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.


Privacy policy
About Wikipedia
Disclaimers
Contact Wikipedia
Code of Conduct
Developers
Statistics
Cookie statement
Mobile view














Search













Search









Toggle the table of contents







Microcode




























31 languages


Add topic
















