https://en.wikipedia.org/wiki/Fortran




Fortran - Wikipedia



































Jump to content







Main menu





Main menu
move to sidebar
hide



		Navigation
	


Main pageContentsCurrent eventsRandom articleAbout WikipediaContact us





		Contribute
	


HelpLearn to editCommunity portalRecent changesUpload fileSpecial pages



















Search











Search






















Appearance
















Donate

Create account

Log in








Personal tools





Donate Create account Log in





		Pages for logged out editors learn more



ContributionsTalk




























Contents
move to sidebar
hide




(Top)





1
Naming








2
Origins




Toggle Origins subsection





2.1
FORTRAN






2.1.1
Fixed layout and punched cards












3
Evolution




Toggle Evolution subsection





3.1
FORTRAN II






3.1.1
Simple FORTRAN II program










3.2
FORTRAN III








3.3
FORTRAN IV








3.4
FORTRAN 66








3.5
FORTRAN 77








3.6
Transition to ANSI Standard Fortran








3.7
Fortran 90






3.7.1
Obsolescence and deletions








3.7.2
"Hello, World!" example










3.8
Fortran 95






3.8.1
Conditional compilation and varying length strings












4
Modern Fortran




Toggle Modern Fortran subsection





4.1
Fortran 2003








4.2
Fortran 2008








4.3
Fortran 2018








4.4
Fortran 2023










5
Language features








6
Science and engineering








7
Portability








8
Obsolete variants




Toggle Obsolete variants subsection





8.1
Fortran-based languages










9
Code examples








10
Humor








11
See also








12
References








13
Further reading








14
External links


















Toggle the table of contents







Fortran



78 languages




العربيةAsturianuAzərbaycancaবাংলা閩南語 / Bân-lâm-gúБашҡортсаБеларускаяБългарскиBosanskiCatalàЧӑвашлаČeštinaDanskDeutschEestiΕλληνικάEspañolEsperantoEuskaraفارسیFrançaisGaeilge한국어Հայերենहिन्दीHrvatskiIdoBahasa IndonesiaInterlinguaÍslenskaItalianoעבריתҚазақшаKurdîLatinaLatviešuLietuviųMagyarമലയാളംमराठीBahasa MelayuMirandésМонголမြန်မာဘာသာNederlands日本語Norsk bokmålNorsk nynorskOccitanOʻzbekcha / ўзбекчаPiemontèisPolskiPortuguêsRomânăРусскийСаха тылаScotsShqipSimple EnglishSlovenčinaSlovenščinaکوردیСрпски / srpskiSrpskohrvatski / српскохрватскиSuomiSvenskaதமிழ்TaqbaylitతెలుగుไทยТоҷикӣTürkçeУкраїнськаVènetoTiếng Việt吴语粵語中文

Edit links











ArticleTalk





English

















ReadEditView history







Tools





Tools
move to sidebar
hide



		Actions
	


ReadEditView history





		General
	


What links hereRelated changesUpload filePermanent linkPage informationCite this pageGet shortened URLDownload QR code





		Print/export
	


Download as PDFPrintable version





		In other projects
	


Wikimedia CommonsWikibooksWikiquoteWikidata item





















Appearance
move to sidebar
hide










From Wikipedia, the free encyclopedia


General-purpose programming language


FortranParadigmMulti-paradigm: structured, imperative (procedural, object-oriented), generic, arrayDesigned byJohn BackusDeveloperJohn Backus and IBMFirst appeared1957; 68 years ago (1957)Stable releaseFortran 2023 (ISO/IEC 1539:2023)
   / November 17, 2023; 17 months ago (2023-11-17)
Typing disciplinestrong, static, manifestFilename extensions.f90, .f, .forWebsitefortran-lang.orgMajor implementationsAbsoft, Cray, GFortran, G95, IBM XL Fortran, Intel, Hitachi, Lahey/Fujitsu, Numerical Algorithms Group, Open Watcom, PathScale, PGI, Silverfrost, Oracle Solaris Studio, othersInfluenced bySpeedcodingInfluencedALGOL 58, BASIC, C, Chapel,[1] CMS-2, DOPE, Fortress, MATLAB, PL/I, PACT I, MUMPS, IDL, Ratfor, SAKO[2]
Fortran (/ˈfɔːrtræn/; formerly FORTRAN) is a third-generation, compiled, imperative programming language that is especially suited to numeric computation and scientific computing.
Fortran was originally developed by IBM with a reference manual being released in 1956;[3] however, the first compilers only began to produce accurate code two years later.[4] Fortran computer programs have been written to support scientific and engineering applications, such as numerical weather prediction, finite element analysis, computational fluid dynamics, plasma physics, geophysics, computational physics, crystallography and computational chemistry. It is a popular language for high-performance computing[5] and is used for programs that benchmark and rank the world's fastest supercomputers.[6][7]

The IBM Blue Gene/P supercomputer installation in 2007 at the Argonne Leadership Computing Facility located in the Argonne National Laboratory, in Lemont, Illinois, US
Fortran has evolved through numerous versions and dialects. In 1966, the American National Standards Institute (ANSI) developed a standard for Fortran to limit proliferation of compilers using slightly different syntax.[8] Successive versions have added support for a character data type (Fortran 77), structured programming, array programming, modular programming, generic programming (Fortran 90), parallel computing (Fortran 95), object-oriented programming (Fortran 2003), and concurrent programming (Fortran 2008).

FORTRAN and COBOL genealogy tree
Since April 2024, Fortran has ranked among the top ten languages in the TIOBE index, a measure of the popularity of programming languages.[9]


Naming[edit]
The first manual for FORTRAN describes it as a Formula Translating System, and printed the name with small caps, Fortran.[10]: p.2 [11]  Other sources suggest the name stands for Formula Translator,[12] or Formula Translation.[13]
Early IBM computers did not support lowercase letters, and the names of versions of the language through FORTRAN 77 were usually spelled in all-uppercase.[14] FORTRAN 77 was the last version in which the Fortran character set included only uppercase letters.[15]
The official language standards for Fortran have referred to the language as "Fortran" with initial caps since Fortran 90.[citation needed]

Origins[edit]
John Backus (1924–2007) proposed the FORTRAN project in December 1953 and received the A.M. Turing Award in 1977.
In late 1953, John W. Backus submitted a proposal to his superiors at IBM to develop a more practical alternative to assembly language for programming their IBM 704 mainframe computer.[11]: 69  Backus' historic FORTRAN team consisted of programmers Richard Goldberg, Sheldon F. Best, Harlan Herrick, Peter Sheridan, Roy Nutt, Robert Nelson, Irving Ziller, Harold Stern, Lois Haibt, and David Sayre.[16] Its concepts included easier entry of equations into a computer, an idea developed by J. Halcombe Laning and demonstrated in the Laning and Zierler system of 1952.[17]

The Fortran Automatic Coding System for the IBM 704 (October 15, 1956), the first programmer's reference manual for Fortran[10]
A draft specification for The IBM Mathematical Formula Translating System was completed by November 1954.[11]: 71  The first manual for FORTRAN appeared in October 1956,[10][11]: 72  with the first FORTRAN compiler delivered in April 1957.[11]: 75  Fortran produced efficient enough code for assembly language programmers to accept a high-level programming language replacement.[18]
John Backus said during a 1979 interview with Think, the IBM employee magazine, "Much of my work has come from being lazy. I didn't like writing programs, and so, when I was working on the IBM 701, writing programs for computing missile trajectories, I started work on a programming system to make it easier to write programs."[19]
The language was widely adopted by scientists for writing numerically intensive programs, which encouraged compiler writers to produce compilers that could generate faster and more efficient code.  The inclusion of a complex number data type in the language made Fortran especially suited to technical applications such as electrical engineering.[20]
By 1960, versions of FORTRAN were available for the IBM 709, 650, 1620, and 7090 computers.  Significantly, the increasing popularity of FORTRAN spurred competing computer manufacturers to provide FORTRAN compilers for their machines, so that by 1963 over 40 FORTRAN compilers existed.
FORTRAN was provided for the IBM 1401 computer by an innovative 63-phase compiler that ran entirely in its core memory of only 8000 (six-bit) characters.  The compiler could be run from tape, or from a 2200-card deck; it used no further tape or disk storage.  It kept the program in memory and loaded overlays that gradually transformed it, in place, into executable form, as described by Haines.[21]
This article was reprinted, edited, in both editions of Anatomy of a Compiler[22] and in the IBM manual "Fortran Specifications and Operating Procedures, IBM 1401".[23]  The executable form was not entirely machine language; rather, floating-point arithmetic, sub-scripting, input/output, and function references were interpreted, preceding UCSD Pascal P-code by two decades. GOTRAN, a simplified, interpreted version of FORTRAN I (with only 12 types of statements not 32) for "load and go" operation was available (at least for the early IBM 1620 computer).[24] Modern Fortran, and almost all later versions, are fully compiled, as done for other high-performance languages.
The development of Fortran paralleled the early evolution of compiler technology, and many advances in the theory and design of compilers were specifically motivated by the need to generate efficient code for Fortran programs.

FORTRAN[edit]
The initial release of FORTRAN for the IBM 704[10] contained 32 types of statements, including:

DIMENSION and EQUIVALENCE statements
Assignment statements
Three-way arithmetic IF statement, which passed control to one of three locations in the program depending on whether the result of the arithmetic expression was negative, zero, or positive
Control statements for checking exceptions (IF ACCUMULATOR OVERFLOW, IF QUOTIENT OVERFLOW, and IF DIVIDE CHECK); and control statements for manipulating sense switches and sense lights (IF (SENSE SWITCH), IF (SENSE LIGHT), and SENSE LIGHT)
GO TO, computed GO TO, ASSIGN, and assigned GO TO
DO loops
Formatted I/O: FORMAT, READ, READ INPUT TAPE, WRITE OUTPUT TAPE, PRINT, and PUNCH
Unformatted I/O: READ TAPE, READ DRUM, WRITE TAPE, and WRITE DRUM
Other I/O: END FILE, REWIND, and BACKSPACE
PAUSE, STOP, and CONTINUE
FREQUENCY statement (for providing optimization hints to the compiler).
The arithmetic IF statement was reminiscent of (but not readily implementable by) a three-way comparison instruction (CAS—Compare Accumulator with Storage) available on the 704. The statement provided the only way to compare numbers—by testing their difference, with an attendant risk of overflow. This deficiency was later overcome by "logical" facilities introduced in FORTRAN IV.
The FREQUENCY statement was used originally (and optionally) to give branch probabilities for the three branch cases of the arithmetic IF statement. It could also be used to suggest how many iterations a DO loop might run. The first FORTRAN compiler used this weighting to perform at compile time a Monte Carlo simulation of the generated code, the results of which were used to optimize the placement of basic blocks in memory—a very sophisticated optimization for its time. The Monte Carlo technique is documented in Backus et al.'s paper on this original implementation, The FORTRAN Automatic Coding System:

The fundamental unit of program is the basic block; a basic block is a stretch of program which has one entry point and one exit point. The purpose of section 4 is to prepare for section 5 a table of predecessors (PRED table) which enumerates the basic blocks and lists for every basic block each of the basic blocks which can be its immediate predecessor in flow, together with the absolute frequency of each such basic block link. This table is obtained by running the program once in Monte-Carlo fashion, in which the outcome of conditional transfers arising out of IF-type statements and computed GO TO's is determined by a random number generator suitably weighted according to whatever FREQUENCY statements have been provided.[16]
The first FORTRAN compiler reported diagnostic information by halting the program when an error was found and outputting an error code on its console. That code could be looked up by the programmer in an error messages table in the operator's manual, providing them with a brief description of the problem.[10]: p.19–20 [25] Later, an error-handling subroutine to handle user errors such as division by zero, developed by NASA,[26] was incorporated, informing users of which line of code contained the error.

Fixed layout and punched cards[edit]
See also: Computer programming in the punched card era
FORTRAN code on a punched card, showing the specialized uses of columns 1–5, 6 and 73–80
A reproduction of a FORTRAN coding form, printed on paper and intended to be used by programmers to prepare programs for punching onto cards by keypunch operators. Now obsolete.
Before the development of disk files, text editors and terminals, programs were most often entered on a keypunch keyboard onto 80-column punched cards, one line to a card. The resulting deck of cards would be fed into a card reader to be compiled. Punched card codes included no lower-case letters or many special characters, and special versions of the IBM 026 keypunch were offered that would correctly print the re-purposed special characters used in FORTRAN.
Reflecting punched card input practice, Fortran programs were originally written in a fixed-column format, with the first 72 columns read into twelve 36-bit words.
A letter "C" in column 1 caused the entire card to be treated as a comment and ignored by the compiler. Otherwise, the columns of the card were divided into four fields:

1 to 5 were the label field: a sequence of digits here was taken as a label for use in DO or control statements such as GO TO and IF, or to identify a FORMAT statement referred to in a WRITE or READ statement. Leading zeros are ignored and 0 is not a valid label number.
6 was a continuation field: a character other than a blank or a zero here caused the card to be taken as a continuation of the statement on the prior card. The continuation cards were usually numbered 1, 2, etc. and the starting card might therefore have zero in its continuation column—which is not a continuation of its preceding card.
7 to 72 served as the statement field.
73 to 80 were ignored (the IBM 704's card reader only used 72 columns).[27]
Columns 73 to 80 could therefore be used for identification information, such as punching a sequence number or text, which could be used to re-order cards if a stack of cards was dropped; though in practice this was reserved for stable, production programs. An IBM 519 could be used to copy a program deck and add sequence numbers. Some early compilers, e.g., the IBM 650's, had additional restrictions due to limitations on their card readers.[28] Keypunches could be programmed to tab to column 7 and skip out after column 72. Later compilers relaxed most fixed-format restrictions, and the requirement was eliminated in the Fortran 90 standard.
Within the statement field, whitespace characters (blanks) were ignored outside a text literal. This allowed omitting spaces between tokens for brevity or including spaces within identifiers for clarity. For example, AVG OF X was a valid identifier, equivalent to AVGOFX, and 101010DO101I=1,101 was a valid statement, equivalent to 10101  DO 101 I = 1, 101 because the zero in column 6 is treated as if it were a space (!), while 101010DO101I=1.101 was instead 10101  DO101I = 1.101, the assignment of 1.101 to a variable called DO101I. Note the slight visual difference between a comma and a period.
Hollerith strings, originally allowed only in FORMAT and DATA statements, were prefixed by a character count and the letter H (e.g., 26HTHIS IS ALPHANUMERIC DATA.), allowing blanks to be retained within the character string. Miscounts were a problem.

Evolution[edit]

Timeline of Fortran language


Year

Informal name

Official Standard


1957

FORTRAN

—


1958

FORTRAN II

—


1958

FORTRAN III

—


1961

FORTRAN IV

—


1966

FORTRAN 66

ANSI X3.9-1966


1978

FORTRAN 77

ANSI X3.9-1978


1991

Fortran 90

ANSI X3.198-1992ISO/IEC 1539:1991


1997

Fortran 95

ISO/IEC 1539-1:1997


2004

Fortran 2003

ISO/IEC 1539-1:2004


2010

Fortran 2008

ISO/IEC 1539-1:2010


2018

Fortran 2018

ISO/IEC 1539-1:2018


2023

Fortran 2023

ISO/IEC 1539-1:2023

FORTRAN II[edit]
IBM's FORTRAN II appeared in 1958.  The main enhancement was to support procedural programming by allowing user-written subroutines and functions which returned values with parameters passed by reference.  The COMMON statement provided a way for subroutines to access common (or global) variables. Six new statements were introduced:[29]

SUBROUTINE, FUNCTION, and END
CALL and RETURN
COMMON
Over the next few years, FORTRAN II added support for the DOUBLE PRECISION and COMPLEX data types.
Early FORTRAN compilers supported no recursion in subroutines. Early computer architectures supported no concept of a stack, and when they did directly support subroutine calls, the return location was often stored in one fixed location adjacent to the subroutine code (e.g. the IBM 1130) or a specific machine register (IBM 360 et seq), which only allows recursion if a stack is maintained by software and the return address is stored on the stack before the call is made and restored after the call returns. Although not specified in FORTRAN 77, many F77 compilers supported recursion as an option, and the Burroughs mainframes, designed with recursion built-in, did so by default. It became a standard in Fortran 90 via the new keyword RECURSIVE.[30]

Simple FORTRAN II program[edit]
This program, for Heron's formula, reads data on a tape reel containing three 5-digit integers A, B, and C as input. There are no "type" declarations available: variables whose name starts with I, J, K, L, M, or N are "fixed-point" (i.e. integers), otherwise floating-point. Since integers are to be processed in this example, the names of the variables start with the letter "I". The name of a variable must start with a letter and can continue with both letters and digits, up to a limit of six characters in FORTRAN II.  If A, B, and C cannot represent the sides of a triangle in plane geometry, then the program's execution will end with an error code of "STOP 1".  Otherwise, an output line will be printed showing the input values for A, B, and C, followed by the computed AREA of the triangle as a floating-point number occupying ten spaces along the line of output and showing 2 digits after the decimal point, the .2 in F10.2 of the FORMAT statement with label 601.

C AREA OF A TRIANGLE WITH A STANDARD SQUARE ROOT FUNCTION
C INPUT - TAPE READER UNIT 5, INTEGER INPUT
C OUTPUT - LINE PRINTER UNIT 6, REAL OUTPUT
C INPUT ERROR DISPLAY ERROR OUTPUT CODE 1 IN JOB CONTROL LISTING
      READ INPUT TAPE 5, 501, IA, IB, IC
  501 FORMAT (3I5)
C IA, IB, AND IC MAY NOT BE NEGATIVE OR ZERO
C FURTHERMORE, THE SUM OF TWO SIDES OF A TRIANGLE
C MUST BE GREATER THAN THE THIRD SIDE, SO WE CHECK FOR THAT, TOO
      IF (IA) 777, 777, 701
  701 IF (IB) 777, 777, 702
  702 IF (IC) 777, 777, 703
  703 IF (IA+IB-IC) 777, 777, 704
  704 IF (IA+IC-IB) 777, 777, 705
  705 IF (IB+IC-IA) 777, 777, 799
  777 STOP 1
C USING HERON'S FORMULA WE CALCULATE THE
C AREA OF THE TRIANGLE
  799 S = FLOATF (IA + IB + IC) / 2.0
      AREA = SQRTF( S * (S - FLOATF(IA)) * (S - FLOATF(IB)) *
     +     (S - FLOATF(IC)))
      WRITE OUTPUT TAPE 6, 601, IA, IB, IC, AREA
  601 FORMAT (4H A= ,I5,5H  B= ,I5,5H  C= ,I5,8H  AREA= ,F10.2,
     +        13H SQUARE UNITS)
      STOP
      END

FORTRAN III[edit]
IBM also developed a FORTRAN III in 1958 that allowed for inline assembly code among other features; however, this version was never released as a product.  Like the 704 FORTRAN and FORTRAN II, FORTRAN III included machine-dependent features that made code written in it unportable from machine to machine, as well as Boolean expression support.[11]: 76   Early versions of FORTRAN provided by other vendors suffered from the same disadvantage.

FORTRAN IV[edit]
IBM began development of FORTRAN IV in 1961 as a result of customer demands. FORTRAN IV removed the machine-dependent features of FORTRAN II (such as READ INPUT TAPE), while adding new features such as a LOGICAL data type, logical Boolean expressions, and the logical IF statement as an alternative to the arithmetic IF statement.  Type declarations were added, along with an IMPLICIT statement to override earlier conventions that variables are INTEGER if their name begins with I, J, K, L, M, or N; and REAL otherwise.[31]: pp.70, 71 [32]: p.6-9 
FORTRAN IV was eventually released in 1962, first for the IBM 7030 ("Stretch") computer, followed by versions for the IBM 7090, IBM 7094, and later for the IBM 1401 in 1966.[33]
By 1965, FORTRAN IV was supposed to be compliant with the standard being developed by the American Standards Association X3.4.3 FORTRAN Working Group.[34]
Between 1966 and 1968, IBM offered several FORTRAN IV compilers for its System/360, each named by letters that indicated the minimum amount of memory the compiler needed to run.
[35]
The letters (F, G, H) matched the codes used with System/360 model numbers to indicate memory size, each letter increment being a factor of two larger:[36]: p. 5 

1966 : FORTRAN IV F for DOS/360 (64K bytes)
1966 : FORTRAN IV G for OS/360 (128K bytes)
1968 : FORTRAN IV H for OS/360 (256K bytes)
Digital Equipment Corporation maintained DECSYSTEM-10 Fortran IV (F40) for PDP-10 from 1967 to 1975.[32] Compilers were also available for the UNIVAC 1100 series and the Control Data 6000 series and 7000 series systems.[37]
At about this time FORTRAN IV had started to become an important educational tool and implementations such as the University of Waterloo's WATFOR and WATFIV were created to simplify the complex compile and link processes of earlier compilers.
In the FORTRAN IV programming environment of the era, except for that used on Control Data Corporation (CDC) systems, only one instruction was placed per line. The CDC version allowed for multiple instructions per line if separated by a $ (dollar) character. The FORTRAN sheet was divided into four fields, as described above.
Two compilers of the time, IBM "G" and UNIVAC, allowed comments to be written on the same line as instructions, separated by a special character: "master space": V (perforations 7 and 8) for UNIVAC and perforations 12/11/0/7/8/9 (hexadecimal FF) for IBM. These comments were not to be inserted in the middle of continuation cards.[32][37]

FORTRAN 66[edit]
Perhaps the most significant development in the early history of FORTRAN was the decision by the American Standards Association (now American National Standards Institute (ANSI)) to form a committee sponsored by the Business Equipment Manufacturers Association (BEMA) to develop an American Standard Fortran.  The resulting two standards, approved in March 1966, defined two languages, FORTRAN (based on FORTRAN IV, which had served as a de facto standard), and Basic FORTRAN (based on FORTRAN II, but stripped of its machine-dependent features).  The FORTRAN defined by the first standard, officially denoted X3.9-1966, became known as FORTRAN 66 (although many continued to term it FORTRAN IV, the language on which the standard was largely based).  FORTRAN 66 effectively became the first industry-standard version of FORTRAN. FORTRAN 66 included:

Main program, SUBROUTINE, FUNCTION, and BLOCK DATA program units
INTEGER, REAL, DOUBLE PRECISION, COMPLEX, and LOGICAL data types
COMMON, DIMENSION, and EQUIVALENCE statements
DATA statement for specifying initial values
Intrinsic and EXTERNAL (e.g., library) functions
Assignment statement
GO TO, computed GO TO, assigned GO TO, and ASSIGN statements
Logical IF and arithmetic (three-way) IF statements
DO loop statement
READ, WRITE, BACKSPACE, REWIND, and ENDFILE statements for sequential I/O
FORMAT statement and assigned format
CALL, RETURN, PAUSE, and STOP statements
Hollerith constants in DATA and FORMAT statements, and as arguments to procedures
Identifiers of up to six characters in length
Comment lines
END line
The above Fortran II version of the Heron program needs several modifications to compile as a Fortran 66 program.  Modifications include using the more machine independent versions of the READ and WRITE statements, and removal of the unneeded FLOATF type conversion functions.  Though not required, the arithmetic IF statements can be re-written to use logical IF statements and expressions in a more structured fashion.

C AREA OF A TRIANGLE WITH A STANDARD SQUARE ROOT FUNCTION
C INPUT - TAPE READER UNIT 5, INTEGER INPUT
C OUTPUT - LINE PRINTER UNIT 6, REAL OUTPUT
C INPUT ERROR DISPLAY ERROR OUTPUT CODE 1 IN JOB CONTROL LISTING
      READ (5, 501) IA, IB, IC
  501 FORMAT (3I5)
C
C IA, IB, AND IC MAY NOT BE NEGATIVE OR ZERO
C FURTHERMORE, THE SUM OF TWO SIDES OF A TRIANGLE
C MUST BE GREATER THAN THE THIRD SIDE, SO WE CHECK FOR THAT, TOO
      IF (IA .GT. 0 .AND. IB .GT. 0 .AND. IC .GT. 0) GOTO 10
        WRITE (6, 602)
  602   FORMAT (42H IA, IB, AND IC MUST BE GREATER THAN ZERO.)
        STOP 1
   10 CONTINUE
C
      IF (IA+IB-IC .GT. 0
     +    .AND. IA+IC-IB .GT. 0
     +    .AND. IB+IC-IA .GT. 0) GOTO 20
        WRITE (6, 603)
  603   FORMAT (50H SUM OF TWO SIDES MUST BE GREATER THAN THIRD SIDE.)
        STOP 1
   20 CONTINUE
C
C USING HERON'S FORMULA WE CALCULATE THE
C AREA OF THE TRIANGLE
      S = (IA + IB + IC) / 2.0
      AREA = SQRT ( S * (S - IA) * (S - IB) * (S - IC))
      WRITE (6, 601) IA, IB, IC, AREA
  601 FORMAT (4H A= ,I5,5H  B= ,I5,5H  C= ,I5,8H  AREA= ,F10.2,
     +        13H SQUARE UNITS)
      STOP
      END

FORTRAN 77[edit]
FORTRAN-77 program with compiler output, written on a CDC 175 at RWTH Aachen University, Germany, in 1987
4.3 BSD for the Digital Equipment Corporation (DEC) VAX, displaying the manual for FORTRAN 77 (f77) compiler
After the release of the FORTRAN 66 standard, compiler vendors introduced several extensions to Standard Fortran, prompting ANSI committee X3J3 in 1969 to begin work on revising the 1966 standard, under sponsorship of CBEMA, the Computer Business Equipment Manufacturers Association (formerly BEMA).  Final drafts of this revised standard circulated in 1977, leading to formal approval of the new FORTRAN standard in April 1978.  The new standard, called FORTRAN 77 and officially denoted X3.9-1978, added a number of significant features to address many of the shortcomings of FORTRAN 66:

Block IF and END IF statements, with optional ELSE IF and ELSE clauses, to provide improved language support for structured programming
DO loop extensions, including parameter expressions, negative increments, and zero trip counts
OPEN, CLOSE, and INQUIRE statements for improved I/O capability
Direct-access file I/O
CHARACTER data type, replacing Hollerith strings with vastly expanded facilities for character input and output and processing of character-based data
PARAMETER statement for specifying constants
SAVE statement for persistent local variables
Generic names for intrinsic functions (e.g. SQRT also accepts arguments of other types, such as COMPLEX or REAL*16).
A set of intrinsics (LGE, LGT, LLE, LLT) for lexical comparison of strings, based upon the ASCII collating sequence. (These ASCII functions were demanded by the U.S. Department of Defense, in their conditional approval vote.[citation needed])
A maximum of seven dimensions in arrays, rather than three.  Allowed subscript expressions were also generalized.
In this revision of the standard, a number of features were removed or altered in a manner that might invalidate formerly standard-conforming programs.
(Removal was the only allowable alternative to X3J3 at that time, since the concept of "deprecation" was not yet available for ANSI standards.)
While most of the 24 items in the conflict list (see Appendix A2 of X3.9-1978) addressed loopholes or pathological cases permitted by the prior standard but rarely used, a small number of specific capabilities were deliberately removed, such as:

Hollerith constants and Hollerith data, such as GREET = 12HHELLO THERE!
Reading into an H edit (Hollerith field) descriptor in a FORMAT specification
Overindexing of array bounds by subscripts       DIMENSION A(10,5)
      Y = A(11,1)

Transfer of control out of and back into the range of a DO loop (also known as "Extended Range")
A Fortran 77 version of the Heron program requires no modifications to the Fortran 66 version.  However this example demonstrates additional cleanup of the I/O statements, including using list-directed I/O, and replacing the Hollerith edit descriptors in the FORMAT statements with quoted strings.  It also uses structured IF and END IF statements, rather than GOTO/CONTINUE.

      PROGRAM HERON
C AREA OF A TRIANGLE WITH A STANDARD SQUARE ROOT FUNCTION
C INPUT - DEFAULT STANDARD INPUT UNIT, INTEGER INPUT
C OUTPUT - DEFAULT STANDARD OUTPUT UNIT, REAL OUTPUT
C INPUT ERROR DISPLAY ERROR OUTPUT CODE 1 IN JOB CONTROL LISTING
      READ (*, *) IA, IB, IC
C
C IA, IB, AND IC MAY NOT BE NEGATIVE OR ZERO
C FURTHERMORE, THE SUM OF TWO SIDES OF A TRIANGLE
C MUST BE GREATER THAN THE THIRD SIDE, SO WE CHECK FOR THAT, TOO
      IF (IA .LE. 0 .OR. IB .LE. 0 .OR. IC .LE. 0) THEN
        WRITE (*, *) 'IA, IB, and IC must be greater than zero.'
        STOP 1
      END IF
C
      IF (IA+IB-IC .LE. 0
     +    .OR. IA+IC-IB .LE. 0
     +    .OR. IB+IC-IA .LE. 0) THEN
        WRITE (*, *) 'Sum of two sides must be greater than third side.'
        STOP 1
      END IF
C
C USING HERON'S FORMULA WE CALCULATE THE
C AREA OF THE TRIANGLE
      S = (IA + IB + IC) / 2.0
      AREA = SQRT ( S * (S - IA) * (S - IB) * (S - IC))
      WRITE (*, 601) IA, IB, IC, AREA
  601 FORMAT ('A= ', I5, '  B= ', I5, '  C= ', I5, '  AREA= ', F10.2,
     +        ' square units')
      STOP
      END

Transition to ANSI Standard Fortran[edit]
The development of a revised standard to succeed FORTRAN 77 would be repeatedly delayed as the standardization process struggled to keep up with rapid changes in computing and programming practice.  In the meantime, as the "Standard FORTRAN" for nearly fifteen years, FORTRAN 77 would become the historically most important dialect.
An important practical extension to FORTRAN 77 was the release of MIL-STD-1753 in 1978.[38] This specification, developed by the U.S. Department of Defense, standardized a number of features implemented by most FORTRAN 77 compilers but not included in the ANSI FORTRAN 77 standard. These features would eventually be incorporated into the Fortran 90 standard.

DO WHILE and END DO statements
INCLUDE statement
IMPLICIT NONE variant of the IMPLICIT statement
Bit manipulation intrinsic functions, based on similar functions included in Industrial Real-Time Fortran (ANSI/ISA S61.1 (1976))
The IEEE 1003.9 POSIX Standard, released in 1991, provided a simple means for FORTRAN 77 programmers to issue POSIX system calls.[39] Over 100 calls were defined in the document –  allowing access to POSIX-compatible process control, signal handling, file system control, device control, procedure pointing, and stream I/O in a portable manner.

Fortran 90[edit]
The much-delayed successor to FORTRAN 77, informally known as Fortran 90 (and prior to that, Fortran 8X), was finally released as ISO/IEC standard 1539:1991 in 1991 and an ANSI Standard in 1992.  In addition to changing the official spelling from FORTRAN to Fortran, this major revision added many new features to reflect the significant changes in programming practice that had evolved since the 1978 standard:

Free-form source input removed the need to skip the first six character positions before entering statements.
Lowercase Fortran keywords
Identifiers up to 31 characters in length (In the previous standard, it was only six characters).
Inline comments
Ability to operate on arrays (or array sections) as a whole, thus greatly simplifying math and engineering computations.
whole, partial and masked array assignment statements and array expressions, such as X(1:N)=R(1:N)*COS(A(1:N))
WHERE statement for selective array assignment
array-valued constants and expressions,
user-defined array-valued functions and array constructors.
RECURSIVE procedures
Modules, to group related procedures and data together, and make them available to other program units, including the capability to limit the accessibility to only specific parts of the module.
A vastly improved argument-passing mechanism, allowing interfaces to be checked at compile time
User-written interfaces for generic procedures
Operator overloading
Derived (structured) data types
New data type declaration syntax, to specify the data type and other attributes of variables
Dynamic memory allocation by means of the ALLOCATABLE attribute and the ALLOCATE and DEALLOCATE statements
POINTER attribute, pointer assignment, and NULLIFY statement to facilitate the creation and manipulation of dynamic data structures
Structured looping constructs, with an END DO statement for loop termination, and EXIT and CYCLE statements for terminating normal DO loop iterations in an orderly way
SELECT CASE, CASE, . . . CASE DEFAULT, END SELECT construct for multi-way selection
Portable specification of numerical precision under the user's control
New and enhanced intrinsic procedures.
Obsolescence and deletions[edit]
Unlike the prior revision, Fortran 90 removed no features.[40] Any standard-conforming FORTRAN 77 program was also standard-conforming under Fortran 90, and either standard should have been usable to define its behavior.
A small set of features were identified as "obsolescent" and were expected to be removed in a future standard.  All of the functionalities of these early-version features can be performed by newer Fortran features.  Some are kept to simplify porting of old programs but many were deleted in Fortran 95.


Obsolescence and deletions


Obsolescent feature

Current status


Arithmetic IF-statement

Obsolescent in F90, deleted in F2018


Non-integer DO parameters or control variables

Obsolescent in F90, deleted in F95


Shared DO-loop termination or termination with a statement other than END DO or CONTINUE  

Obsolescent in F90, deleted in F2018


Branching to END IF from outside a block

Obsolescent in F90, deleted in F95


PAUSE statement

Obsolescent in F90, deleted in F95


ASSIGN statement and assigned GO TO statement

Obsolescent in F90, deleted in F95


Assigned statement numbers and FORMAT specifiers

Obsolescent in F90, deleted in F95


H edit descriptor

Obsolescent in F90, deleted in F95


Vertical format control

Deleted in F2003


Alternate return

Obsolescent in F90


Computed GO TO statement

Obsolescent in F90


Statement functions

Obsolescent in F90


DATA statements among executable statements

Obsolescent in F90


Assumed length character functions

Obsolescent in F90


Fixed form source code

Obsolescent in F90


CHARACTER* form of CHARACTER declaration

Obsolescent in F90


ENTRY statements

Obsolescent in F2008


Label form of DO statement

Obsolescent in F2018


COMMON and EQUIVALENCE statements, and the BLOCK DATA program unit

Obsolescent in F2018


Specific names for intrinsic function

Obsolescent in F2018


FORALL construct and statement

Obsolescent in F2018

"Hello, World!" example[edit]
program helloworld
     print *, "Hello, World!"
end program helloworld

Fortran 95[edit]
"F95" redirects here. For the Düsseldorf-based football club nicknamed "F95", see Fortuna Düsseldorf.
Main article: Fortran 95 language features
Fortran 95, published officially as ISO/IEC 1539-1:1997, was a minor revision, mostly to resolve some outstanding issues from the Fortran 90 standard.  Nevertheless, Fortran 95 also added a number of extensions, notably from the High Performance Fortran specification:

FORALL and nested WHERE constructs to aid vectorization
User-defined PURE and ELEMENTAL procedures
Default initialization of derived type components, including pointer initialization
Expanded the ability to use initialization expressions for data objects
Initialization of pointers to NULL()
Clearly defined that ALLOCATABLE arrays are automatically deallocated when they go out of scope.
A number of intrinsic functions were extended (for example a dim argument was added to the maxloc intrinsic).
Several features noted in Fortran 90 to be "obsolescent" were removed from Fortran 95:

DO statements using REAL and DOUBLE PRECISION index variables
Branching to an END IF statement from outside its block
PAUSE statement
ASSIGN and assigned GO TO statement, and assigned format specifiers
H Hollerith edit descriptor.
An important supplement to Fortran 95 was the ISO technical report TR-15581: Enhanced Data Type Facilities, informally known as the Allocatable TR.  This specification defined enhanced use of ALLOCATABLE arrays, prior to the availability of fully Fortran 2003-compliant Fortran compilers.  Such uses include ALLOCATABLE arrays as derived type components, in procedure dummy argument lists, and as function return values.  (ALLOCATABLE arrays are preferable to POINTER-based arrays because ALLOCATABLE arrays are guaranteed by Fortran 95 to be deallocated automatically when they go out of scope, eliminating the possibility of memory leakage.  In addition, elements of allocatable arrays are contiguous, and aliasing is not an issue for optimization of array references, allowing compilers to generate faster code than in the case of pointers.[41])
Another important supplement to Fortran 95 was the ISO technical report TR-15580: Floating-point exception handling, informally known as the IEEE TR.  This specification defined support for IEEE floating-point arithmetic and floating-point exception handling.

Conditional compilation and varying length strings[edit]
In addition to the mandatory "Base language" (defined in ISO/IEC 1539-1 : 1997), the Fortran 95 language also included two optional modules:

Varying length character strings (ISO/IEC 1539-2 : 2000)
Conditional compilation (ISO/IEC 1539-3 : 1998)
which, together, compose the multi-part International Standard (ISO/IEC 1539).
According to the standards developers, "the optional parts describe self-contained features which have been requested by a substantial body of users and/or implementors, but which are not deemed to be of sufficient generality for them to be required in all standard-conforming Fortran compilers." Nevertheless, if a standard-conforming Fortran does provide such options, then they "must be provided in accordance with the description of those facilities in the appropriate Part of the Standard".

Modern Fortran[edit]
The language defined by the twenty-first century standards, in particular because of its incorporation of object-oriented programming support and subsequently Coarray Fortran, is often referred to as 'Modern Fortran', and the term is increasingly used in the literature.[42]

Fortran 2003[edit]
Fortran 2003, officially published as ISO/IEC 1539-1:2004, was a major revision introducing many new features.[43] A comprehensive summary of the new features of Fortran 2003 is available at the Fortran Working Group (ISO/IEC JTC1/SC22/WG5) official Web site.[44]
From that article, the major enhancements for this revision include:

Derived type enhancements: parameterized derived types, improved control of accessibility, improved structure constructors, and finalizers
Object-oriented programming support: type extension and inheritance, polymorphism, dynamic type allocation, and type-bound procedures, providing complete support for abstract data types
Data manipulation enhancements: allocatable components (incorporating TR 15581), deferred type parameters, VOLATILE attribute, explicit type specification in array constructors and allocate statements, pointer enhancements, extended initialization expressions, and enhanced intrinsic procedures
Input/output enhancements: asynchronous transfer, stream access, user specified transfer operations for derived types, user specified control of rounding during format conversions, named constants for preconnected units, the FLUSH statement, regularization of keywords, and access to error messages
Procedure pointers
Support for IEEE floating-point arithmetic and floating-point exception handling (incorporating TR 15580)
Interoperability with the C programming language
Support for international usage: access to ISO 10646 4-byte characters and choice of decimal or comma in numeric formatted input/output
Enhanced integration with the host operating system: access to command-line arguments, environment variables, and processor error messages
An important supplement to Fortran 2003 was the ISO technical report TR-19767: Enhanced module facilities in Fortran.  This report provided sub-modules, which make Fortran modules more similar to Modula-2 modules.  They are similar to Ada private child sub-units.  This allows the specification and implementation of a module to be expressed in separate program units, which improves packaging of large libraries, allows preservation of trade secrets while publishing definitive interfaces, and prevents compilation cascades.

Fortran 2008[edit]
ISO/IEC 1539-1:2010, informally known as Fortran 2008, was approved in September 2010.[45][46] As with Fortran 95, this is a minor upgrade, incorporating clarifications and corrections to Fortran 2003, as well as introducing some new capabilities.  The new capabilities include:

Sub-modules – additional structuring facilities for modules; supersedes ISO/IEC TR 19767:2005
Coarray Fortran – a parallel execution model
The DO CONCURRENT construct – for loop iterations with no interdependencies
The CONTIGUOUS attribute – to specify storage layout restrictions
The BLOCK construct – can contain declarations of objects with construct scope
Recursive allocatable components – as an alternative to recursive pointers in derived types
The Final Draft international Standard (FDIS) is available as document N1830.[47]
A supplement to Fortran 2008 is the International Organization for Standardization (ISO) Technical Specification (TS) 29113 on Further Interoperability of Fortran with C,[48][49] which has been submitted to ISO in May 2012 for approval. The specification adds support for accessing the array descriptor from C and allows ignoring the type and rank of arguments.

Fortran 2018[edit]
The Fortran 2018 revision of the language was earlier referred to as Fortran 2015.[50] It was a significant revision and was released on November 28, 2018.[51]
Fortran 2018 incorporates two previously published Technical Specifications:

ISO/IEC TS 29113:2012 Further Interoperability with C[52]
ISO/IEC TS 18508:2015 Additional Parallel Features in Fortran[53]
Additional changes and new features include support for ISO/IEC/IEEE 60559:2011 (the version of the IEEE floating-point standard before the latest minor revision IEEE 754–2019), hexadecimal input/output, IMPLICIT NONE enhancements and other changes.[54][55][56][57]
Fortran 2018 deleted the arithmetic IF statement.  It also deleted non-block DO constructs - loops which do not end with an END DO or CONTINUE statement.  These had been an obsolescent part of the language since Fortran 90.
New obsolescences are: COMMON and EQUIVALENCE statements and the BLOCK DATA program unit, labelled DO loops, specific names for intrinsic functions, and the FORALL statement and construct.

Fortran 2023[edit]
Fortran 2023 (ISO/IEC 1539-1:2023) was published in November 2023, and can be purchased from the ISO.[58]
Fortran 2023 is a minor extension of Fortran 2018 that focuses on correcting errors and omissions
in Fortran 2018.  It also adds some small features, including an enumerated type capability.

Language features[edit]
Main article: Fortran 95 language features
A full description of the Fortran language features brought by Fortran 95 is covered in the related article, Fortran 95 language features. The language versions defined by later standards are often referred to collectively as 'Modern Fortran' and are described in the literature.

Science and engineering[edit]
General relativistic magnetohydrodynamic Fortran simulation of black hole accretion using the BHAC code with cartesian adaptive mesh
Flow around a cylinder computed in Fortran with OpenCL (University of Bristol, UK)
Velocity and sea surface temperature in the oceans, computed with the NEMO Fortran code (Nucleus for European Modeling of the Ocean, https://www.nemo-ocean.eu) in the Barcelona Supercomputing Center (2020)
Although a 1968 journal article by the authors of BASIC already described FORTRAN as "old-fashioned",[59] programs have been written in Fortran for many decades and there is a vast body of Fortran software in daily use throughout the scientific and engineering communities.[60] Jay Pasachoff wrote in 1984 that "physics and astronomy students simply have to learn FORTRAN.  So much exists in FORTRAN that it seems unlikely that scientists will change to Pascal, Modula-2, or whatever."[61] In 1993, Cecil E. Leith called FORTRAN the "mother tongue of scientific computing", adding that its replacement by any other possible language "may remain a forlorn hope".[62]
It is the primary language for some of the most intensive super-computing tasks, such as in astronomy, climate modeling, computational chemistry, computational economics, computational fluid dynamics, computational physics, data analysis,[63] hydrological modeling, numerical linear algebra and numerical libraries (LAPACK, IMSL and NAG), optimization, satellite simulation, structural engineering, and weather prediction.[64]  Many of the floating-point benchmarks to gauge the performance of new computer processors, such as the floating-point components of the SPEC benchmarks (e.g., CFP2006, CFP2017) are written in Fortran. Math algorithms are well documented in Numerical Recipes.
Apart from this, more modern codes in computational science generally use large program libraries, such as METIS for graph partitioning, PETSc or Trilinos for linear algebra capabilities, deal.II or FEniCS for mesh and finite element support, and other generic libraries.  Since the early 2000s, many of the widely used support libraries have also been implemented in C and more recently, in C++. On the other hand, high-level languages such as the Wolfram Language, MATLAB, Python, and R have become popular in particular areas of computational science. Consequently, a growing fraction of scientific programs are also written in such higher-level scripting languages. For this reason, facilities for inter-operation with C were added to Fortran 2003 and enhanced by the ISO/IEC technical specification 29113, which was incorporated into Fortran 2018 to allow more flexible interoperation with other programming languages.

Portability[edit]
Portability was a problem in the early days because there was no agreed upon standard—not even IBM's reference manual—and computer companies vied to differentiate their offerings from others by providing incompatible features.  Standards have improved portability.  The 1966 standard provided a reference syntax and semantics, but vendors continued to provide incompatible extensions.  Although careful programmers were coming to realize that use of incompatible extensions caused expensive portability problems, and were therefore using programs such as The PFORT Verifier,[65][66] it was not until after the 1977 standard, when the National Bureau of Standards (now NIST) published FIPS PUB 69, that processors purchased by the U.S. Government were required to diagnose extensions of the standard.  Rather than offer two processors, essentially every compiler eventually had at least an option to diagnose extensions.[67][68]
Incompatible extensions were not the only portability problem.  For numerical calculations, it is important to take account of the characteristics of the arithmetic.  This was addressed by Fox et al. in the context of the 1966 standard by the PORT library.[66] The ideas therein became widely used, and were eventually incorporated into the 1990 standard by way of intrinsic inquiry functions.  The widespread (now almost universal) adoption of the IEEE 754 standard for binary floating-point arithmetic has essentially removed this problem.
Access to the computing environment (e.g., the program's command line, environment variables, textual explanation of error conditions) remained a problem until it was addressed by the 2003 standard.
Large collections of library software that could be described as being loosely related to engineering and scientific calculations, such as graphics libraries, have been written in C, and therefore access to them presented a portability problem.  This has been addressed by incorporation of C interoperability into the 2003 standard.
It is now possible (and relatively easy) to write an entirely portable program in Fortran, even without recourse to a preprocessor.

Obsolete variants[edit]
Until the Fortran 66 standard was developed, each compiler supported its own variant of Fortran.  Some were more divergent from the mainstream than others.
The first Fortran compiler set a high standard of efficiency for compiled code.  This goal made it difficult to create a compiler so it was usually done by the computer manufacturers to support hardware sales. This left an important niche: compilers that were fast and provided good diagnostics for the programmer (often a student).  Examples include Watfor, Watfiv, PUFFT, and on a smaller scale, FORGO, Wits Fortran, and Kingston Fortran 2.
Fortran 5 was marketed by Data General Corp from the early 1970s to the early 1980s, for the Nova, Eclipse, and MV line of computers.  It had an optimizing compiler that was quite good for minicomputers of its time.  The language most closely resembles FORTRAN 66.
FORTRAN V was distributed by Control Data Corporation in 1968 for the CDC 6600 series. The language was based upon FORTRAN IV.[69]
Univac also offered a compiler for the 1100 series known as FORTRAN V.  A spinoff of Univac Fortran V was Athena FORTRAN.
Specific variants produced by the vendors of high-performance scientific computers (e.g., Burroughs, Control Data Corporation (CDC), Cray, Honeywell, IBM, Texas Instruments, and UNIVAC) added extensions to Fortran to take advantage of special hardware features such as instruction cache, CPU pipelines, and vector arrays.  For example, one of IBM's FORTRAN compilers (H Extended IUP) had a level of optimization which reordered the machine code instructions to keep multiple internal arithmetic units busy simultaneously.  Another example is CFD, a special variant of FORTRAN designed specifically for the ILLIAC IV supercomputer, running at NASA's Ames Research Center.
IBM Research Labs also developed an extended FORTRAN-based language called VECTRAN for processing vectors and matrices.
Object-Oriented Fortran was an object-oriented extension of Fortran, in which data items can be grouped into objects, which can be instantiated and executed in parallel.  It was available for Sun, Iris, iPSC, and nCUBE, but is no longer supported.
Such machine-specific extensions have either disappeared over time or have had elements incorporated into the main standards. The major remaining extension is OpenMP, which is a cross-platform extension for shared memory programming.  One new extension, Coarray Fortran, is intended to support parallel programming.
FOR TRANSIT was the name of a reduced version of the IBM 704 FORTRAN language, which was implemented for the IBM 650, using a translator program developed at Carnegie in the late 1950s.[70] The following comment appears in the IBM Reference Manual (FOR TRANSIT Automatic Coding System C28-4038, Copyright 1957, 1959 by IBM):

The FORTRAN system was designed for a more complex machine than the 650, and consequently some of the 32 statements found in the FORTRAN Programmer's Reference Manual are not acceptable to the FOR TRANSIT system.  In addition, certain restrictions to the FORTRAN language have been added.  However, none of these restrictions make a source program written for FOR TRANSIT incompatible with the FORTRAN system for the 704.
The permissible statements were:

Arithmetic assignment statements, e.g., a = b
GO to n
GO TO (n1, n2, ..., nm), i
IF (a) n1, n2, n3
PAUSE
STOP
DO n i = m1, m2
CONTINUE
END
READ n, list
PUNCH n, list
DIMENSION V, V, V, ...
EQUIVALENCE (a,b,c), (d,c), ...
Up to ten subroutines could be used in one program.
FOR TRANSIT statements were limited to columns 7 through 56, only. Punched cards were used for input and output on the IBM 650.  Three passes were required to translate source code to the "IT" language, then to compile the IT statements into SOAP assembly language, and finally to produce the object program, which could then be loaded into the machine to run the program (using punched cards for data input, and outputting results onto punched cards).
Two versions existed for the 650s with a 2000 word memory drum:  FOR TRANSIT I (S) and FOR TRANSIT II, the latter for machines equipped with indexing registers and automatic floating-point decimal (bi-quinary) arithmetic.  Appendix A of the manual included wiring diagrams for the IBM 533 card reader/punch control panel.

Fortran-based languages[edit]
Prior to FORTRAN 77, many preprocessors were commonly used to provide a friendlier language, with the advantage that the preprocessed code could be compiled on any machine with a standard FORTRAN compiler.[71] These preprocessors would typically support structured programming, variable names longer than six characters, additional data types, conditional compilation, and even macro capabilities.  Popular preprocessors included EFL, FLECS, iftran, MORTRAN, SFtran, S-Fortran, Ratfor, and Ratfiv.  EFL, Ratfor and Ratfiv, for example, implemented C-like languages, outputting preprocessed code in standard FORTRAN 66.  The PFORT preprocessor was often used to verify that code conformed to a portable subset of the language.  Despite advances in the Fortran language, preprocessors continue to be used for conditional compilation and macro substitution.
One of the earliest versions of FORTRAN, introduced in the '60s, was popularly used in colleges and universities.  Developed, supported, and distributed by the University of Waterloo, WATFOR was based largely on FORTRAN IV.  A student using WATFOR could submit their batch FORTRAN job and, if there were no syntax errors, the program would move straight to execution.  This simplification allowed students to concentrate on their program's syntax and semantics, or execution logic flow, rather than dealing with submission Job Control Language (JCL), the compile/link-edit/execution successive process(es), or other complexities of the mainframe/minicomputer environment.  A down side to this simplified environment was that WATFOR was not a good choice for programmers needing the expanded abilities of their host processor(s), e.g., WATFOR typically had very limited access to I/O devices. WATFOR was succeeded by WATFIV and its later versions.

program; s=0 i=1,n; s=s+1; stop i; s='s'  Stop
  (line programming)
LRLTRAN was developed at the Lawrence Radiation Laboratory to provide support for vector arithmetic and dynamic storage, among other extensions to support systems programming.  The distribution included the Livermore Time Sharing System (LTSS) operating system.
The Fortran-95 Standard includes an optional Part 3 which defines an optional conditional compilation capability.  This capability is often referred to as "CoCo".
Many Fortran compilers have integrated subsets of the C preprocessor into their systems.
SIMSCRIPT is an application specific Fortran preprocessor for modeling and simulating large discrete systems.
The F programming language was designed to be a clean subset of Fortran 95 that attempted to remove the redundant, unstructured, and deprecated features of Fortran, such as the EQUIVALENCE statement.  F retains the array features added in Fortran 90, and removes control statements that were made obsolete by structured programming constructs added to both FORTRAN 77 and Fortran 90.  F is described by its creators as "a compiled, structured, array programming language especially well suited to education and scientific computing".[72] Essential Lahey Fortran 90 (ELF90) was a similar subset.
Lahey and Fujitsu teamed up to create Fortran for the Microsoft .NET Framework.[73] Silverfrost FTN95 is also capable of creating .NET code.[74]

Code examples[edit]
Further information: Wikibooks:Fortran/Fortran examples
The following program illustrates dynamic memory allocation and array-based operations, two features introduced with Fortran 90.  Particularly noteworthy is the absence of DO loops and IF/THEN statements in manipulating the array; mathematical operations are applied to the array as a whole.  Also apparent is the use of descriptive variable names and general code formatting that conform with contemporary programming style.  This example computes an average over data entered interactively.

program average

    ! Read in some numbers and take the average
    ! As written, if there are no data points, an average of zero is returned
    ! While this may not be desired behavior, it keeps this example simple

    implicit none

    real, allocatable :: points(:)
    integer           :: number_of_points
    real              :: average_points, positive_average, negative_average
    average_points   = 0.
    positive_average = 0.
    negative_average = 0.
    write (*,*) "Input number of points to average:"
    read  (*,*) number_of_points

    allocate (points(number_of_points))

    write (*,*) "Enter the points to average:"
    read  (*,*) points

    ! Take the average by summing points and dividing by number_of_points
    if (number_of_points > 0) average_points = sum(points) / number_of_points

    ! Now form average over positive and negative points only
    if (count(points > 0.) > 0) positive_average = sum(points, points > 0.) / count(points > 0.)
    if (count(points < 0.) > 0) negative_average = sum(points, points < 0.) / count(points < 0.)

    ! Print result to terminal stdout unit 6
    write (*,'(a,g12.4)') 'Average = ', average_points
    write (*,'(a,g12.4)') 'Average of positive points = ', positive_average
    write (*,'(a,g12.4)') 'Average of negative points = ', negative_average
    deallocate (points) ! free memory

end program average

Humor[edit]
During the same FORTRAN standards committee meeting at which the name "FORTRAN 77" was chosen, a satirical technical proposal was incorporated into the official distribution bearing the title "Letter O Considered Harmful".  This proposal purported to address the confusion that sometimes arises between the letter "O" and the numeral zero, by eliminating the letter from allowable variable names.  However, the method proposed was to eliminate the letter from the character set entirely (thereby retaining 48 as the number of lexical characters, which the colon had increased to 49).  This was considered beneficial in that it would promote structured programming, by making it impossible to use the notorious GO TO statement as before. (Troublesome FORMAT statements would also be eliminated.) It was noted that this "might invalidate some existing programs" but that most of these "probably were non-conforming, anyway".[75][unreliable source?][76]
When X3J3 debated whether the minimum trip count for a DO loop should be zero or one in Fortran 77, Loren Meissner suggested a minimum trip count of two—reasoning (tongue-in-cheek) that if it were less than two, then there would be no reason for a loop.
When assumed-length arrays were being added, there was a dispute as to the appropriate character to separate upper and lower bounds. In a comment examining these arguments, Walt Brainerd penned an article entitled "Astronomy vs. Gastroenterology" because some proponents had suggested using the star or asterisk ("*"), while others favored the colon (":").[citation needed]
Variable names beginning with the letters I–N have a default type of integer, while variables starting with any other letters defaulted to real, although programmers could override the defaults with an explicit declaration.[77] This led to the joke: "In FORTRAN, GOD is REAL (unless declared INTEGER)."

See also[edit]

Computer programming portal
f2c – program to convert Fortran 77 to C codePages displaying wikidata descriptions as a fallback
F2PY – Python library for numerical programming
FORMAC – computer algebra system based on FORTRANPages displaying wikidata descriptions as a fallback
List of Fortran compilers
List of Fortran numerical libraries
List of programming languages
Matrix representation – storage method in computer memoryPages displaying wikidata descriptions as a fallback
Spaghetti code – Software source code with poor structure
References[edit]


^ "Chapel spec (Acknowledgements)" (PDF). Cray Inc. October 1, 2015. Archived (PDF) from the original on February 5, 2016. Retrieved January 14, 2016.

^ Report of a Visit to Discuss Common Programming Languages in Czechoslowakia and Poland, 1963, John A. Gosden (Editor), Roger E. Gay, John L. Jones, Jack N. Merner, Christopher J. Shaw

^ John Backus. "The history of FORTRAN I, II and III" (PDF). Softwarepreservation.org. Archived (PDF) from the original on July 26, 2007. Retrieved November 19, 2014.

^ Wilson, Leslie B. (2001). Comparative Programming Languages, Third Edition. Addison-Wesley. p. 16. ISBN 0-201-71012-9. The manual for Fortran I was released in 1956, but it was 1958 before successful compilers were running programs correctly.

^ Loh, Eugene (June 18, 2010). "The Ideal HPC Programming Language". ACM Queue. 8 (6): 30–38. doi:10.1145/1810226.1820518.

^ "HPL –  A Portable Implementation of the High-Performance Linpack Benchmark for Distributed-Memory Computers". Retrieved February 21, 2015.

^ "Q13. What are the benchmarks?". Overview – CPU 2017. SPEC. Retrieved November 13, 2019.

^ Wilson, Leslie B. (2001). Comparative Programming Languages, Third Edition. Addison-Wesley. p. 18. ISBN 0-201-71012-9. Another problem was that there was no standard for Fortran and so slightly different versions ... would likely fail when used with a different compiler.

^ TIOBE Software BV (May 2024). "TIOBE Index". TIOBE.com. TIOBE. Retrieved May 6, 2024.

^ a b c d e Backus, John Warner; Beeber, R. J.; Best, Sheldon F.; Goldberg, Richard; Herrick, Harlan L.; Hughes, R. A.; Mitchell, L. B.; Nelson, Robert A.; Nutt, Roy; Sayre, David; Sheridan, Peter B.; Stern, Harold; Ziller, Irving (October 15, 1956). Sayre, David (ed.). The FORTRAN Automatic Coding System for the IBM 704 EDPM: Programmer's Reference Manual (PDF). New York, USA: Applied Science Division and Programming Research Department, International Business Machines Corporation. pp. 2, 19–20. Archived (PDF) from the original on July 4, 2022. Retrieved July 4, 2022. (2+51+1 pages)

^ a b c d e f Backus, John (October–December 1998). "The History of Fortran I, II, and III" (PDF). IEEE Annals of the History of Computing. 20 (4): 68–78. doi:10.1109/85.728232. Archived (PDF) from the original on March 3, 2016. Retrieved June 17, 2020. [1][2]

^ "FORTRAN: The Pioneering Programming Language". IBM. March 7, 2012. Retrieved July 19, 2017.

^ "FORTRAN". Encyclopedia Britannica. June 14, 2021. Retrieved July 19, 2021.

^ Chapman, Stephen J. (2018). Fortran for Scientists and Engineers (Fourth ed.). New York: McGraw-Hill Education. p. 13. ISBN 978-0-07-338589-1.

^ The "Fortran character set" defined by the FORTRAN 77 standard was the minimal character set that standard-compliant compilers were required to support; in practice, many FORTRAN 77 compilers supported the full ASCII character set.

^ a b J. W. Backus; R. J. Beeber; S. Best; R. Goldberg; L. M. Haibt; H. L. Herrick; R. A. Nelson; D. Sayre; P. B. Sheridan; H. Stern; L. Ziller; R. A. Hughes; R. Nutt (February 1957). The FORTRAN Automatic Coding System (PDF). Western Joint Computer Conference. pp. 188–198. doi:10.1145/1455567.1455599.

^ Mindell, David (2008). Digital Apollo. Cambridge, MA: MIT Press. p. 99. ISBN 978-0-262-13497-2. JSTOR j.ctt5hhn02. OCLC 228031739.

^ Padua, David (January–February 2000). "The Fortran I Compiler" (PDF). Computing in Science & Engineering. 2 (1): 70–75. Bibcode:2000CSE.....2a..70P. doi:10.1109/5992.814661. Archived from the original (PDF) on June 17, 2020. The Fortran I compiler was the first major project in code optimization. It tackled problems of crucial importance whose general solution was an important research focus in compiler technology for several decades. Many classical techniques for compiler analysis and optimization can trace their origins and inspiration to the Fortran I compiler.

^ Brian Bergstein (May 20, 2007). "Fortran creator John Backus dies". MSNBC. Retrieved October 29, 2018.

^ "FORTRAN – The First Programming Language for Numeric Calculations". SciHi Blog. October 15, 2019.

^ Haines, L. H. (1965). "Serial compilation and the 1401 FORTRAN compiler". IBM Systems Journal. 4 (1): 73–80. doi:10.1147/sj.41.0073.

^ Lee, John A. N. (1967). Anatomy of a Compiler. Van Nostrand Reinhold.

^ Fortran Specifications and Operating Procedures, IBM 1401 (PDF). IBM. C24-1455-2. Archived (PDF) from the original on September 23, 2017.

^ "Subject: GOTRAN ON THE IBM 1316 DISK STORAGE PACK (Serial No. K7402)". Archived from the original on February 21, 2006. Retrieved March 3, 2006.

^ The FORTRAN Automatic Coding System for the IBM 704 EDPM : Preliminary Operator's Manual (PDF). Programming Research Department, International Business Machines Corporation. April 8, 1957. pp. 6–37. Archived (PDF) from the original on February 26, 2014.

^ Armstead, Betty Jo (January 21, 2015). "My Years at NASA" (PDF). Denver Museum of Nature & Science. Archived from the original (PDF) on December 24, 2019. Retrieved June 15, 2019.

^ Reference Manual, IBM 7090 Data Processing System (PDF). 1961. A22-6528-3. Archived (PDF) from the original on December 1, 2008.

^ Fortran II General Information Manual (PDF). 1963. Archived (PDF) from the original on April 26, 2005. Retrieved November 19, 2014.

^ Reference Manual, FORTRAN II for the IBM 704 Data Processing System (PDF). 1958. C28-6000-2. Archived (PDF) from the original on October 30, 2005.

^ "Recursion". User Notes on FORTRAN Programming (UNFP). Retrieved September 15, 2014.

^ IBM System/360 FORTRAN IV Language, Form C28-6515-6 (PDF). IBM. April 1966.

^ a b c "DECSYSTEM-10 FORTRAN IV (F40) Programmers Reference Manual" (PDF). Github. Digital Equipment Corporation. Retrieved April 15, 2022.

^ Fortran IV Language Specifications, Program Specifications, and Operating Procedures, IBM 1401, 1440, and 1460 (PDF). IBM. April 1966. C24-3322-2. Archived (PDF) from the original on September 23, 2017.

^ McCracken, Daniel D. (1965). "Preface". A Guide to FORTRAN IV Programming. New York: Wiley. p. v. ISBN 978-0-471-58281-6.

^ "List of FORTRAN Implementations 1957 – 1967". BCS Fortran Specialist Group. IEEE Annals. 2017. Retrieved October 17, 2017.

^ IBM System/360 Model 50 Functional Characteristics (PDF). IBM. 1967. A22-6898-1. Archived (PDF) from the original on October 29, 2021 – via bitsavers.

^ a b "FORTRAN IV". WorldCat.org. Retrieved December 10, 2023.

^ MIL-STD 1753 - FORTRAN, DoD Supplement To American National Standard X3.9-1978. United States Government Printing Office. November 9, 1978. Retrieved April 21, 2024.

^ IEEE 1003.9-1992 – IEEE Standard for InformationTechnology – POSIX(R) FORTRAN 77 Language Interfaces – Part 1: Binding for System Application Program Interface (API). IEEE. Retrieved November 24, 2018.

^ ANSI X3.198-1992 (R2002) (Fortran 90), Appendix B.1.

^ "Fortran 95 Reference". Gnu.Org. Retrieved May 10, 2014.

^ Lionel, Steve (December 30, 2013). "Doctor Fortran in "It's a Modern Fortran World"". Intel (was DEC) Fortran forum discussion group. Intel. Retrieved April 11, 2022.

^ "Fortran 2003– Last Working Draft". Gnu.Org. Retrieved May 10, 2014.

^ "WG5 Completes Processing Fortran 2003 and the TR". nag.co.uk. May 14, 2004. Archived from the original on August 5, 2004. Retrieved April 3, 2023.. It may also be downloaded as a PDF file at "The New Features of Fortran 2003" (PDF). Archived (PDF) from the original on January 15, 2018. Retrieved April 3, 2023.

^ "N1836, Summary of Voting/Table of Replies on ISO/IEC FDIS 1539-1, Information technology – Programming languages – Fortran – Part 1: Base language" (PDF). Archived (PDF) from the original on January 15, 2018.

^ "Fortran 2008 – Last Working Draft" (PDF). Gnu.Org. Archived (PDF) from the original on May 12, 2014. Retrieved May 10, 2014.

^ N1830, Information technology – Programming languages – Fortran – Part 1: Base language [3][dead link]

^ ISO/IEC TS 29113:2012 – Information technology – Further interoperability of Fortran with C.

^ "Draft of the Technical Specification (TS) 29113" (PDF). wg5-fortran.org. Archived (PDF) from the original on January 15, 2018.

^ "Doctor Fortran in "Eighteen is the new Fifteen"". Software.intel.com. Retrieved November 20, 2017.

^ "Fortran 2018". ISO. Retrieved November 30, 2018.

^ "Further Interoperability with C" (PDF). ISO. Archived (PDF) from the original on December 1, 2017. Retrieved November 20, 2017.

^ "Additional Parallel Features in Fortran". ISO. Retrieved November 20, 2017.

^ "The New Features of Fortran 2015". ISO. Retrieved June 23, 2017.

^ "Doctor Fortran in "One Door Closes"". Software.intel.com. Retrieved September 21, 2015.

^ "Doctor Fortran Goes Dutch: Fortran 2015". Software.intel.com. Archived from the original on April 1, 2017. Retrieved November 19, 2014. The ISO Fortran Standards Committee held its annual meeting in Delft, [...]

^ 
Fortran 2018 Interpretation Document (PDF). October 9, 2018.

^ "Fortran 2023". wg5-fortran.org. Retrieved November 30, 2023.

^ Kemeny, John G.; Kurtz, Thomas E. (October 11, 1968). "Dartmouth Time-Sharing". Science. 162 (3850): 223–228. Bibcode:1968Sci...162..223K. doi:10.1126/science.162.3850.223. PMID 5675464.

^ Phillips, Lee (May 8, 2014). "Scientific computing's future: Can any coding language top a 1950s behemoth?". Ars Technica. Retrieved May 8, 2014.

^ Pasachoff, Jay M. (April 1984). "Scientists: FORTRAN vs. Modula-2". BYTE (letter). p. 404. Retrieved February 6, 2015.

^ Galperin, Boris (1993). "26". Large Eddy Simulation of Complex Engineering and Geophysical Flows. London: Cambridgey. p. 573. ISBN 978-0-521-43009-8.

^ Brandt, Siegmund (1970). Statistical and Computational Methods in Data Analysis. North-Holland Publishing Company. pp. Preface. ISBN 0-7204-2033-4.

^ Curcic, Milan (November 24, 2020). Modern Fortran: Building efficient parallel applications. Simon and Schuster. ISBN 978-1-61729-528-7.

^ Gaffney, P W; Wooten, J W (May 1, 1980). Methods to ensure the standardization of FORTRAN software (Report). Oak Ridge National Laboratory. OSTI 5361454. PFORT ... Library ...

^ a b P. A. Fox (1977). "Port — A portable mathematical subroutine library". A portable mathematical subroutine library. Lecture Notes in Computer Science. Vol. 57. pp. 165–177. doi:10.1007/3-540-08446-0_42. ISBN 978-3-540-08446-4. PORT ... written in (PFORT) .. ANS Fortran

^ Whitten, Douglas E.; Demaine, Paul A. D. (1975). "A machine and configuration independent Fortran: Portable Fortran {PFortran}". IEEE Transactions on Software Engineering. SE-1 (1). Institute of Electrical and Electronics Engineers (IEEE): 111–124. doi:10.1109/tse.1975.6312825. ISSN 0098-5589. S2CID 16485156.

^ "Portability Issues". .. discusses .. portability of .. Fortran

^ Healy, MJR (1968). "Towards FORTRAN VI". Advanced scientific Fortran by CDC. CDC. pp. 169–172. Archived from the original on July 5, 2009. Retrieved April 10, 2009.

^ Perlis, A. J.; Smith, J. W.; Van Zoeren, H. R. Internal Translator (IT) A Compiler for the IBM 650 (PDF). Computation Center, Carnegie Institute of Technology. Archived (PDF) from the original on October 2, 2012.

^ Meissner, Loren (September 1, 1975). "On extending Fortran control structures to facilitate structured programming". ACM SIGPLAN Notices. 10 (9). acm.org: 19–30. doi:10.1145/987316.987320.

^ "F Programming Language Homepage". Fortran.com. Archived from the original on January 9, 2015. Retrieved November 19, 2014.

^ "Fortran for .NET Language System". Archived from the original on October 18, 2014.

^ "FTN95: Fortran 95 for Windows". Silverfrost.com. Retrieved November 19, 2014.

^ X3J3 post-meeting distribution for meeting held at Brookhaven National Laboratory in November 1976.

^ "The obliteration of O". Computer Weekly. March 3, 1977.

^ Rules for Data Typing (FORTRAN 77 Language Reference). Retrieved September 29, 2016.


Further reading[edit]
Language standards
ANSI x3.9-1966. USA Standard FORTRAN (PDF). American National Standards Institute. Archived from the original (PDF) on May 15, 2011. Retrieved May 5, 2010. Informally known as FORTRAN 66.
ANSI x3.9-1978. American National Standard – Programming Language FORTRAN. American National Standards Institute. Archived from the original on October 29, 2013. Retrieved December 11, 2007. Also known as ISO 1539–1980, informally known as FORTRAN 77.
ANSI X3.198-1992 (R2002) / ISO/IEC 1539:1991. American National Standard – Programming Language Fortran Extended. American National Standards Institute / ISO/IEC. Informally known as Fortran 90.
ISO/IEC 1539-1:1997. Information technology – Programming languages – Fortran – Part 1: Base language (PDF). Archived from the original (PDF) on August 18, 2011. Retrieved December 13, 2007. Informally known as Fortran 95.  There are a further two parts to this standard.  Part 1 has been formally adopted by ANSI.
ISO/IEC 1539-1:2004. Information technology – Programming languages – Fortran – Part 1: Base language (PDF). Archived from the original (PDF) on July 31, 2023. Informally known as Fortran 2003.
ISO/IEC 1539-1:2010 (Final Draft International Standard). Information technology – Programming languages – Fortran – Part 1: Base language (PDF).[permanent dead link] Informally known as Fortran 2008.
Related standards
Kneis, Wilfried (October 1981). "Draft standard Industrial Real-Time FORTRAN". ACM SIGPLAN Notices. 16 (7): 45–60. doi:10.1145/947864.947868. ISSN 0362-1340. S2CID 8662381.
ISO 8651-1:1988 Information processing systems – Computer graphics – Graphical Kernel System (GKS) language bindings – Part 1: FORTRAN. Geneva, Switzerland: ISO. 1988.
Other reference material
ECMA Standard on FORTRAN (PDF). European Computer Manufacturers Association. April 1965. Archived (PDF) from the original on May 10, 2008. Retrieved November 17, 2014.
FORTRAN 77 4.0 Reference Manual (PDF). Sun Microsystems, Inc. 1995. Archived from the original (PDF) on January 5, 2012. Retrieved November 17, 2014.
"FORTRAN Coding Form" (PDF). IBM. Archived from the original (PDF) on June 8, 2015. Retrieved November 17, 2014.
IBM System/360 and System/370 Fortran IV Language (PDF). IBM. May 1974. Archived from the original (PDF) on April 6, 2011. Retrieved November 17, 2014.
Goerz, Michael (2014). "Modern Fortran Reference Card" (PDF). Archived (PDF) from the original on December 14, 2014. Retrieved December 14, 2014.
Books
Adams, Jeanne C.; Brainerd, Walter S.; Hendrickson, Richard A.; Maine, Richard E.; Martin, Jeanne T.; Smith, Brian T. (2009). The Fortran 2003 Handbook (1st ed.). Springer. ISBN 978-1-84628-378-9.
Akin, J. E. (2003). Object-oriented programming via Fortran 90/95. Cambridge, New York: Cambridge University Press. ISBN 978-0-521-52408-7. OCLC 49906306.
Arjen, Markus (2012), "Modern Fortran in Practice", Cambridge Univ. Press, ISBN 978-1-13908479-6.
Brainerd, W.S.; Goldberg, C.H.; Adams, J.C. (1996). Programmer's Guide to Fortran 90 (3rd ed.). Springer. ISBN 978-0-387-94570-5.
Brainerd, Walter (2015). Guide to Fortran 2008 programming. London: Springer. ISBN 978-1-4471-6758-7. OCLC 920530344.
Chapman, Stephen J. (2018). Fortran for Scientists and Engineers (Fourth ed.). New York: McGraw-Hill Education. pp. xxiv + 1024. ISBN 978-0-07-338589-1.
Chivers, Ian; Sleightholme, Jane (2018). Introduction to Programming with Fortran (4th ed.). Springer. ISBN 978-3-319-75501-4.
Clerman, Norman (2012). Modern Fortran : style and usage. New York: Cambridge University Press. ISBN 978-0-521-51453-8. OCLC 776162717.
Curcic, Milan (2020). Modern Fortran: building efficient parallel applications. Shelter Island, NY: Manning Publications Company. ISBN 978-1-61729-528-7. OCLC 1256806439.
Ellis, T. M. R.; Phillips, Ivor R.; Lahey, Thomas M. (1994). Fortran 90 Programming (1st ed.). Addison Wesley. ISBN 978-0-201-54446-6.
Etter, D. M. (1990). Structured FORTRAN 77 for Engineers and Scientists (3rd ed.). The Benjamin/Cummings Publishing Company, Inc. ISBN 978-0-8053-0051-2.
Kerrigan, J. F. (1993). Migrating to Fortran 90 (1st ed.). O'Reilly & Associates, Inc. ISBN 1-56592-049-X.
Kupferschmid, Michael (2002). Classical Fortran: Programming for Engineering and Scientific Applications. Marcel Dekker (CRC Press). ISBN 978-0-8247-0802-3. (Supplemental materials)
Lorenzo, Mark Jones (2019). Abstracting Away the Machine: The History of the FORTRAN Programming Language (FORmula TRANslation). Independently published. ISBN 978-1082395949.
Loukides, Mike (1990). Unix for FORTRAN Programmers. Sebastopol, CA: O'Reilly & Associates, Inc. ISBN 0-937175-51-X.
McCracken, Daniel D. (1961). A Guide to FORTRAN Programming. New York: Wiley. LCCN 61016618.
Metcalf, Michael; Reid, John; Cohen, Malcolm; Bader, Reinhold (2024). Modern Fortran Explained: Incorporating Fortran 2023 (6th ed.). Oxford University Press. ISBN 9780198876595.
Nyhoff, Larry; Sanford Leestma (1995). FORTRAN 77 for Engineers and Scientists with an Introduction to Fortran 90 (4th ed.). Prentice Hall. ISBN 978-0-13-363003-9.
Page, Clive G. (1988). Professional Programmer's Guide to Fortran77 (June 7, 2005 ed.). London: Pitman. ISBN 978-0-273-02856-7. Retrieved May 4, 2010.
Press, William H. (1996). Numerical Recipes in Fortran 90: The Art of Parallel Scientific Computing. Cambridge, UK: Cambridge University Press. ISBN 978-0-521-57439-6.
Ruetsch, Gregory; Fatica, Massimiliano (2013). CUDA Fortran for Scientists and Engineers (1st ed.). Elsevier. p. 338. ISBN 9780124169708.
Sleighthome, Jane; Chivers, Ian David (1990). Interactive Fortran 77: A Hands-On Approach. Computers and their applications (2nd ed.). Chichester: E. Horwood. ISBN 978-0-13-466764-5. Archived from the original on March 12, 2014. Retrieved March 12, 2014.
Articles
Allen, F.E. (September 1981). "A History of Language Processor Technology in IBM". IBM Journal of Research and Development. 25 (5): 535–548. doi:10.1147/rd.255.0535. S2CID 14149353.
J. W. Backus; R. J. Beeber; S. Best; R. Goldberg; L. M. Haibt; H. L. Herrick; R. A. Nelson; D. Sayre; P. B. Sheridan; H. Stern; L. Ziller; R. A. Hughes; R. Nutt (February 1957). The FORTRAN Automatic Coding System (PDF). Western Joint Computer Conference. pp. 188–198. doi:10.1145/1455567.1455599.
Chivers, Ian D.; Sleightholme, Jane (2022). "Compiler support for Fortran 2008 & 2018 standards".
Pigott, Diarmuid (2006). "FORTRAN – Backus et al high-level compiler (Computer Language)". The Encyclopedia of Computer Languages. Murdoch University. Archived from the original on October 8, 2009. Retrieved May 5, 2010.
Roberts, Mark L.; Griffiths, Peter D. (1985). "Design Considerations for IBM Personal Computer Professional FORTRAN, an Optimizing Compiler". IBM Systems Journal. 24 (1): 49–60. doi:10.1147/sj.241.0049.
External links[edit]



Wikibooks has a book on the topic of: Fortran




Wikiquote has quotations related to Fortran.

ISO/IEC JTC1/SC22/WG5—the official home of Fortran standards
Fortran Standards Documents—GFortran standards
fortran-lang.org (2020).
History of FORTRAN and Fortran II—Computer History Museum
Valmer Norrod, et al.: A self-study course in FORTRAN programing—Volume I—textbook, Computer Science Corporation El Segundo, California (April 1970). NASA (N70-25287).
Valmer Norrod, Sheldom Blecher, and Martha Horton: A self-study course in FORTRAN programing—Volume II—workbook, NASA CR-1478 (April 1970), NASA (N70-25288).
An introduction to the Fortran programming language, by Reinhold Bader, Nisarg Patel, Leibniz Supercomputing Centre.
A coarray tutorial
Victor Eijkhout : Introduction to Scientific Programming in C++17/Fortran2008, The Art of HPC, volume 3 (PDF) Archived February 5, 2023, at the Wayback Machine
vteIBMHistory
History
Mergers and acquisitions
PC business acquisition by Lenovo
ProductsHardwareCurrent
Mainframe
IBM Z
Power microprocessors
Power Systems
Storage
FlashSystem
DS8000
Quantum
Q System One
Q System Two
Eagle
Osprey
Heron
Condor
Former
Blue Gene
Cell microprocessors
PowerPC
Midrange computer
Personal Computer
Selectric
ThinkPad

Carbon Design System
Cloud
Cloudant
Cognos Analytics
Connections
Criminal Reduction Utilising Statistical History
Fortran
ILOG
Information Management Software
Lotus Software
Mainframe operating systems
Mashup Center
Planning Analytics
PureQuery
Quantum Platform
Qiskit
OpenQASM
Rational Software
SPSS
Tivoli Software
Service Automation Manager
Watson
Watsonx
Granite
WebSphere
BusinessentitiesCurrent
Apptio
Center for The Business of Government
Consulting
Promontory
Kenexa
International subsidiaries
India
Press
Red Hat
Research
Former
AdStar
AIM alliance
Kaleida Labs
Taligent
Ambra Computer
Cognos
EduQuest
Kyndryl
Lexmark
Merative
Microelectronics
Product Center
Science Research Associates
Service Bureau
The Weather Company (Weather Underground)
Facilities
Towers
1250 René-Lévesque, Montreal, QC
One Atlantic Center, Atlanta, GA
Software Labs
Rome Software Lab
Toronto Software Lab
IBM Buildings
330 North Wabash, Chicago, IL
Honolulu
Seattle
Facilities
Thomas J. Watson Research Center
Hakozaki Facility
Yamato Facility
Cambridge Scientific Center
IBM Hursley
Canada Head Office Building
IBM Rochester
Initiatives
Academy of Technology
Deep Thunder
Develothon
Fellow
The Great Mind Challenge
Linux Technology Center
SkillsBuild
Smarter Planet
Virtual Universe Community
World Community Grid
Think conference
Inventions
Automated teller machine
Cynefin framework
DRAM
Electronic keypunch
Floppy disk
Hard disk drive
Magnetic stripe card
Relational model
Sabre airline reservation system
Scanning tunneling microscope
Financial swaps
Universal Product Code
Terminology
Big Blue
Commercial Processing Workload
Customer engineer
Globally integrated enterprise
e-business
Think slogan
CEOs
Thomas J. Watson (1914–1956)
Thomas Watson Jr. (1956–1971)
T. Vincent Learson (1971–1973)
Frank T. Cary (1973–1981)
John R. Opel (1981–1985)
John Fellows Akers (1985–1993)
Louis V. Gerstner Jr. (1993–2002)
Samuel J. Palmisano (2002–2011)
Ginni Rometty (2012–2020)
Arvind Krishna (since 2020)
Board ofdirectors
Thomas Buberl
David Farr
Alex Gorsky
Michelle J. Howard
Arvind Krishna
Andrew Liveris
Martha E. Pollack
Joseph R. Swedish
Peter R. Voser
Other
A Boy and His Atom
Big Blue sports teams
American football
Rugby union
Common Public License/IBM Public License
Wallace v. International Business Machines Corp.
Deep Blue
Deep Thought
Dynamic infrastructure
GlobalFoundries
GUIDE International
IBM and the Holocaust
International chess tournament
Lucifer cipher
Mathematica
IBM Plex
SHARE computing
ScicomP
Unions

 Commons
 Category
 Navigational boxes
FOSS
Midrange computers
Operating systems
Personal computers
System/360
System/370
Typewriters
Vacuum tube computers

vteProgramming languages
Comparison
Timeline
History

Ada
ALGOL
Simula
APL
Assembly
BASIC
Visual Basic
classic
.NET
C
C++
C#
COBOL
Erlang
Elixir
Forth
Fortran
Go
Haskell
Java
JavaScript
Julia
Kotlin
Lisp
Lua
MATLAB
ML
Caml 
OCaml
Pascal
Object Pascal
Perl 
Raku
PHP
Prolog
Python
R
Ruby
Rust
SAS
SQL
Scratch
Shell
Smalltalk
Swift
more...

 Lists: Alphabetical
Categorical
Generational
Non-English-based
 Category

Authority control databases: National GermanyUnited StatesFranceBnF dataCzech RepublicSpainIsrael




Retrieved from "https://en.wikipedia.org/w/index.php?title=Fortran&oldid=1287755959"
Categories: FortranFortran programming language familyAmerican inventionsArray programming languagesComputer standardsNumerical programming languagesObject-oriented programming languagesProcedural programming languagesHigh-level programming languagesIBM softwareProgramming languages created in 1957Programming languages with an ISO standardStatically typed programming languagesUnix programming tools1957 softwareHidden categories: All articles with dead external linksArticles with dead external links from January 2016Articles with short descriptionShort description matches WikidataUse American English from April 2023All Wikipedia articles written in American EnglishUse mdy dates from April 2023All articles with unsourced statementsArticles with unsourced statements from April 2024Articles with unsourced statements from October 2011All articles lacking reliable referencesArticles lacking reliable references from August 2014Articles with unsourced statements from July 2016Pages displaying wikidata descriptions as a fallback via Module:Annotated linkArticles with dead external links from July 2017Articles with permanently dead external linksWebarchive template wayback links






 This page was last edited on 28 April 2025, at 07:58 (UTC).
Text is available under the Creative Commons Attribution-ShareAlike 4.0 License;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.


Privacy policy
About Wikipedia
Disclaimers
Contact Wikipedia
Code of Conduct
Developers
Statistics
Cookie statement
Mobile view














Search













Search









Toggle the table of contents







Fortran




























78 languages


Add topic
















