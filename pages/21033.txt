https://en.wikipedia.org/wiki/SPARC




SPARC - Wikipedia



































Jump to content







Main menu





Main menu
move to sidebar
hide



		Navigation
	


Main pageContentsCurrent eventsRandom articleAbout WikipediaContact us





		Contribute
	


HelpLearn to editCommunity portalRecent changesUpload fileSpecial pages



















Search











Search






















Appearance
















Donate

Create account

Log in








Personal tools





Donate Create account Log in





		Pages for logged out editors learn more



ContributionsTalk




























Contents
move to sidebar
hide




(Top)





1
Features








2
History








3
Architecture




Toggle Architecture subsection





3.1
Registers








3.2
Instruction formats








3.3
Instructions






3.3.1
Loads and stores








3.3.2
ALU operations








3.3.3
Branching








3.3.4
Large constants










3.4
Synthetic instructions










4
SPARC architecture licensees








5
Implementations








6
Operating system support








7
Open source implementations








8
Supercomputers








9
See also








10
References








11
External links


















Toggle the table of contents







SPARC



36 languages




العربيةБеларуская (тарашкевіца)БългарскиCatalàЧӑвашлаČeštinaDeutschEestiΕλληνικάEspañolفارسیFrançaisGalego한국어Bahasa IndonesiaItalianoעבריתLatviešuLietuviųMagyarNederlands日本語Norsk bokmålPolskiPortuguêsRomânăРусскийSlovenčinaSlovenščinaСрпски / srpskiSuomiSvenskaTürkçeУкраїнськаTiếng Việt中文

Edit links











ArticleTalk





English

















ReadEditView history







Tools





Tools
move to sidebar
hide



		Actions
	


ReadEditView history





		General
	


What links hereRelated changesUpload filePermanent linkPage informationCite this pageGet shortened URLDownload QR code





		Print/export
	


Download as PDFPrintable version





		In other projects
	


Wikimedia CommonsWikidata item





















Appearance
move to sidebar
hide










From Wikipedia, the free encyclopedia


RISC instruction set architecture
For other uses, see SPARC (disambiguation).


SPARCDesignerSun Microsystems (acquired by Oracle Corporation)[1][2]Bits64-bit (32 → 64)Introduced1986; 39 years ago (1986) (production)1987; 38 years ago (1987) (shipments)VersionV9 (1993) / OSA2017DesignRISCTypeLoad–storeEncodingFixedBranchingCondition codeEndiannessBi (Big → Bi)Page size8 KB (4 KB → 8 KB)ExtensionsVIS 1.0, 2.0, 3.0, 4.0OpenYes, and royalty freeRegistersGeneral-purpose31 (G0 = 0; non-global registers use register windows)Floating point32 (usable as 32 single-precision, 32 double-precision, or 16 quad-precision)
A Sun UltraSPARC II microprocessor (1997)
SPARC (Scalable Processor ARChitecture) is a reduced instruction set computer (RISC) instruction set architecture originally developed by Sun Microsystems.[1][2] Its design was strongly influenced by the experimental Berkeley RISC system developed in the early 1980s. First developed in 1986 and released in 1987,[3][2] SPARC was one of the most successful early commercial RISC systems, and its success led to the introduction of similar RISC designs from many vendors through the 1980s and 1990s.
The first implementation of the original 32-bit architecture (SPARC V7) was used in Sun's Sun-4 computer workstation and server systems, replacing their earlier Sun-3 systems based on the Motorola 68000 series of processors. SPARC V8 added a number of improvements that were part of the SuperSPARC series of processors released in 1992. SPARC V9, released in 1993, introduced a 64-bit architecture and was first released in Sun's UltraSPARC processors in 1995. Later, SPARC processors were used in symmetric multiprocessing (SMP) and non-uniform memory access (CC-NUMA) servers produced by Sun, Solbourne, and Fujitsu, among others.
The design was turned over to the SPARC International trade group in 1989, and since then its architecture has been developed by its members. SPARC International is also responsible for licensing and promoting the SPARC architecture, managing SPARC trademarks (including SPARC, which it owns), and providing conformance testing. SPARC International was intended to grow the SPARC architecture to create a larger ecosystem; SPARC has been licensed to several manufacturers, including Atmel, Bipolar Integrated Technology, Cypress Semiconductor, Fujitsu, Matsushita and Texas Instruments. Due to SPARC International, SPARC is fully open, non-proprietary and royalty-free.
As of 2024, the latest commercial high-end SPARC processors are Fujitsu's SPARC64 XII (introduced in September 2017 for its SPARC M12 server) and Oracle's SPARC M8 introduced in September 2017 for its high-end servers.
On September 1, 2017, after a round of layoffs that started in Oracle Labs in November 2016, Oracle terminated SPARC design after completing the M8. Much of the processor core development group in Austin, Texas, was dismissed, as were the teams in Santa Clara, California, and Burlington, Massachusetts.[4][5]
Fujitsu will also discontinue their SPARC production (has already shifted to producing their own ARM-based CPUs), after two "enhanced" versions of Fujitsu's older SPARC M12 server in 2020–22 (formerly planned for 2021) and again in 2026–27, end-of-sale in 2029, of UNIX servers and a year later for their mainframe and end-of-support in 2034 "to promote customer modernization".[6]


Features[edit]
The SPARC architecture was heavily influenced by the earlier RISC designs, including the RISC I and II from the University of California, Berkeley and the IBM 801. These original RISC designs were minimalist, including as few features or op-codes as possible and aiming to execute instructions at a rate of almost one instruction per clock cycle. This made them similar to the MIPS architecture in many ways, including the lack of instructions such as multiply or divide. Another feature of SPARC influenced by this early RISC movement is the branch delay slot.
The SPARC processor usually contains as many as 160 general-purpose registers. According to the "Oracle SPARC Architecture 2015" specification an "implementation may contain from 72 to 640 general-purpose 64-bit" registers.[7] At any point, only 32 of them are immediately visible to software — 8 are a set of global registers (one of which, g0, is hard-wired to zero, so only seven of them are usable as registers) and the other 24 are from the stack of registers. These 24 registers form what is called a register window, and at function call/return, this window is moved up and down the register stack. Each window has eight local registers and shares eight registers with each of the adjacent windows. The shared registers are used for passing function parameters and returning values, and the local registers are used for retaining local values across function calls.
The "scalable" in SPARC comes from the fact that the SPARC specification allows implementations to scale from embedded processors up through large server processors, all sharing the same core (non-privileged) instruction set.  One of the architectural parameters that can scale is the number of implemented register windows; the specification allows from three to 32 windows to be implemented, so the implementation can choose to implement all 32 to provide maximum call stack efficiency, or to implement only three to reduce cost and complexity of the design, or to implement some number between them. Other architectures that include similar register file features include Intel i960, IA-64, and AMD 29000.
The architecture has gone through several revisions. It gained hardware multiply and divide functionality in version 8.[8][9] 64-bit (addressing and data) were added to the version 9 SPARC specification published in 1994.[10]
In SPARC version 8, the floating-point register file has 16 double-precision registers. Each of them can be used as two single-precision registers, providing a total of 32 single-precision registers. An odd–even number pair of double-precision registers can be used as a quad-precision register, thus allowing 8 quad-precision registers. SPARC Version 9 added 16 more double-precision registers (which can also be accessed as 8 quad-precision registers), but these additional registers can not be accessed as single-precision registers. No SPARC CPU implements quad-precision operations in hardware as of 2024.[11]
Tagged add and subtract instructions perform adds and subtracts on values checking that the bottom two bits of both operands are 0 and reporting overflow if they are not.  This can be useful in the implementation of the run time for ML, Lisp, and similar languages that might use a tagged integer format.
The endianness of the 32-bit SPARC V8 architecture is purely big-endian. The 64-bit SPARC V9 architecture uses big-endian instructions, but can access data in either big-endian or little-endian byte order, chosen either at the application instruction (load–store) level or at the memory page level (via an MMU setting).  The latter is often used for accessing data from inherently little-endian devices, such as those on PCI buses.

History[edit]
There have been three major revisions of the architecture. The first published version was the 32-bit SPARC version 7 (V7) in 1986. SPARC version 8 (V8), an enhanced SPARC architecture definition, was released in 1990.  The main differences between V7 and V8 were the addition of integer multiply and divide instructions, and an upgrade from 80-bit "extended-precision" floating-point arithmetic to 128-bit "quad-precision" arithmetic.  SPARC V8 served as the basis for IEEE Standard 1754-1994, an IEEE standard for a 32-bit microprocessor architecture.
SPARC version 9, the 64-bit SPARC architecture, was released by SPARC International in 1993.  It was developed by the SPARC Architecture Committee consisting of Amdahl Corporation, Fujitsu, ICL, LSI Logic, Matsushita, Philips, Ross Technology, Sun Microsystems, and Texas Instruments. Newer specifications always remain compliant with the full SPARC V9 Level 1 specification.
In 2002, the SPARC Joint Programming Specification 1 (JPS1) was released by Fujitsu and Sun, describing processor functions which were identically implemented in the CPUs of both companies ("Commonality"). The first CPUs conforming to JPS1 were the UltraSPARC III by Sun and the SPARC64 V by Fujitsu. Functionalities which are not covered by JPS1 are documented for each processor in "Implementation Supplements".
At the end of 2003, JPS2 was released to support multicore CPUs. The first CPUs conforming to JPS2 were the UltraSPARC IV by Sun and the SPARC64 VI by Fujitsu.
In early 2006, Sun released an extended architecture specification, UltraSPARC Architecture 2005. This includes not only the non-privileged and most of the privileged portions of SPARC V9, but also all the architectural extensions developed through the processor generations of UltraSPARC III, IV, and IV+, as well as CMT extensions starting with the UltraSPARC T1 implementation:

the VIS 1 and VIS 2 instruction set extensions and the associated GSR register
multiple levels of global registers, controlled by the GL register
Sun's 64-bit MMU architecture
privileged instructions ALLCLEAN, OTHERW, NORMALW, and INVALW
access to the VER register is now hyperprivileged
the SIR instruction is now hyperprivileged
In 2007, Sun released an updated specification, UltraSPARC Architecture 2007, to which the UltraSPARC T2 implementation complied.
In December 2007, Sun also made the UltraSPARC T2 processor's RTL available via the OpenSPARC project.[12] It was also released under the GNU General public license v2.[13] OpenSPARC T2 is 8 cores, 16 pipelines with 64 threads.
In August 2012, Oracle Corporation made available a new specification, Oracle SPARC Architecture 2011, which besides the overall update of the reference, adds the VIS 3 instruction set extensions and hyperprivileged mode to the 2007 specification.[14]
In October 2015, Oracle released SPARC M7, the first processor based on the new Oracle SPARC Architecture 2015 specification.[7][15]  This revision includes VIS 4 instruction set extensions and hardware-assisted encryption and silicon secured memory (SSM).[16]
SPARC architecture has provided continuous application binary compatibility from the first SPARC V7 implementation in 1987 through the Sun UltraSPARC Architecture implementations.
Among various implementations of SPARC, Sun's SuperSPARC and UltraSPARC-I were very popular, and were used as reference systems for SPEC CPU95 and CPU2000 benchmarks. The 296 MHz UltraSPARC-II is the reference system for the SPEC CPU2006 benchmark.

Architecture[edit]
SPARC is a load–store architecture (also known as a register–register architecture); except for the load/store instructions used to access memory, all instructions operate on the registers, in accordance with the RISC design principles.
A SPARC processor includes an integer unit (IU) that performs integer load, store, and arithmetic operations.[17]: 9 [10]: 15–16   It may include a floating-point unit (FPU) that performs floating-point operations[17]: 9 [10]: 15–16  and, for SPARC V8, may include a co-processor (CP) that performs co-processor-specific operations; the architecture does not specify what functions a co-processor would perform, other than load and store operations.[17]: 9 

Registers[edit]
The SPARC architecture has an overlapping register window scheme. At any instant, 32 general-purpose registers are visible. A Current Window Pointer (CWP) variable in the hardware points to the current set. The total size of the register file is not part of the architecture, allowing more registers to be added as the technology improves, up to a maximum of 32 windows in SPARC V7 and V8 as CWP is 5 bits and is part of the PSR register.
In SPARC V7 and V8 CWP will usually be decremented by the SAVE instruction (used by the SAVE instruction during the procedure call to open a new stack frame and switch the register window), or incremented by the RESTORE instruction (switching back to the call before returning from the procedure). Trap events (interrupts, exceptions or TRAP instructions) and RETT instructions (returning from traps) also change the CWP. For SPARC V9, CWP register is decremented during a RESTORE instruction, and incremented during a SAVE instruction. This is the opposite of PSR.CWP's behavior in SPARC V8. This change has no effect on nonprivileged instructions.


Window Addressing


Register group
Mnemonic
Register address
Availability


global
G0...G7
R[00]...R[07]
always the same ones, G0 being zero always


out
O0...O7
R[08]...R[15]
to be handed over to, and returned from, the called subroutine, as its "in"


local
L0...L7
R[16]...R[23]
truly local to the current subroutine


in
I0...I7
R[24]...R[31]
handed over from the caller, and returned to the caller, as its "out"

SPARC registers are shown in the figure above.
There is also a non-windowed Y register, used by the multiply-step, integer multiply, and integer divide instructions.[17]: 32 
A SPARC V8 processor with an FPU includes 32 32-bit floating-point registers, each of which can hold one single-precision IEEE 754 floating-point number.  An even–odd pair of floating-point registers can hold one double-precision IEEE 754 floating-point number, and a quad-aligned group of four floating-point registers can hold one quad-precision IEEE 754 floating-point number.[17]: 10 
A SPARC V9 processor with an FPU includes:[10]: 36–40 

32 32-bit floating-point registers, each of which can hold one single-precision IEEE 754 floating-point number;
32 64-bit floating-point registers, each of which can hold one double-precision IEEE 754 floating-point number;
16 128-bit floating-point registers, each of which can hold one quad-precision IEEE 754 floating-point number.
The registers are organized as a set of 64 32-bit registers, with the first 32 being used as the 32-bit floating-point registers, even–odd pairs of all 64 registers being used as the 64-bit floating-point registers, and quad-aligned groups of four floating-point registers being used as the 128-bit floating-point registers.
Floating-point registers are not windowed; they are all global registers.[10]: 36–40 

Instruction formats[edit]
All SPARC instructions occupy a full 32-bit word and start on a word boundary. Four formats are used, distinguished by the first two bits. All arithmetic and logical instructions have 2 source operands and 1 destination operand.[18] RD is the "destination register", where the output of the operation is deposited. The majority of SPARC instructions have at least this register, so it is placed near the "front" of the instruction format. RS1 and RS2 are the "source registers", which may or may not be present, or replaced by a constant.


SPARC instruction formats


Type

Bit


31
30
29
28
27
26
25
24
23
22
21
20
19
18
17
16
15
14
13
12
11
10
9
8
7
6
5
4
3
2
1
0


SETHI format
00
RD
100
Immediate constant 22 bits


I Branch format
00
A
icc
010
Displacement constant 22 bits


F Branch format
00
A
fcc
110
Displacement constant 22 bits


C Branch format
00
A
ccc
111
Displacement constant 22 bits


CALL disp
01
PC-relative displacement


Arithmetic register
10
RD
opcode
RS1
0
0
RS2


Arithmetic immediate
10
RD
opcode
RS1
1
Immediate constant 13 bits


FPU operation
10
FD
110100/110101
FS1
opf
FS2


CP operation
10
RD
110110/110111
RS1
opc
RS2


JMPL register
10
RD
111000
RS1
0
0
RS2


JMPL immediate
10
RD
111000
RS1
1
Immediate constant 13 bits


LD/ST register
11
RD
opcode
RS1
0
0
RS2


LD/ST immediate
11
RD
opcode
RS1
1
Immediate constant 13 bits

Instructions[edit]
Loads and stores[edit]
Load and store instructions have a three-operand format, in that they have two operands representing values for the address and one operand for the register to read or write to. The address is created by adding the two address operands to produce an address. The second address operand may be a constant or a register. Loads take the value at the address and place it in the register specified by the third operand, whereas stores take the value in the register specified by the first operand and place it at the address. To make this more obvious, the assembler language indicates address operands using square brackets with a plus sign separating the operands, instead of using a comma-separated list. Examples:[18]

ld [%L1+%L2],%L3  !load the 32-bit value at address %L1+%L2 and put the value into %L3
ld [%L1+8],%L2    !load the value at %L1+8 into %L2
ld [%L1],%L2      !as above, but no offset, which is the same as +%G0
st %L1,[%I2]      !store the value in %L1 into the location stored in %I2
st %G0,[%I1+8]    !clear the memory at %I1+8

Due to the widespread use of non-32-bit data, such as 16-bit or 8-bit integral data or 8-bit bytes in strings, there are instructions that load and store 16-bit half-words and 8-bit bytes, as well as instructions that load 32-bit words. During a load, those instructions will read only the byte or half-word at the indicated location and then either fill the rest of the target register with zeros (unsigned load) or with the value of the uppermost bit of the byte or half-word (signed load). During a store, those instructions discard the upper bits in the register and store only the lower bits. There are also instructions for loading double-precision values used for floating-point arithmetic, reading or writing eight bytes from the indicated register and the "next" one, so if the destination of a load is L1, L1 and L2 will be set. The complete list of load and store instructions for the general-purpose registers in 32-bit SPARC is LD, ST, LDUB (unsigned byte), LDSB (signed byte), LDUH (unsigned half-word), LDSH (signed half-word), LDD (load double), STB (store byte), STH (store half-word), STD (store double).[18]
In SPARC V9, registers are 64-bit, and the LD instruction, renamed LDUW, clears the upper 32 bits in the register and loads the 32-bit value into the lower 32 bits, and the ST instruction, renamed STW, discards the upper 32 bits of the register and stores only the lower 32 bits.  The new LDSW instruction sets the upper bits in the register to the value of the uppermost bit of the word and loads the 32-bit value into the lower bits. The new LDX instruction loads a 64-bit value into the register, and the STX instruction stores all 64 bits of the register.
The LDF, LDDF, and LDQF instructions load a single-precision, double-precision, or quad-precision value from memory into a floating-point register; the STF, STDF, and STQF instructions store a single-precision, double-precision, or quad-precision floating-point register into memory.
The memory barrier instruction, MEMBAR, serves two interrelated purposes: it articulates order constraints among memory references and facilitates explicit control over the completion of memory references. For example, all effects of the stores that appear prior to the MEMBAR instruction must be made visible to all processors before any loads following the MEMBAR can be executed.[19]

ALU operations[edit]
Arithmetic and logical instructions also use a three-operand format, with the first two being the operands and the last being the location to store the result. The middle operand can be a register or a 13-bit signed integer constant; the other operands are registers. Any of the register operands may point to G0; pointing the result to G0 discards the results, which can be used for tests. Examples include:[18]

add %L1,%L2,%L3   !add the values in %L1 and %L2 and put the result in %L3
add %L1,1,%L1     !increment %L1
add %G0,%G0,%L4   !clear any value in %L4

The list of mathematical instructions is ADD, SUB, AND, OR, XOR, and negated versions ANDN, ORN, and XNOR. One quirk of the SPARC design is that most arithmetic instructions come in pairs, with one version setting the NZVC condition code bits in the status register, and the other not setting them, with the default being not to set the codes. This is so that the compiler has a way to move instructions around when trying to fill delay slots. If one wants the condition codes to be set, this is indicated by adding cc to the instruction:[18]

subcc %L1,10,%G0  !compare %L1 to 10 and ignore the result, but set the flags

add and sub also have another modifier, X, which indicates whether the operation should set the carry bit:

addx %L1,100,%L1  !add 100 to the value in %L1 and track carry

SPARC V7 does not have multiplication or division instructions, but it does have MULSCC, which does one step of a multiplication testing one bit and conditionally adding the multiplicand to the product. This was because MULSCC can complete over one clock cycle in keeping with the RISC philosophy.  SPARC V8 added UMUL (unsigned multiply), SMUL (signed multiply), UDIV (unsigned divide), and SDIV (signed divide) instructions, with both versions that do not update the condition codes and versions that do.  MULSCC and the multiply instructions use the Y register to hold the upper 32 bits of the product; the divide instructions use it to hold the upper 32 bits of the dividend.  The RDY instruction reads the value of the Y register into a general-purpose register; the WRY instruction writes the value of a general-purpose register to the Y register.[17]: 32   SPARC V9 added MULX, which multiplies two 64-bit values and produces a 64-bit result, SDIVX, which divides a 64-bit signed dividend by a 64-bit signed divisor and produces a 64-bit signed quotient, and UDIVX, which divides a 64-bit unsigned dividend by a 64-bit unsigned divisor and produces a 64-bit signed quotient; none of those instructions use the Y register.[10]: 199 

Branching[edit]
Conditional branches test condition codes in a status register, as seen in many instruction sets such the IBM System/360 architecture and successors and the x86 architecture. This means that a test and branch is normally performed with two instructions; the first is an ALU instruction that sets the condition codes, followed by a branch instruction that examines one of those flags. The SPARC does not have specialized test instructions; tests are performed using normal ALU instructions with the destination set to %G0. For instance, to test if a register holds the value 10 and then branch to code that handles it, one would:

subcc %L1,10,%G0 !subtract 10 from %L1, setting the zero flag if %L1 is 10
be WASEQUAL      !if the zero flag is set, branch to the address marked WASEQUAL

In a conditional branch instruction, the icc or fcc field specifies the condition being tested. The 22-bit displacement field is the address, relative to the current PC, of the target, in words, so that conditional branches can go forward or backward up to 8 megabytes. The ANNUL (A) bit is used to get rid of some delay slots. If it is 0 in a conditional branch, the delay slot is executed as usual. If it is 1, the delay slot is only executed if the branch is taken. If it is not taken, the instruction following the conditional branch is skipped.
There are a wide variety of conditional branches: BA (branch always, essentially a jmp), BN (branch never), BE (equals), BNE (not equals), BL (less than), BLE (less or equal), BLEU (less or equal, unsigned), BG (greater), BGE (greater or equal), BGU (greater unsigned), BPOS (positive), BNEG (negative), BCC (carry clear), BCS (carry set), BVC (overflow clear), BVS (overflow set).[17]: 119–120 
The FPU and CP have sets of condition codes separate from the integer condition codes and from each other; two additional sets of branch instructions were defined to test those condition codes. Adding an F to the front of the branch instruction in the list above performs the test against the FPU's condition codes,[17]: 121–122  while, in SPARC V8, adding a C tests the flags in the otherwise undefined CP.[17]: 123–124 
The CALL (jump to subroutine) instruction uses a 30-bit program counter-relative word offset. As the target address is specifying the start of a word, not a byte, 30-bits is all that is needed to reach any address in the 4 gigabyte address space.[18] The CALL instruction deposits the return address in register R15, also known as output register O7.
The JMPL (jump and link) instruction is a three-operand instruction, with two operands representing values for the target address and one operand for a register in which to deposit the return address. The address is created by adding the two address operands to produce a 32-bit address. The second address operand may be a constant or a register.

Large constants[edit]
As the instruction opcode takes up some bits of the 32-bit instruction word, there is no way to load a 32-bit constant using a single instruction. This is significant because addresses are manipulated through registers and they are 32-bits. To ease this, the special-purpose SETHI instruction copies its 22-bit immediate operand into the high-order 22 bits of any specified register, and sets each of the low-order 10 bits to 0. In general use, SETHI is followed by an or instruction with only the lower 10 bits of the value set. To ease this, the assembler includes the %hi(X) and %lo(X) macros. For example:[18]

sethi %hi(0x89ABCDEF),%L1       !sets the upper 22 bits of L1
or    %L1,%lo(0x89ABCDEF),%L1   !sets the lower 10 bits of L1 by ORing

The hi and lo macros are performed at assembly time, not runtime, so it has no performance hit yet makes it clearer that L1 is set to a single value, not two unrelated ones. To make this even easier, the assembler also includes a "synthetic instruction", set, that performs these two operations in a single line:

set   0x89ABCDEF,% L1

This outputs the two instructions above if the value is larger than 13 bits, otherwise it will emit a single ld with the value.[18]

Synthetic instructions[edit]
As noted earlier, the SPARC assembler uses "synthetic instructions" to ease common coding tasks. Additional examples include (among others):[18]


SPARC synthetic instructions


mnemonic

actual output

purpose


nop
sethi 0,%g0
do nothing


clr %reg
or %g0,%g0,%reg
set a register to zero


clr [address]
st %g0,[address]
set a memory address to zero


clrh [address]
sth %g0,[address]
set the half-word at memory address to zero


clrb [address]
stb %g0,[address]
set the byte at memory address to zero


cmp %reg1,%reg2
subcc %reg1,%reg2,%g0
compare two registers, set codes, discard results


cmp %reg,const
subcc %reg,const,%g0
compare register with constant


mov %reg1,%reg2
or %g0,%reg1,%reg2
copy value from one register to another


mov const,%reg
or %g0,const,%reg
copy constant value into a register


inc %reg
add %reg,1,%reg
increment a register


inccc %reg
addcc %reg,1,%reg
increment a register, set conditions


dec %reg
sub %reg,1,%reg
decrement a register


deccc %reg
subcc %reg,1,%reg
decrement a register, set conditions


not %reg
xnor %reg,%g0,%reg
flip the bits in a register


neg %reg
sub %g0,%reg,%reg
two's complement a register


tst %reg
orcc %reg,%g0,%g0
test whether the value in a register is > 0, 0, or < 0

SPARC architecture licensees[edit]
Intel was the 80386's only producer, which made it very expensive and caused the industry to be wary of sole sourced CPUs. When Sun announced SPARC in 1987, the company stated that it would be available from multiple sources. Fujitsu was the first SPARC vendor, and Cypress Semiconductor was the second licensee; as of February 1989[update] their SPARC CPUs were available, as was Texas Instruments's FPU.[20] The following organizations have licensed the SPARC architecture:


Afara Websystems
Bipolar Integrated Technology (BIT)[20]
Cypress Semiconductor[20]
European Space Research and Technology Center (ESTEC)
Fujitsu[20] (and its Fujitsu Microelectronics subsidiary)
Gaisler Research
HAL Computer Systems
Hyundai
LSI Logic[20]
Matra Harris Semiconductors (MHS)
Matsushita Electrical Industrial Co.
Meiko Scientific
Metaflow Technologies
Philips Electronics
Prisma
Ross Technology
Solbourne Computer
Systems & Processes Engineering Corporation (SPEC)
TEMIC
Texas Instruments[20]
Weitek

Implementations[edit]





Name (codename)

Model

Frequency (MHz)

Arch. version

Year

Total threads[note 1]

Process (nm)

Transistors (millions)

Die size (mm2)

IO pins

Power (W)

Voltage (V)

L1 Dcache (KB)

L1 Icache (KB)

L2 cache (KB)

L3 cache (KB)


SPARC MB86900

Fujitsu[1][3][2]

14.28–33
V7
1986
1×1=1
1300
0.11
—
256
—
—
0–128 (unified)
none
none


SPARC

Various[note 2]

14.28–40
V7
1989–1992
1×1=1
800–1300
~0.1–1.8
—
160–256
—
—
0–128 (unified)
none
none


MN10501 (KAP)

Solbourne Computer,
Matsushita[21]


33–36

V8

1990–1991

1x1=1

—

1.0[22]

—

—

—

—

8

8

0–256

none


microSPARC I (Tsunami)

TI TMS390S10

40–50
V8
1992
1×1=1
800
0.8
225?
288
2.5
5
2
4
none
none


SuperSPARC I (Viking)

TI TMX390Z50 / Sun STP1020

33–60
V8
1992
1×1=1
800
3.1
—
293
14.3
5
16
20
0–2048
none


SPARClite

Fujitsu MB8683x

66–108
V8E
1992
1×1=1
—
—
—
144, 176
—
2.5/3.3–5.0 V, 2.5–3.3 V
1, 2, 8, 16
1, 2, 8, 16
none
none


hyperSPARC (Colorado 1)

Ross RT620A

40–90
V8
1993
1×1=1
500
1.5
—
—
—
5?
0
8
128–256
none


microSPARC II (Swift)

Fujitsu MB86904 / Sun STP1012

60–125
V8
1994
1×1=1
500
2.3
233
321
5
3.3
8
16
none
none


hyperSPARC (Colorado 2)

Ross RT620B

90–125
V8
1994
1×1=1
400
1.5
—
—
—
3.3
0
8
128–256
none


SuperSPARC II (Voyager)

Sun STP1021

75–90
V8
1994
1×1=1
800
3.1
299
—
16
—
16
20
1024–2048
none


hyperSPARC (Colorado 3)

Ross RT620C

125–166
V8
1995
1×1=1
350
1.5
—
—
—
3.3
0
8
512–1024
none


TurboSPARC

Fujitsu MB86907

160–180
V8
1996
1×1=1
350
3.0
132
416
7
3.5
16
16
512
none


UltraSPARC (Spitfire)

Sun STP1030

143–167
V9
1995
1×1=1
470
3.8
315
521
30[note 3]
3.3
16
16
512–1024
none


UltraSPARC (Hornet)

Sun STP1030

200
V9
1995
1×1=1
420
5.2
265
521
—
3.3
16
16
512–1024
none


hyperSPARC (Colorado 4)

Ross RT620D

180–200
V8
1996
1×1=1
350
1.7
—
—
—
3.3
16
16
512
none


SPARC64

Fujitsu (HAL)

101–118
V9
1995
1×1=1
400
—
Multichip
286
50
3.8
128
128
—
—


SPARC64 II

Fujitsu (HAL)

141–161
V9
1996
1×1=1
350
—
Multichip
286
64
3.3
128
128
—
—


SPARC64 III

Fujitsu (HAL) MBCS70301

250–330
V9
1998
1×1=1
240
17.6
240
—
—
2.5
64
64
8192
—


UltraSPARC IIs (Blackbird)

Sun STP1031

250–400
V9
1997
1×1=1
350
5.4
149
521
25[note 4]
2.5
16
16
1024 or 4096
none


UltraSPARC IIs (Sapphire-Black)

Sun STP1032 / STP1034

360–480
V9
1999
1×1=1
250
5.4
126
521
21[note 5]
1.9
16
16
1024–8192
none


UltraSPARC IIi (Sabre)

Sun SME1040

270–360
V9
1997
1×1=1
350
5.4
156
587
21
1.9
16
16
256–2048
none


UltraSPARC IIi (Sapphire-Red)

Sun SME1430

333–480
V9
1998
1×1=1
250
5.4
—
587
21[note 6]
1.9
16
16
2048
none


UltraSPARC IIe (Hummingbird)

Sun SME1701

400–500
V9
1999
1×1=1
180 Al
—
—
370
13[note 7]
1.5–1.7
16
16
256
none


UltraSPARC IIi (IIe+) (Phantom)

Sun SME1532

550–650
V9
2000
1×1=1
180 Cu
—
—
370
17.6
1.7
16
16
512
none


SPARC64 GP

Fujitsu SFCB81147

400–563
V9
2000
1×1=1
180
30.2
217
—
—
1.8
128
128
8192
—


SPARC64 GP

--

600–810
V9
—
1×1=1
150
30.2
—
—
—
1.5
128
128
8192
—


SPARC64 IV

Fujitsu MBCS80523

450–810
V9
2000
1×1=1
130
—
—
—
—
—
128
128
2048
—


UltraSPARC III (Cheetah)

Sun SME1050

600
JPS1
2001
1×1=1
180 Al
29
330
1368
53
1.6
64
32
8192
none


UltraSPARC III (Cheetah)

Sun SME1052

750–900
JPS1
2001
1×1=1
130 Al
29
—
1368
—
1.6
64
32
8192
none


UltraSPARC III Cu (Cheetah+)

Sun SME1056

900–1200
JPS1
2001
1×1=1
130 Cu
29
232
1368
50[note 8]
1.6
64
32
8192
none


UltraSPARC IIIi (Jalapeño)

Sun SME1603

1064–1593
JPS1
2003
1×1=1
130
87.5
206
959
52
1.3
64
32
1024
none


SPARC64 V (Zeus)

Fujitsu

1100–1350
JPS1
2003
1×1=1
130
190
289
269
40
1.2
128
128
2048
—


SPARC64 V+ (Olympus-B)

Fujitsu

1650–2160
JPS1
2004
1×1=1
90
400
297
279
65
1
128
128
4096
—


UltraSPARC IV (Jaguar)

Sun SME1167

1050–1350
JPS2
2004
1×2=2
130
66
356
1368
108
1.35
64
32
16384
none


UltraSPARC IV+ (Panther)

Sun SME1167A

1500–2100
JPS2
2005
1×2=2
90
295
336
1368
90
1.1
64
64
2048
32768


UltraSPARC T1 (Niagara)

Sun SME1905

1000–1400
UA2005
2005
4×8=32
90
300
340
1933
72
1.3
8
16
3072
none


SPARC64 VI (Olympus-C)

Fujitsu

2150–2400
JPS2
2007
2×2=4
90
540
422
—
120–150
1.1
128×2
128×2
4096–6144
none


UltraSPARC T2 (Niagara 2)

Sun SME1908A

1000–1600
UA2007
2007
8×8=64
65
503
342
1831
95
1.1–1.5
8
16
4096
none


UltraSPARC T2 Plus (Victoria Falls)

Sun SME1910A

1200–1600
UA2007
2008
8×8=64
65
503
342
1831
—
—
8
16
4096
none


SPARC64 VII (Jupiter)[23]

Fujitsu

2400–2880
JPS2
2008
2×4=8
65
600
445
—
150
—
64×4
64×4
6144
none


UltraSPARC "RK" (Rock)[24]

Sun SME1832

2300
????
canceled[25]
2×16=32
65
?
396
2326
?
?
32
32
2048
?


SPARC64 VIIIfx (Venus)[26][27]

Fujitsu

2000
JPS2 / HPC-ACE
2009
1×8=8
45
760
513
1271
58
?
32×8
32×8
6144
none


LEON2FT

Atmel AT697F

100
V8
2009
1×1=1
180
—
—
196
1
1.8/3.3
16
32
—
—|none


SPARC T3 (Rainbow Falls)

Oracle/Sun

1650
UA2007
2010
8×16=128
40[28]
????
371
?
139
?
8
16
6144
none


Galaxy FT-1500

NUDT (China)

1800
UA2007?
201?
8×16=128
40
????
???
?
65
?
16×16
16×16
512×16
4096


SPARC64 VII+ (Jupiter-E or M3)[29][30]

Fujitsu

2667–3000
JPS2
2010
2×4=8
65
—
—
—
160
—
64×4
64×4
12288
none


LEON3FT

Cobham Gaisler GR712RC

100
V8E
2011
1×2=2
180
—
—
—
1.5[note 9]
1.8/3.3
4x4Kb
4x4Kb
none
none


R1000

MCST (Russia)

1000
JPS2
2011
1×4=4
90
180
128
—
15
1, 1.8, 2.5
32
16
2048
none


SPARC T4 (Yosemite Falls)[31]

Oracle

2850–3000
OSA2011
2011
8×8=64
40
855
403
?
240
?
16×8
16×8
128×8
4096


SPARC64 IXfx[32][33][34]

Fujitsu

1850
JPS2 / HPC-ACE
2012
1x16=16
40
1870
484
1442
110
?
32×16
32×16
12288
none


SPARC64 X (Athena)[35]

Fujitsu

2800
OSA2011 / HPC-ACE
2012
2×16=32
28
2950
587.5
1500
270
?
64×16
64×16
24576
none


SPARC T5

Oracle

3600
OSA2011
2013
8×16=128
28
1500
478
?
?
?
16×16
16×16
128×16
8192


SPARC M5[36]

Oracle

3600
OSA2011
2013
8×6=48
28
3900
511
?
?
?
16×6
16×6
128×6
49152


SPARC M6[37]

Oracle

3600
OSA2011
2013
8×12=96
28
4270
643
?
?
?
16×12
16×12
128×12
49152


SPARC64 X+ (Athena+)[38]

Fujitsu

3200–3700
OSA2011 / HPC-ACE
2014
2×16=32
28
2990
600
1500
392
?
64×16
64×16
24M
none


SPARC64 XIfx[39]

Fujitsu

2200
JPS2 / HPC-ACE2
2014
1×(32+2)=34
20
3750
?
1001
?
?
64×34
64×34
12M×2
none


SPARC M7[40][41]

Oracle

4133
OSA2015
2015
8×32=256
20
>10,000
?
?
?
?
16×32
16×32
256×24
65536


SPARC S7[42][43]

Oracle

4270
OSA2015
2016
8×8=64
20
????
?
?
?
?
16×8
16×8
256×2+256×4
16384


SPARC64 XII[44]

Fujitsu

4250
OSA201? / HPC-ACE
2017
8×12=96
20
5500
795
1860
?
?
64×12
64×12
512×12
32768


SPARC M8[45][46]

Oracle

5000
OSA2017
2017
8×32=256
20
?
?
?
?
?
32×32
16×32
128×32+256×8
65536


LEON4

Cobham Gaisler GR740

250[note 10]
V8E
2017
1×4=4
32
—
—
—
—
1.2/2.5/3.3
4x4
4x4
2048
none


R2000

MCST (Russia)

2000
?
2018
1×8=8
28
500
?
—
?
?
?
?
?
none


LEON5

Cobham Gaisler

—
V8E
2019
?
?
—
—
—
—
—
?
?
16–8192
none


Name (codename)

Model

Frequency (MHz)

Arch. version

Year

Total threads[note 1]

Process (nm)

Transistors (millions)

Die size (mm2)

IO pins

Power (W)

Voltage (V)

L1 Dcache (KB)

L1 Icache (KB)

L2 cache (KB)

L3 cache (KB)

Notes:



^ a b Threads per core × number of cores

^ Various SPARC V7 implementations were produced by Fujitsu, LSI Logic, Weitek, Texas Instruments, Cypress and Temic. A SPARC V7 processor generally consisted of several discrete chips, usually comprising an integer unit (IU), a floating-point unit (FPU), a memory management unit (MMU) and cache memory. Conversely, the Atmel (now Microchip Technology) TSC695 is a single-chip SPARC V7 implementation.

^ @167 MHz

^ @250 MHz

^ @400 MHz

^ @440 MHz

^ max. @500 MHz

^ @1200 MHz

^ excluding I/O buses

^ nominal; specification from 100 to 424 MHz depending on attached RAM capabilities


Operating system support[edit]
SPARC machines have generally used Sun's SunOS, Solaris, JavaOS, or OpenSolaris including derivatives illumos and OpenIndiana, but other operating systems have also been used, such as NeXTSTEP, RTEMS, FreeBSD, OpenBSD, NetBSD, and Linux.
In 1993, Intergraph announced a port of Windows NT to the SPARC architecture,[47] but it was later cancelled.
In October 2015, Oracle announced a "Linux for SPARC reference platform".[48]

Open source implementations[edit]
Several fully open source implementations of the SPARC architecture exist:

LEON, a 32-bit radiation-tolerant, SPARC V8 implementation, designed especially for space use. Source code is written in VHDL, and licensed under the GPL.
OpenSPARC T1, released in 2006, a 64-bit, 32-thread implementation conforming to the UltraSPARC Architecture 2005 and to SPARC Version 9 (Level 1). Source code is written in Verilog, and licensed under many licenses.  Most OpenSPARC T1 source code is licensed under the GPL.  Source based on existent open source projects will continue to be licensed under their current licenses.  Binary programs are licensed under a binary software license agreement.
S1, a 64-bit Wishbone compliant CPU core based on the OpenSPARC T1 design. It is a single UltraSPARC V9 core capable of 4-way SMT. Like the T1, the source code is licensed under the GPL.
OpenSPARC T2, released in 2008, a 64-bit, 64-thread implementation conforming to the UltraSPARC Architecture 2007 and to SPARC Version 9 (Level 1). Source code is written in Verilog, and licensed under many licenses.  Most OpenSPARC T2 source code is licensed under the GPL. Source based on existing open source projects will continue to be licensed under their current licenses.  Binary programs are licensed under a binary Software License Agreement.
A fully open source simulator for the SPARC architecture also exists:

RAMP Gold, a 32-bit, 64-thread SPARC Version 8 implementation, designed for FPGA-based architecture simulation. RAMP Gold is written in ~36,000 lines of SystemVerilog, and licensed under the BSD licenses.
Supercomputers[edit]
For HPC loads Fujitsu builds specialized SPARC64 fx processors  with a new instruction extensions set, called HPC-ACE (High Performance Computing – Arithmetic Computational Extensions).
Fujitsu's K computer ranked No. 1 in the TOP500 June 2011 and November 2011 lists. It combines 88,128 SPARC64 VIIIfx CPUs, each with eight cores, for a total of 705,024 cores—almost twice as many as any other system in the TOP500 at that time. The K Computer was more powerful than the next five systems on the list combined, and had the highest performance-to-power ratio of any supercomputer system.[49] It also ranked No. 6 in the Green500 June 2011 list, with a score of 824.56 MFLOPS/W.[50]  In the November 2012 release of TOP500, the K computer ranked No. 3, using by far the most power of the top three.[51]  It ranked No. 85 on the corresponding Green500 release.[52] Newer HPC processors, IXfx and XIfx, were included in recent PRIMEHPC FX10 and FX100 supercomputers.
Tianhe-2 (TOP500 No. 1 as of November 2014[53]) has a number of nodes with Galaxy FT-1500 OpenSPARC-based processors developed in China. However, those processors did not contribute to the LINPACK score.[54][55]

See also[edit]
ERC32 — based on SPARC V7 specification
Ross Technology, Inc. — a SPARC microprocessor developer during the 1980s and 1990s
Sparcle — a modified SPARC with multiprocessing support used by the MIT Alewife project
LEON — a space rated SPARC V8 processor.
R1000 — a Russian quad-core microprocessor based on SPARC V9 specification
Galaxy FT-1500 — a Chinese 16-core OpenSPARC-based processor
References[edit]


^ a b c "Fujitsu to take ARM into the realm of Super". The CPU Shack Museum. June 21, 2016. Archived from the original on June 30, 2019. Retrieved June 30, 2019.

^ a b c d "Timeline". SPARC International. Archived from the original on April 24, 2019. Retrieved June 30, 2019.

^ a b "Fujitsu SPARC". cpu-collection.de. Archived from the original on August 6, 2016. Retrieved June 30, 2019.

^ Vaughan-Nichols, Steven J. (September 5, 2017). "Sun set: Oracle closes down last Sun product lines". ZDNet. Archived from the original on September 10, 2017. Retrieved September 11, 2017.

^ Nichols, Shaun (August 31, 2017). "Oracle finally decides to stop prolonging the inevitable, begins hardware layoffs". The Register. Archived from the original on September 12, 2017. Retrieved September 11, 2017.

^ "Roadmap: Fujitsu Global". www.fujitsu.com. Retrieved February 15, 2022.

^ a b "Oracle SPARC Architecture 2015: One Architecture ... Multiple Innovative Implementations" (PDF). Draft D1.0.0. January 12, 2016. Archived (PDF) from the original on April 24, 2016. Retrieved June 13, 2016. IMPL. DEP. #2-V8: An Oracle SPARC Architecture implementation may contain from 72 to 640 general-purpose 64-bit R registers. This corresponds to a grouping of the registers into MAXPGL + 1 sets of global R registers plus a circular stack of N_REG_WINDOWS sets of 16 registers each, known as register windows. The number of register windows present (N_REG_WINDOWS) is implementation dependent, within the range of 3 to 32 (inclusive).

^ "SPARC Options", Using the GNU Compiler Collection (GCC), GNU, archived from the original on January 9, 2013, retrieved January 8, 2013

^ SPARC Optimizations With GCC, OSNews, February 23, 2004, archived from the original on May 23, 2013, retrieved January 8, 2013

^ a b c d e f Weaver, D. L.; Germond, T., eds. (1994). The SPARC Architecture Manual, Version 9. SPARC International, Inc.: Prentice Hall. ISBN 0-13-825001-4. Retrieved May 27, 2023.

^ "SPARC Behavior and Implementation". Numerical Computation Guide – Sun Studio 10. Sun Microsystems, Inc. 2004. Archived from the original on January 25, 2022. Retrieved September 24, 2011. There are four situations, however, when the hardware will not successfully complete a floating-point instruction: ... The instruction is not implemented by the hardware (such as ... quad-precision instructions on any SPARC FPU).

^ "Sun Accelerates Growth of UltraSPARC CMT Eco System". Sun Microsystems. Archived from the original on January 26, 2008.

^ "OpenSPARC Frequently Asked Questions". Oracle. Archived from the original on October 17, 2012. Retrieved March 20, 2021.

^ "Oracle SPARC Architecture 2011" (PDF), Oracle Corporation, May 21, 2014, archived (PDF) from the original on September 24, 2015, retrieved November 25, 2015

^ Soat, John. "SPARC M7 Innovation". Oracle web site. Oracle Corporation. Archived from the original on September 5, 2015. Retrieved October 13, 2015.

^ "Software in Silicon Cloud - Oracle". www.oracle.com. Archived from the original on January 21, 2019. Retrieved January 21, 2019.

^ a b c d e f g h i The SPARC Architecture Manual, Version 8. SPARC International, Inc. 1992. Retrieved May 27, 2023.

^ a b c d e f g h i "SPARC Fundamental Instructions".

^ "SPARC64 IXfx Extensions Fujitsu Limited Ver 12, 2 Dec. 2013" (PDF). pp. 103–104. Retrieved December 17, 2023.

^ a b c d e f Marshall, Trevor; Tazelaar, Jane Morrill (February 1989). "Worth the RISC". BYTE. McGraw-Hill. pp. 245–249. Retrieved October 8, 2024.

^ "Floodgap Retrobits presents the Solbourne Solace: a shrine to the forgotten SPARC". www.floodgap.com. Archived from the original on December 1, 2020. Retrieved January 14, 2020.

^ Sager, D.; Hinton, G.; Upton, M.; Chappell, T.; Fletcher, T.D.; Samaan, S.; Murray, R. (2001). "A 0.18 μm CMOS IA32 microprocessor with a 4 GHZ integer execution unit". 2001 IEEE International Solid-State Circuits Conference. Digest of Technical Papers. ISSCC (Cat. No.01CH37177). San Francisco, CA, USA: IEEE. pp. 324–325. doi:10.1109/ISSCC.2001.912658. ISBN 978-0-7803-6608-4.

^ FX1 Key Features & Specifications (PDF), Fujitsu, February 19, 2008, archived (PDF) from the original on January 18, 2012, retrieved December 6, 2011

^ Tremblay, Marc; Chaudhry, Shailender (February 19, 2008), "A Third-Generation 65nm 16-Core 32-Thread Plus 32-Scout-Thread CMT SPARC(R) Processor" (PDF), OpenSPARC, Sun Microsystems, archived from the original on January 16, 2013, retrieved December 6, 2011

^ Vance, Ashlee (June 15, 2009), "Sun Is Said to Cancel Big Chip Project", The New York Times, archived from the original on November 4, 2011, retrieved May 23, 2010

^ "Fujitsu shows off SPARC64 VII", heise online, August 28, 2008, archived from the original on May 23, 2013, retrieved December 6, 2011

^ Barak, Sylvie (May 14, 2009), "Fujitsu unveils world's fastest CPU", The Inquirer, archived from the original on May 17, 2009, retrieved December 6, 2011

^ "Sparc T3 processor" (PDF), Oracle Corporation, archived (PDF) from the original on April 24, 2016, retrieved December 6, 2011

^ Morgan, Timothy Prickett (December 3, 2010), "Ellison: Sparc T4 due next year", The Register, archived from the original on March 7, 2012, retrieved December 6, 2011

^ "SPARC Enterprise M-series Servers Architecture" (PDF), Fujitsu, April 2011, archived (PDF) from the original on March 4, 2016, retrieved November 5, 2011

^ Morgan, Timothy Prickett (August 22, 2011), "Oracle's Sparc T4 chip", The Register, archived from the original on November 30, 2011, retrieved December 6, 2011

^ Morgan, Timothy Prickett (November 21, 2011), "Fujitsu parades 16-core Sparc64 super stunner", The Register, archived from the original on November 24, 2011, retrieved December 8, 2011

^ "Fujitsu Launches PRIMEHPC FX10 Supercomputer", Fujitsu, November 7, 2011, archived from the original on January 18, 2012, retrieved February 3, 2012

^ "Ixfx Download" (PDF). fujitsu.com. Archived (PDF) from the original on May 18, 2015. Retrieved May 17, 2015.

^ "Images of SPARC64" (PDF). fujitsu.com. Archived (PDF) from the original on April 22, 2016. Retrieved August 29, 2017.

^ "Oracle Products" (PDF). oracle.com. Archived (PDF) from the original on March 8, 2017. Retrieved August 29, 2017.

^ "Oracle SPARC products" (PDF). oracle.com. Archived (PDF) from the original on September 26, 2018. Retrieved August 29, 2017.

^ "Fujitsu Presentation pdf" (PDF). fujitsu.com. Archived (PDF) from the original on April 22, 2016. Retrieved August 29, 2017.

^ "Fujitsu Global Images" (PDF). fujitsu.com. Archived from the original (PDF) on May 18, 2015. Retrieved August 29, 2017.

^ "M7: Next Generation SPARC. Hotchips 26" (PDF). swisdev.oracle.com. Archived (PDF) from the original on October 31, 2014. Retrieved August 12, 2014.

^ "Oracle's SPARC T7 and SPARC M7 Server Architecture" (PDF). oracle.com. Archived (PDF) from the original on November 6, 2015. Retrieved October 10, 2015.

^ Vinaik, Basant; Puri, Rahoul (August 24, 2015). "Hot Chips – August 23–25, 2015 – Conf. Day1 – Oracle's Sonoma Processor: Advanced low-cost SPARC processor for enterprise workloads" (PDF). hotchips.org. Archived (PDF) from the original on October 9, 2022. Retrieved January 25, 2022.

^ "Blueprints revealed: Oracle crams Sparc M7 and InfiniBand into cheaper 'Sonoma' chips". theregister.co.uk. Archived from the original on August 29, 2017. Retrieved August 29, 2017.

^ "Documents at Fujitsu" (PDF). fujitsu.com. Archived (PDF) from the original on August 29, 2017. Retrieved August 29, 2017.

^ "Oracle's New SPARC Systems Deliver 2-7x Better Performance, Security Capabilities, and Efficiency than Intel-based Systems". oracle.com. Archived from the original on September 18, 2017. Retrieved September 18, 2017.

^ "SPARC M8 Processor" (PDF). oracle.com. Archived (PDF) from the original on February 28, 2019. Retrieved September 18, 2017.

^ McLaughlin, John (July 7, 1993), "Intergraph to Port Windows NT to SPARC", The Florida SunFlash, 55 (11), archived from the original on July 23, 2014, retrieved December 6, 2011

^ Project: Linux for SPARC - oss.oracle.com, October 12, 2015, archived from the original on December 8, 2015, retrieved December 4, 2015

^ "TOP500 List (1-100)", TOP500, June 2011, archived from the original on June 23, 2011, retrieved December 6, 2011

^ "The Green500 List", Green500, June 2011, archived from the original on July 3, 2011

^ "Top500 List – November 2012 | TOP500 Supercomputer Sites", TOP500, November 2012, archived from the original on November 13, 2012, retrieved January 8, 2013

^ "The Green500 List – November 2012 | The Green500", Green500, November 2012, archived from the original on June 6, 2016, retrieved January 8, 2013

^ "Tianhe-2 (MilkyWay-2)", TOP500, May 2015, archived from the original on May 26, 2015, retrieved May 27, 2015

^ Keane, Andy, "Tesla Supercomputing" (mp4), Nvidia, archived from the original on February 25, 2021, retrieved December 6, 2011

^ Thibodeau, Patrick (November 4, 2010). "U.S. says China building 'entirely indigenous' supercomputer". Computerworld. Archived from the original on October 11, 2012. Retrieved August 28, 2017.


External links[edit]



Wikimedia Commons has media related to SPARC microprocessors.

SPARC International, Inc.
Oracle SPARC Processor Documentation at the Wayback Machine (archived October 13, 2019)
SPARC Technical Documents
OpenSPARC Architecture specification
Hypervisor/Sun4v Reference Materials
Fujitsu SPARC64 V, VI, VII, VIIIfx, IXfx Extensions at the Wayback Machine (archived April 3, 2019), and X / X+ Specification
Sun – UltraSPARC Processors Documentation at the Wayback Machine (archived January 14, 2010)
Sun – FOSS Open Hardware Documentation at the Wayback Machine (archived December 9, 2011)
OpenSPARC at the Wayback Machine (archived February 27, 2011)
Oracle SPARC and Solaris Public Roadmap at the Wayback Machine (archived May 25, 2018)
Fujitsu SPARC Roadmap
SPARC processor images and descriptions
The Rough Guide to MBus Modules (SuperSPARC, hyperSPARC)
SPARC Version 9, lecture by David Ditzel on YouTube
A quite an extensive list of operating systems supporting SPARC64 processors
vteReduced instruction set computer (RISC) architecturesOrigins
IBM 801
Berkeley RISC
Stanford MIPS
In active development
Analog Devices Blackfin
ARC
ARM
AVR
eSi-RISC
LatticeMico8, LatticeMico32
MIPS
OpenRISC
Power ISA
Renesas M32R, SuperH, V850
RISC-V
SPARC
Sunway
Unicore
Xilinx MicroBlaze, PicoBlaze
Development discontinued
Alpha
AMD Am29000
Apollo PRISM
Atmel AVR32
Clipper
CR16
CRISP
DEC PRISM
Intel i860, i960
META
MIPS-X
Motorola 88000, M·CORE
PA-RISC
POWER, PowerPC (active use in space exploration as RAD750), ROMP

vteSun MicrosystemsAcquired by OracleHardwareSystems
Sun-1
Sun-2
Sun-3
Sun386i
Sun-4
SPARCstation/server/center
1
2
4
5
10
20
IPC
IPX
LX
ZX
SPARCclassic
Netra
Ultra
1
2
5
10
24
30
60
80
Enterprise
10000
Blade server
Blade workstation
Fire
12K
15K
E25K
T2000
X4500
SPARC Enterprise
JavaStation
Java Workstation
Ray
Cobalt Qube
Cobalt RaQ
Processors
SPARC
MB86900
microSPARC
SuperSPARC
UltraSPARC
UltraSPARC II
UltraSPARC IIe
UltraSPARC IIi
Gemini
UltraSPARC III
UltraSPARC III Cu
UltraSPARC IIIi
UltraSPARC IV
UltraSPARC T1
UltraSPARC T2
SPARC T3
SPARC T4
SPARC T5
Rock
MAJC
Other
Sun4d
SBus
Fireplane
LOM port
MBus
Modular Datacenter
Neptune
System Service Processor
SPARC T series
SPOT
Ultra Port Architecture
Visual Instruction Set
Software
SunOS
Solaris
NIS
NIS+
NFS
ZFS
ZFS+
SunView
NeWS
OpenWindows
Java Desktop System
Studio
Java
StarOffice
iPlanet
Java System
Sun Secure Global Desktop
MySQL
xVM
GlassFish
VirtualBox
Storage
StorageTek 5800 System
StorageTek SL8500
Open Storage
QFS
ZFS
Performance
Cloud
Constellation System
Visualization System
Grid Engine
Lustre
Research
Sun Microsystems Laboratories
picoJava
Fortress
Project Looking Glass
Education
BlueJ
Global Education & Learning Community
SCPs
Community
Common Development and Distribution License
Java Community Process
NetBeans
OpenOffice.org
OpenSolaris
OpenSPARC
OpenJDK
Open Source University Meetup
People
Bill Joy
Andy Bechtolsheim
Scott McNealy
Vinod Khosla
Acquisitions
Afara Websystems
Cobalt Networks
Gridware
Lighthouse Design
Montalvo Systems
MySQL AB
Pixo
Procom Technology
SavaJe
StorageTek
Tarantella
Slogans
The Network is the Computer
Write once, run anywhere
Category
vteOracle CorporationCorporate directors
Jeffrey Berg
H. Raymond Bingham
Michael Boskin
Safra Catz
Larry Ellison
Héctor García-Molina
Joseph Grundfest
Jeffrey O. Henley
Mark Hurd
Jack F. Kemp
Donald L. Lucas
Naomi O. Seligman
Acquisitions (list)
Sun
PeopleSoft
Hyperion
Siebel
BEA
JD Edwards
RightNow
Virtual Iron
TimesTen
Sunopsis
NetSuite
Cerner
Databases
Oracle Database
MySQL
InnoDB
Berkeley DB
TimesTen
Rdb
Essbase
Programming languages
Java
PL/SQL
IDEs
JDeveloper
Forms
NetBeans
Apex
SQL Developer
Developer Studio
Middleware
Fusion Middleware
WebCenter
SOA Suite
WebLogic Server
Coherence
Tuxedo
GlassFish
Operating systems
Oracle Linux
Oracle Solaris
Computer hardware
Sun Fire
SPARC (T-Series, Enterprise)
StorageTek
Computer appliances
Oracle Exadata
Oracle Exalogic
Big Data Appliance
Education and recognition
Oracle Certification Program

 Category

vteProcessor technologiesModels
Abstract machine
Stored-program computer
Finite-state machine
with datapath
Hierarchical
Deterministic finite automaton
Queue automaton
Cellular automaton
Quantum cellular automaton
Turing machine
Alternating Turing machine
Universal
Post–Turing
Quantum
Nondeterministic Turing machine
Probabilistic Turing machine
Hypercomputation
Zeno machine
Belt machine
Stack machine
Register machines
Counter
Pointer
Random-access
Random-access stored program
Architecture
Microarchitecture
Von Neumann
Harvard
modified
Dataflow
Transport-triggered
Cellular
Endianness
Memory access
NUMA
HUMA
Load–store
Register/memory
Cache hierarchy
Memory hierarchy
Virtual memory
Secondary storage
Heterogeneous
Fabric
Multiprocessing
Cognitive
Neuromorphic
Instruction setarchitecturesTypes
Orthogonal instruction set
CISC
RISC
Application-specific
EDGE
TRIPS
VLIW
EPIC
MISC
OISC
NISC
ZISC
VISC architecture
Quantum computing
Comparison
Addressing modes
Instructionsets
Motorola 68000 series
VAX
PDP-11
x86
ARM
Stanford MIPS
MIPS
MIPS-X
Power
POWER
PowerPC
Power ISA
Clipper architecture
SPARC
SuperH
DEC Alpha
ETRAX CRIS
M32R
Unicore
Itanium
OpenRISC
RISC-V
MicroBlaze
LMC
System/3x0
S/360
S/370
S/390
z/Architecture
Tilera ISA
VISC architecture
Epiphany architecture
Others
ExecutionInstruction pipelining
Pipeline stall
Operand forwarding
Classic RISC pipeline
Hazards
Data dependency
Structural
Control
False sharing
Out-of-order
Scoreboarding
Tomasulo's algorithm
Reservation station
Re-order buffer
Register renaming
Wide-issue
Speculative
Branch prediction
Memory dependence prediction
ParallelismLevel
Bit
Bit-serial
Word
Instruction
Pipelining
Scalar
Superscalar
Task
Thread
Process
Data
Vector
Memory
Distributed
Multithreading
Temporal
Simultaneous
Hyperthreading
Simultaneous and heterogenous
Speculative
Preemptive
Cooperative
Flynn's taxonomy
SISD
SIMD
Array processing (SIMT)
Pipelined processing
Associative processing
SWAR
MISD
MIMD
SPMD
Processorperformance
Transistor count
Instructions per cycle (IPC)
Cycles per instruction (CPI)
Instructions per second (IPS)
Floating-point operations per second (FLOPS)
Transactions per second (TPS)
Synaptic updates per second (SUPS)
Performance per watt (PPW)
Cache performance metrics
Computer performance by orders of magnitude
Types
Central processing unit (CPU)
Graphics processing unit (GPU)
GPGPU
Vector
Barrel
Stream
Tile processor
Coprocessor
PAL
ASIC
FPGA
FPOA
CPLD
Multi-chip module (MCM)
System in a package (SiP)
Package on a package (PoP)
By application
Embedded system
Microprocessor
Microcontroller
Mobile
Ultra-low-voltage
ASIP
Soft microprocessor
Systemson chip
System on a chip (SoC)
Multiprocessor (MPSoC)
Cypress PSoC
Network on a chip (NoC)
Hardwareaccelerators
Coprocessor
AI accelerator
Graphics processing unit (GPU)
Image processor
Vision processing unit (VPU)
Physics processing unit (PPU)
Digital signal processor (DSP)
Tensor Processing Unit (TPU)
Secure cryptoprocessor
Network processor
Baseband processor

Word size
1-bit
4-bit
8-bit
12-bit
15-bit
16-bit
24-bit
32-bit
48-bit
64-bit
128-bit
256-bit
512-bit
bit slicing
others
variable
Core count
Single-core
Multi-core
Manycore
Heterogeneous architecture
Components
Core
Cache
CPU cache
Scratchpad memory
Data cache
Instruction cache
replacement policies
coherence
Bus
Clock rate
Clock signal
FIFO
Functionalunits
Arithmetic logic unit (ALU)
Address generation unit (AGU)
Floating-point unit (FPU)
Memory management unit (MMU)
Load–store unit
Translation lookaside buffer (TLB)
Branch predictor
Branch target predictor
Integrated memory controller (IMC)
Memory management unit
Instruction decoder
Logic
Combinational
Sequential
Glue
Logic gate
Quantum
Array
Registers
Processor register
Status register
Stack register
Register file
Memory buffer
Memory address register
Program counter
Control unit
Hardwired control unit
Instruction unit
Data buffer
Write buffer
Microcode ROM
Counter
Datapath
Multiplexer
Demultiplexer
Adder
Multiplier
CPU
Binary decoder
Address decoder
Sum-addressed decoder
Barrel shifter
Circuitry
Integrated circuit
3D
Mixed-signal
Power management
Boolean
Digital
Analog
Quantum
Switch

Powermanagement
PMU
APM
ACPI
Dynamic frequency scaling
Dynamic voltage scaling
Clock gating
Performance per watt (PPW)
Related
History of general-purpose CPUs
Microprocessor chronology
Processor design
Digital electronics
Hardware security module
Semiconductor device fabrication
Tick–tock model
Pin grid array
Chip carrier

Authority control databases: National Germany




Retrieved from "https://en.wikipedia.org/w/index.php?title=SPARC&oldid=1285966368"
Categories: Computer-related introductions in 1986SPARC microprocessor architectureSun microprocessors32-bit computers64-bit computersHidden categories: CS1: unfit URLArticles with short descriptionShort description matches WikidataUse mdy dates from August 2016Articles containing potentially dated statements from before 1990All articles containing potentially dated statementsCommons category link is on WikidataWebarchive template wayback links






 This page was last edited on 16 April 2025, at 22:08 (UTC).
Text is available under the Creative Commons Attribution-ShareAlike 4.0 License;
additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.


Privacy policy
About Wikipedia
Disclaimers
Contact Wikipedia
Code of Conduct
Developers
Statistics
Cookie statement
Mobile view














Search













Search









Toggle the table of contents







SPARC




























36 languages


Add topic
















